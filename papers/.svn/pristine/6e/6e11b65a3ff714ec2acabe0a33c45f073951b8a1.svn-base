\documentclass[english,a4paper,onecolumn]{article}
\usepackage[latin1]{inputenc}
\usepackage[dvips]{graphicx}
\usepackage{babel}
\usepackage{times}
\usepackage[lmargin=2.5cm,rmargin=2.5cm,tmargin=2.5cm,bmargin=2cm,nohead]{geometry}
\setlength{\parskip}{1.5ex}
\sloppy

\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}%, labelstep=0}
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinelanguage{DUMP} {
  keywords={line,type,type,operator}}
\lstdefinelanguage{JOINPOINT} {
  keywords={line,type,type,operator}}
\lstdefinestyle{prg} {basicstyle=\small\sffamily, lineskip=-0.2ex}
\lstdefinestyle{inlineprg} {basicstyle=\small\sffamily}

\newcommand{\prg}[4][tbp]{
  \begin{figure}[#1]
    \vspace{\parskip}
    \makebox[\columnwidth][c]{
      \lstinputlisting[language=#2,style=prg]{#3.prg}}
    \vspace{0.5\parskip}
    \caption{#4\label{prg:#3}}
  \end{figure}
}

\newcommand{\inlineprg}[2][C++]{
  \vspace{\parskip}
  \noindent\makebox[\columnwidth][c]{
    \begin{lstlisting}[language=#1,style=inlineprg]{}
      ^^J #2
    \end{lstlisting}}
  \vspace{0.5\parskip}
}

\def\textprg{\lstinline[language=C++,style=inlineprg]}

\newcommand{\fig}[3][tbp]{
  \begin{figure}[#1]
    {\centering{\includegraphics{#2}}\par}
    \caption{#3\label{fig:#2}}
  \end{figure}
}

\catcode`\<=\active
\catcode`\>=\active
\def<{$\char60$}
\def>{$\char62$}

\title{
  \textbf{Bridging AOP and SMP:\\ turning GCC into a metalanguage preprocessor}\\[7mm]
}

%\author{
%  \textbf{Tiago Stein D'Agostini} and  \textbf{Antônio Augusto Fröhlich}\\[2mm]
%  Federal University of Santa Catarina (UFSC)\\
%  Laboratory for Software/Hardware Integration (LISHA)\\
%  PO Box 476\\
%  88049-900 Florianópolis - SC, Brazil\\
%  \texttt{tiago@lisha.ufsc.br}\\
%}

\date{}


\begin{document}
\maketitle

%\begin{abstract}
  
%  The evolution of software engineering presented us with a variety of
%  tools and techniques in order to reach code separation of concerns,
%  modularity, generics and configurability. Among these techniques are
%  static meta-programming and aspect oriented programming. Although
%  similar in power and expressivity, one cannot fully replace the other
%  so that they must work together to obtain the best results.
%  Unfortunately there is no implementation of aspect weaver capable of
%  work in full association with static meta-programming. This paper
%  encompasses a proposal that aims at providing a solution for the use
%  of aspect-oriented programming along with meta-language capabilities
%  of moderns compilers and languages. By implementing a way to make
%  static meta-programming compatible not only with aspect-oriented
%  programming, but also with the possibility of extending this
%  compatibility to other technologies and even other languages.
%%Can I say that aspect oriented programming and static meta-programming are similar in expressivity? (it's something intuitive that.. but I need a reference.. or not say that at all
% \end{abstract}


\section{Introduction\label{sec:intro}}

The management of computer program's complexity has always been one of
the main challenges for software engineers. Methods and techniques to
manage the complexity of software, and perhaps even more important, to
manage the complexity of the software development process, have been
proposed as integral parts of software engineering strategies such as
\emph{Family-Based Design}~\cite{Parnas:1976},
\emph{Object-Orientation}~\cite{Wegner:1986}, \emph{Generative
  Programming}~\cite{Czarnecki:2000}, \emph{Application-Oriented System
  Design}~\cite{Froehlich:2001}, and many others.

In order to be effective as regards of complexity management, software
engineering strategies usually rely on language constructs and tools.
Indeed, the lack of proper language support was probably the reason why
\emph{Family-Based Design} could not achieve in the 70's what its niece,
\emph{Software Product Lines}~\cite{Weiss:1999}, is achieving nowadays.
For this paper, the language and tool support behind the main techniques
of \emph{Generative Programming}, i.e. \emph{Aspect-Oriented
  Programming}~(AOP)~\cite{Kiczales:1997} and \emph{Static
  Metaprogramming}~(SMP)~\cite{Pescio:1997}, are those of greater
interest.  These techniques make it possible for software engineers to
act upon the complexity of component-based software by the factorization
of non-functional aspects from software components and also by
supporting the enforcement of system-wide properties. Using these
techniques, a software engineering equipped with a domain engineering
strategy such as \emph{Application-Oriented System Design} should be
able to decompose a domain in software components that are less complex
and in smaller number than otherwise.

Nonetheless, both techniques, \textsc{AOP} and \textsc{SMP}, rely on
complex language and tool artifacts to achieve their goals. Static
meta-programming implies in a multi-level programming
language~\cite{Glueck:1997} and is better known from its implementation
in the \textsc{C++} programming language~\cite{Stroustrup:1986} via the
\texttt{template}\footnote{The support for static meta-programming in
  \textsc{C++} extends beyond the \texttt{template} mechanism,
  including, among others, function inlining, class constant attributes
  elimination, and short-circuit evaluation of constant expressions with
  elimination of unused code.}  mechanism~\cite{Stroustrup:1997,
  Veldhuizen:1995}.  \textsc{AOP}, besides implying in an
aspect-language such as \textsc{Aspect-J}~\cite{Coady:2001} or
\textsc{Aspect-C++}~\cite{Gal:2001}, also requires a tool, usually
called \emph{weaver}, to interweave component and aspect code.

As of today, there is no single tool capable of supporting AOP and SMP
techniques at the same time: \textsc{Aspect-J} is reaching maturity, but
\textsc{Java} does not support \textsc{SMP}; \textsc{C++} has full
support to \textsc{SMP}, but \textsc{Aspect-C++} is rather restrict when
the subject is weaving \texttt{templates}.  For this reason, both
techniques are seldom deployed together in the same project, thus
restricting the degree of adaptability and configurability that the
software can reach.

An additional complication regarding the deployment of \textsc{SMP} and
\textsc{AOP} techniques pertains the realm of embedded system. Many of
the $\mu$-controllers available today are distributed without any
object-oriented language support, usually restricting developers to the
features of the \textsc{C} programming language and consequently
preventing the use of advanced software engineering techniques. This is
a major constraint in a field of every-growing complexity.

This paper describes an approach to combine \textsc{SMP} and
\textsc{AOP} techniques in the context of the \textsc{C++} programming
language and to extend their benefits to platforms equipped solely with
a \textsc{C} compiler. The approach consists basically in modifying the
\textsc{GCC} \textsc{C++} compiler~\cite{GCC} to transform it into a
\emph{static meta-programming preprocessor} that parses the \textsc{C++}
input program, executes eventual metaprograms, and outputs the resulting
program as an equivalent \textsc{C} program. The \textsc{C} program can
subsequently be submitted to \textsc{Aspect-C}~\cite{Coady:2001} or
\textsc{Aspect-C++} for weaving or to any standard \textsc{C} compiler
for compilation.


\section{A few words on Aspects and Metaprograms\label{sec:aop-smp}}

\textsc{AOP} is often taken by its tools (i.e. \emph{aspect weavers}
and \emph{aspect languages}) instead of its principles. Indeed, its
tools are often deployed to ``patch'' defect systems instead of being a
support to handle non-functional properties of component-based software.
In case of properly designed software components, AOP can be practiced
even without its traditional tools. For instance, \emph{scenario
  adapters} are static metaprogrammed constructs that apply aspects to
components much in the AOP way, but without requiring a
weaver~\cite{Froehlich:sci:2000}. Nonetheless, the powerfulness of
modern aspect languages in what concerns the specification of joint
points\footnote{A joint point is a certain defined point in program
  execution where aspect code, usually known as advices, should be
  weaved. The join point mechanism of an aspect oriented programming
  language also include concepts as advices and pointcuts, allowing that
  the description of the aspect can indicate if it should be executed
  before the execution of the join point, after it, or other possible
  ways.} makes the weaver approach very sound.

On the other hand, \textsc{SMP} is often used in a mechanical way, with
programmers being mostly unaware that their class and function
\texttt{templates} will be executed during program's compilation.
Nonetheless, concrete deployment approaches were proved effective:
\emph{Generic Programming}~\cite{Musser:1989}, the \textsc{C++}
\emph{Standard Template Library}~\cite{Plauger:1995}, and, more
recently, \emph{Generative Programming}~\cite{Czarnecki:2000},

It is nothing but natural that versed software engineers combine AOP and
SMP techniques in their projects, and discourses aimed at convincing
adepts of one technique to migrate to the other, because allegedly
everything that can be done with one can also be done with the other,
play minor role here. Indeed, as regards programming languages,
\textsc{C++} and \textsc{Aspect-C++} seem to have already answered the
significant questions. In what concerns domain engineering,
\emph{Application-Oriented System Design}~\cite{Froehlich:2001} proposes
a strategy that is capable of bridging both realms.  This leads us to
the conclusion that what is really missing to bring \textsc{SMP} and
\textsc{AOP} together is mainly tool support.


\section{Alternatives to combine AOP and SMP\label{sec:alt}}

There are basically two alternatives to deliver the tool support needed
to combine AOP and SMP in the context of \textsc{C++}: including a
metaprogram execution environment inside the aspect weaver, or
delivering a metaprogram preprocessor to execute eventual metaprograms
in advance of the weaving process.

The first alternative, embedding a metaprogram execution environment
into the aspect weaver, seems to be of great complexity, for it would
require the aspect weaver to handle template resolution and
instantiation in order to properly manage join points. Template
resolution and instantiation are some of the most defying tasks for a
\textsc{C++} compiler~\cite{Siff:1996}: template instantiation requires
arguments to be checked against the language's type system, while
template resolution depends on sophisticated inference techniques specially in the case of function templates where the template parameter must be infered directly or inderectly from the function's parameter.
Furthermore, these would be nothing but fundamentals for any metaprogram
execution.

The second alternative, executing the metaprogram in advance, releases
the weaver from most of these tasks, since template resolution and
instantiation, type checking as well as all other tasks concerning
metaprogram execution are done by the \emph{metaprogram preprocessor}.
Nevertheless, this approach only makes sense if we take on a preexisting
\textsc{C++} compilation environment that is flexible enough to parse
the input program, execute eventual metaprograms, and export the
resulting single-level program before it is translated into intermediate
or machine-level language.  The pioneer \textsc{Cfront} \textsc{C++}
compiler~\cite{Stroustrup:1994} operated much in this way and would be a
powerful metaprogram preprocessor had it continued its evolution along
the language.

% verifique o parágrafo a baixo com muito cuidado, pois tive grande dificuldade para compreender o que tu querias dizer com o texto original (inglês???)
One remaining question to make the case in favor of an external
metaprogram preprocessor is the handling of join points targeting static
metaprograms themselves. Since the preprocessor would be executed in
advance of the weaver, metaprograms are no longer part of a program as
it reaches the weaver. Moreover, fragments of the original program
affected by metaprograms will look rather different in the preprocessed
output. All this could mislead the weaver to produce a corrupted final
program. However, as Veldhuizen observed
~\cite{Veldhuizen:c-templates-touring complete,Veldhuizen:template
  partial evaluation}, two level language introduced by \textsc{C++}
templates comes with the cost of a awkward syntax and coding style. This
syntax and coding style comprise the potential benefits of applying
aspects to static metaprograms since the direct application of aspects
into a metaprogram can produce undesired side effects. The simple
introduction of any code that cannot be handled at compile time inside
of a metaprogram would invalidate it, so most aspects developed to be
used in conventional programs are not compatible with staticaly solved
metaprograms.  From this point of view, restricting the application of
aspects only to metaprogram results is perfectly reasonable.
 
In the case of parametric classes the instanciation of the templates
will create new classes that can match with the aspect's join points.
Although, the correct handling of these join points may be influenced by
the support provided by the weaver to the proposed prepreocessor. This
support includes the capability of recognizing the newly created classes
as matchs for the join points targeting template instances.  Aiming to
reduce the complexity of the implementation of such support the
instantiataion of templates by the preprocessor follows naming rules as
simple as possible.  The name of a template's instance is exact original
instace declaration with the angle brackets exchanged by the underscore
character. The figure~\ref{fig:joinpoint} ilustrate a case where a
simple parametric class is used along with a simple \textsc{AspectC++}
aspect. At the stated example the \emph{joinpoints} of the aspect are
defined as the call of any member function named \emph{foo} from any
class that returns an integer, and also the call of any member function
named \emph{foo} from a X<int> class and that also returns an integer.
Both cases the match should be made with the function \emph{foo()} from
class \textsc{X\_int\_}. In the first case this match has no special
chracteristics since the advice will be applied to any class, but the
second example is not of a so direct resolution. The advice targeted a
member function of an instance of class \textsc{X<class T>} obtained
from \textsc{X<int>}. In the code where the aspect will be weaved there
will be no class named \textsc{X<int>}, but instead there will be a
\textsc{X\_int\_} class. The aspect weaver must be able to translate the
\textsc{X<int>} into \textsc{X\_int\_} and apply the aspect to the
correct target.

\prg{JOINPOINT}{joinpoint}{Example of parametric classes used along with
  aspect C++}

% ao invés disso, um exemplo simples de combinação de AOP e SMP onde um join point seja claramente definido 
%As we have seen, parametric classes, diferently from static metaprograms
%are preserved in the preprocessing and transformed in non-template
%classes. Concerning the parametric classes, the join point handling is
%deeply bound to the naming used in the new classes. The previously
%described rule of using a transformed version of the template with its
%actual parameters by replacing the angled brackets by underscore
%character present us with the possibility of simple solutions.


\section{The metaprogram preprocessor}

In the previous sections we signaled our preference for a
\emph{metaprogram preprocessor} as a tool to support the combination of
AOP and SMP.  In summary, deploying a preexisting compilation
environment to implement a metaprogram preprocessor seemed to be more
practical then embedding a metaprogram execution environment into an
aspect weaver.  The decision was also encouraged by the fact that the
\textsc{C++} compiler in the \textsc{GNU Compiler
  Collection}~\cite{GCC}, besides being an open-source compiler, also
proved very effective in handling the complex static metaprograms in
\textsc{Epos}~\cite{Froehlich:2001}, the project that motivated this
study.

Indeed, the current releases of \textsc{g++}\footnote{The results
  presented in this paper are based on a metaprogram preprocessor built
  over \textsc{g++} version 3.3.} can be used, unmodified, to parse a
\textsc{C++} compilation unit (input program), execute eventual
metaprograms, and dump the resulting parse-tree for further processing
by our tools. By invoking \textsc{g++} with the
\texttt{-fdump-tree-inlined}, we instruct the compiler to do exactly
that. Certainly, a parse-tree of this kind is not a \textsc{C++} program
and cannot be used as input to an aspect weaver, but it contains enough
information to sustain the reconstruction of a valid \textsc{C++}
program that is equivalent to the input program after the execution of
eventual metaprograms.

Indeed, in order to properly support \textsc{AOP} tools, the
reconstructed program must be more than logically equivalent to the
original program: it must preserve the overall structure of join points,
otherwise aspects defined to be used with the original code will not
produce the same results when applied to the reconstructed one (see
discussion in section~\ref{sec:alt}). That is the main reason why the
preprocessor cannot be implemented simply as a compiler back-end.

An schematic of the tool chain behind the metaprogram preprocessor is
depicted in figure~\ref{fig:overview}. The parse-tree dumped by
\textsc{g++} is subsequently fed into the \emph{reassembler} to
reconstruct the \textsc{C++} program that will be submitted to the
aspect weaver. In this way, SMP duties are processed first, followed by
AOP ones. An overview of the tool chain is depicted in
figure~\ref{fig:overview}.

\fig{overview}{An overview of the metaprogram preprocessing scheme.}


\subsection{The reassembler\label{reassembler}}

In order to sustain the subsequent discussion about the reassembling
tool, it is important to understand the basics of the parse-tree dumped
by \textsc{g++}. Therefore, let us take the classical factorial
metaprogram as an example (figure~\ref{prg:factorial}). This metaprogram
is able to calculate the factorial of any constant number for which the
function is defined during the compilation of the associated
\textsc{C++} unit.

\prg{C++}{factorial}{A statically metaprogrammed factorial calculator.}

The compilation of the program in figure~\ref{prg:factorial} causes the
\texttt{Factorial} metaprogram to be executed, producing an output
function \texttt{main} that barely returns \texttt{24} (the factorial of
4). The corresponding \textsc{g++} dump is presented in
figure~\ref{prg:dump}.  It consists of a set of parse trees, one for
each function defined in the program. The nodes of each tree represent
the symbols and types used in the function body, return statement and
parameter list. Additional nodes express the contents of the function
body as commands, expressions, scope delimiters, and flow control
statements of the language.

\prg{DUMP}{dump}{The parse-tree produced by \textsc{g++} for the
  factorial program above.}

While processing the parse-tree in figure~\ref{prg:dump}, the
reassembler would output a single declaration (node @1) for a function
(node @3), whose name is \texttt{main} (nome @2), that returns an
integer (node @6) and takes no parameters (node @15, type
\texttt{void}). The body of the function (node @4) consists of a
compound statement whose scope is defined by nodes @8 and @24 and whose
contents are defined by node @16: a return statement (node @23). The
returned expression (node @28) is of integer type (node @6) and has the
constant value 24 (node @29). The reassembler would thus produce the
following output:

\inlineprg{int main(void) \{ return 24; \}}

\noindent which is exactly the result of the execution of the metaprogram in
figure~\ref{prg:factorial}.

Note that the nodes representing types (e.g. node @6) are inserted in
the trees as they get used by functions. In this way, a type may be
described several times in the dump of a single compilation unit, one
for each referring function. Likewise, types that are not referred by
any functions do not appear in the dump. Note also that even built-in
types such as \texttt{integer} and \texttt{void} are listed.
Consequently, the reassembler must keep track of the types included in
the dump to avoid declaring a built-in type or declaring a type twice in
the corresponding output file. 


One relevant concern in the pre-processing of static metaprogramming is
the positioning of each structure in the output code. Though not shown 
in figure~\ref{fig:dump}, the parse tree dumped by \textsc{g++} also 
includes information about the original files in which a type was declared,
either in the compilation unit file or in one of the header files. 
The reassembler preserves this information in order to include declarations
and definitions at their original places while producing the output. 
This makes the treatment of classic code a simple task since the
\emph{classes} and \emph{structs} are rebuilt in their original header
files, or wherever they were described originaly. By using the file and line
informations retrieved from \textsc{gcc} this case has a straight solution. The
functions and expressions are also handled in a direct way during the
transverse so that the attainment of the mathematical and logical
expressions code is achieved by direct output of the transversed nodes of 
the function's body.

The first peculiarities arise when we start dealing with template
instantiation. Since the original code does not present us with a
\emph{class} but with the \emph{template} that represents a \emph
{family} of \emph{classes}, we have to output code that was not 
present at original source in order to represent the instantiate
templates. When new code is introduced at the program, there is a
special concern on where to introduce this code so that no side-effects
are created and the outputted code really represents the desired program
and still  valid as a \textsc{C++} program. The problem arises from the
fact that since templates are up to be solved classes or metaprograms they
can be instantiated with actual parameters from types that were not
declared at time of the template declaration, a property that is not
shared with common classes and structs. An example of that
situation is a simple parametric class named \textsc{A}, with a formal
type parameter \textsc{T} and containing  a member of type \textsc{T}.
After the declaration of the template at any point where a type \textsc{B}
has been declared  the template \textsc{A<B>} can be instanciated.
If we used the concept of declaring our new \textsc{A\_B\_} type at the 
same point where the original template was declared, a compilation error 
would be generated since we cannot have any class with members of type 
\textsc{B} before type \textsc{B} is declared.

To solve that problem we must introduce the new classes just prior to
the scope where the templates were instantiated.  At this position, the
types possibly used in the parameters of the template have already been
declared. The original code and resulting code of a simple example can
be seen at figure~\ref{prg:simple}.

\prg{C++}{simple}{Simple parametric class transformation.}

Although this approach may seem at first glance enough to translate
simple parametric classes, it doesn't contemplate to an exception in the
rule of using a type only after its declaration. That is the case when
we have two classes \textsc{A} and \textsc{B}, being the second nested
in the first one. In this case \textsc{class A} may have among its local
functions an inline one that makes use of type \textsc{B} before this
type is declared. This situation is demonstrated by fig
\ref{prg:nested}. In this situation if our new classes were declared
just before the function that uses the template the compiler would emit
en error, because class \textsc{X\_A\_} would declare a member of type
A, while this type is yet undeclared.

\prg{C++}{nested}{Nested classes with posponed instantiation}

In order to solve that possible instatiation problem, the implementation of
inline functions originaly implemented inside the class declaration are
moved to outside the class declaration. Also in the case where a
parameter of a template is not yet declared, the instantiation of the
template itself is postponed until this type is declared. 
Looking for keep the pre-processed code equivalent to the original one,
the postponed declarations have a foward declaration at their original location 
in the code, so that for example a function may have a return of the template 
instance's type.


\subsection{Integration with \textsc{Aspect-C++}\label{sec:aspectcpp}}

% detalhar e exemplificar a coexistência entre a tua ferramenta e o aspectc++

The effective use of the preprocessing technique to bridge  \emph{AOP} and \emph{SMP}
is bound to the support that \emph{AspectC++} weaver can provide to the combined use
with this preprocessor. The most obvious concern on that is the transparency of this 
process to anyone writing aspects. In other words this mean that the aspect developer 
ideally should not need to know how the preprocessed code will look like in order to 
decide about the aspect's join points . This can only be fully acomplished if 
\emph{aspectC++} weaver is capable of translating names of template instances present 
at aspects join points to the names that will be replacing those in the preprocessed code.

While \emph{AspectC++} still does not support this kind of preprocessing, the use of simple 
naming rules may allow that, even without direct support of AspectC++ for this tool,
 join points targeting the pre-processed code may be easily described by aspect developers.
 That means that if the aspect weaving tool does not offer the possibility of direct translation
from the original template join points, like \textsc{A<int>}, into the
new naming, \textsc{A\_int\_}, the developer can easily code its aspects
with the translated naming. This same simplicity is expected to make easier the
implementation of direct support from \emph{AspectC++}.



\section{Extending the use of the technique\label{sec:extending}}
%Provide some explanations about how that tool would be useful in the problem of converting C++ code into C code
The above exposed technique of \emph{template} pre-processing was originally envisioned to fulfill the requirements of \emph{aspect-oriented programming} and \emph{static metarprogramming} combined use. Without modifications it can also be used to replace template code in any circumstance where it can by any reason be undesirable. This kind of situation may arise whenever a tool must operate on \textsc{C++} code, while metaprogramming creates difficulties for that tool.

One importance example of when the replacement of \emph{template} code may be a gift, is the development of basic software or application software while targeting an architecture or platform that does not contemplate the user with a good \emph{static meta-programming} support on its compilers. That means it can prepare complex \textsc{C++} code to be compiled by less featured compilers such as those available to some $\mu$-controllers and other architectures.
A practical example of this situation would be the LanAI architecture that presents as latest \textsc{C++} support a \textsc{gcc} compiler at version 2.95. This version of the compiler is not capable of handling complex template features, making impossible to produce a port of operating systems like EPOS \cite{Froehlich:2001} that really on th use of \emph{static meta-programming}. By the use of a template pre-processor the \emph{static meta-programmed} code and \emph{parametric classes} could be solved with basis on a recent \textsc{gcc} compiler (version 3.2 by example) and after that have the final stage of compilation and code generation performed by any compiler with suitable port to the given architecture. 
A deeper extension of this idea could be used to assist the development of a \textsc{C++} into \textsc{C} language converter. This converter would be a possible solution for the application of \emph{object-oriented programming} when the targeting architecture is supported only by \textsc{C} language compilers. That situation is quite common and represents a restriction to the use of modern techniques in a large field of computer science.    


%since the lack of good C++ compiler will always be a problem
\section{Related Work\label{sec:relatedwork}}
%make some statements about Olaf's new paper

The works on compatibility between \emph{static metaprogramming} and \emph{aspect oriented programming} are few, 
and most of it if focused in the application of \emph{aspect oriented programming} by the use of 
\emph{static metaprogramming}, like  \emph{generative programming}~\cite{Czarnecki:2000}, \emph{application-oriented
system design}~\cite{Froehlich:2001}.   

The bridging between \emph{aspect oriented programming} and \emph{static metaprogramming} is deeply bounded to the 
small set of programing languages that support \emph{static metaprogramming} and the languahes that already have
an extension for \emph{aspect weaving}. The main efforts on using \emph{aspect oriented programming} in combination 
with languages that support \emph{metaprogramming} were made by \textsc{AspectC++}, since is the most advanced atempt
on providing \emph{aspect oriented programming} support to a \emph{metaprogramming} capable language. 
Currently AspectC++ is not yet able to apply templates on join points defined in parametric classes and template functions, 
although it is capable of parsing correctly template code and apply aspects to non template code used in same 
compilation units as template code. 
%-----
Recently \textsc{AspectC++} team has made a work in direction of supporting the use of templates in the aspects
themselves, an improvement that already bring us closer to a integration between the two technologies. Although 
this is already an improvement, it is still not enough to provide totally free combination of these technologies.

\section{Conclusion\label{sec:conclusion}}

This work focused on the combined use of static metaprogramming with weaving based aspect oriented programming tool. We defended that the combined use of both techniques, not its mutual exclusion, is the key for better modularity and configurability.

The best current opportunity on integrating both techniques is in \textsc{C++} programming language along with \textsc{AspectC++} aspect weaving mechanism. In order to eliminate the complexities of static metaprogramming tha have been delaying the use of \textsc{AspectC++} on template code, we present a pre-processor approach capable of transforming \textsc{C++} code in to equivalent \textsc{C++} code without templates or metaprograms.

More than a way for integrating an aspect oriented programming tool along with metaprogramming, we could show that this same approach may be extended to any technology currently incompatible with templates, including older or less featured compilers that are common on $\mu$-controllers.

Concerning the evolution of this concept and future work, we aim complete \textsc{C++} features support, as well the use of the technique here described to help in the problem of \textsc{C++} to \textsc{C} conversion that is most present in  the $\mu$-controllers world.

\bibliographystyle{plain}
\bibliography{guto,os,se}


\end{document}

