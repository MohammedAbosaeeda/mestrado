\section{Trabalhos Relacionados}
% Protocolos de Disseminação
% - tabela comparativa
% SOs embarcados
% - tinyos, sos, mantisos, retos, nano-kernel

\subsection{Protocolos de Disseminação}
%MOAP
\textit{Multi-hop Over the Air Programming} é um mecanismo de distribuição de código projetado priorizando o consumo de energia e memória em detrimento da latência \cite{moap}. O \textsc{MOAP} utiliza um mecanismo de disseminação chamado \textit{Ripple}, que distribui os dados de vizinhança em vizinhança. Em cada vizinhança apenas um pequeno subconjunto de nodos (de preferência apenas um) funcionam como emissores, enquanto os restantes são receptores. Quando os nodos recebem todos os dados eles podem se tornar emissores para seus próprios vizinhos (que estavam fora do alcance do emissor original). Para evitar que nodos se tornem emissores em uma vizinhança que já possua um, o mecanismo utiliza uma interface divulga/inscreve, nodos emissores divulgam sua versão e todos os interessados se inscrevem. Caso um emissor não receba inscrições ele fica em silêncio.

%Deluge
\textit{Deluge} é um protocolo de disseminação projetado para propagar uma grande quantidade de dados de forma rápida e confiável. Ele compartilha várias ideias com o \textsc{MOAP}, como o uso de NACKs, pedidos de retransmissão \textit{unicast} e transmissão de dados \textit{broadcast} \cite{deluge}. Com o intuito de limitar a quantidade de informações que um receptor deve manter, possibilitar atualizações incrementais e permitir que os nodos continuem a disseminação antes de possuírem todos os dados, o protocolo utiliza o conceito de páginas. Os dados são divididos em \emph{P} páginas, sendo que uma página nada mais é do que um conjunto de \emph{N} pacotes. Utilizando um vetor de idades para descrever a idade de cada página, os nodos são capazes de determinar quando uma página mudou e se necessitam ou não requisitá-la. Exigindo que os nodos recebam uma página por vez, pode-se utilizar um mapa de bits de apenas \emph{N} bits para gerenciamento de segmentos, pois não é mais necessário manter registros de todos os pacotes ao mesmo tempo.

%MNP
\textit{Multi-hop Network Programming} (MNP) é um protocolo de reprogramação em rede cujas principais características incluem um mecanismo para seleção de emissor e uma abordagem para reduzir o uso da memória RAM \cite{mnp}. Assim como no \textsc{MOAP} a disseminação ocorre de vizinhança em vizinhança e um nodo só pode se tornar emissor após receber todos os dados. Através do algoritmo para seleção de emissor, um nodo decide se deve transmitir o código ou não. O objetivo deste algoritmo é o de garantir que a qualquer momento apenas um nodo esteja transmitindo os dados por vez, e que este transmissor seja o que vai causar maior impacto, em outras palavras, o que tiver um maior número de receptores. É importante ressaltar que o algoritmo não garante encontrar o emissor ideal, todavia, ele seleciona ``bons'' emissores e reduz o número de colisões.

%Infuse
\textit{Infuse} é um protocolo de disseminação de dados baseado em uma comunicação sem colisões devido ao uso do MAC (\textit{Medium Access Control}) TDMA (\textit{Time Division Multiple Access}) \cite{infuse}. Este protocolo requer que os nodos conheçam tanto a sua localização como a de seus vizinhos, classificando-os em predecessores e sucessores. Assim um nodo ouve durante a faixa de tempo de seus predecessores para receber os dados e transmite durante a sua. A Tabela \ref{tab:prot} apresenta as prioridades dos protocolos analisados.

%Sprinkler
%\textit{Sprinkler} é um serviço de disseminação de dados projetado para ser energéticamente eficiente através da computação de um subconjunto de nodos emissores e do uso de TDMA \cite{sprinkler}. Assim como o \textit{Infuse}, o \textit{Sprinkler} também requer que os nodos saibam a sua localização. Além disto, este mecanismo assume que a distribuição dos nodos possua uma densidade mínima. Partindo destas duas premissas um CDS (\textit{Connected Dominating Set}) é computado e sobre este conjunto são calculadas faixas de tempo para uma transmissão TDMA através do algoritmo de coloração D-2. A disseminação é dividida em duas fases: \textit{Streaming}, onde apenas os nodos pertencentes ao CDS transmitem pacotes e \textit{Recovering}, quando nodos não pertencentes ao CDS enviam requisições por pacotes perdidos.

\subsection{Sistemas Operacionais Embarcados}
Alguns SOs embarcados são projetados com uma abstração para atualização de software. Através desta abstração é possível realizar reprogramações em tempo de execução sem a necessidade de reiniciar o sistema, desta forma, evitando perda de dados.

%TinyOS
\textsc{TinyOS} é um sistema operacional constituído de componentes reutilizáveis que são usados em conjunto formando uma aplicação específica \cite{tinyos}. Este SO suporta uma ampla gama de plataformas de hardware e tem sido utilizado em várias gerações de nodos sensores, podendo ser considerado o SO mais usado na área de RSSF. Ele apresenta um modelo de concorrência orientado a eventos e originalmente não suporta reconfiguração de software. Contudo, todos os protocolos apresentados anteriormente foram implementados utilizando o \textsc{TinyOS}, desta forma possibilitando a reconfiguração. 
%\textsc{TinyOS} é considerado o SO mais popular para RSSF. É um SO orientado a eventos e originalmente não suporta reconfiguração de software~\cite{hill00system}. Entretanto, diversos trabalhos têm sido realizados com o intuito de suportar reconfiguração no \textsc{TinyOS}~\cite{deluge, flexcup, mate}. \textsc{MantisOS} é outro SO para RSSF muito conhecimento no ambiente acadêmico, mas não suporta reconfiguração~\cite{mantis}.

%SOS
\textsc{SOS} é um sistema operacional constituído por módulos dinamicamente carregáveis e um \textit{kernel} \cite{sos}. Esses módulos enviam mensagens e se comunicam com o \textit{kernel} através de uma tabela do sistema que contém \textit{jumps} relativos. Desta forma o código em cada módulo torna-se independente de posição da memória, possibilitando alterações no software de maneira mais eficiente.
%\textsc{SOS} é um SO para RSSF que permite RDS~\cite{sos}. O SO é construído em módulos que são inseridos, removidos ou substituídos em tempo de execução. Através do uso de chamadas relativas, o código em cada módulo torna-se independente de posição da memória. \ELUS{} é conceitualmente similar aos trabalhos relacionados apresentados, porém a infra-estrutura do framework possui a vantagem de eliminar parte do sobrecusto associado às tabelas de indireção com o uso da metaprogramação estática. Tabela~\ref{tab:reconf2} revisa o processo de reconfiguração nos SOs embarcados analisados.

%Contiki
\textsc{Contiki} é um SO que possui uma estrutura de reconfiguração semelhante a do \textsc{SOS}. Ele implementa processos especiais, chamados \emph{serviços}, responsáveis por prover funcionalidades a outros processos~\cite{dunkels04contiki}. Esses serviços podem ser substituídos em tempo de execução através de uma \emph{interface stub} responsável por redirecionar as chamadas das funções para uma \emph{interface de serviço}, que possui ponteiros para as implementações atuais das funções do serviço correspondente. A Tabela \ref{tab:reconf2} resume o processo de reconfiguração nos SOs analisados.
%\textsc{Contiki} é um SO para RSSF que implementa processos especiais, chamados de \emph{serviços}, que provêem funcionalidades a outros processos~\cite{dunkels04contiki}. Serviços são substituídos em tempo de execução através de uma \emph{interface stub} responsável por redirecionar as chamadas das funções para uma \emph{interface de serviço}, que possue ponteiros para as implementações atuais das funções do serviço correspondente. \textsc{Contiki} somente permite a atualização de algumas partes do sistema.


%\textsc{Nano-Kernel} permite RDS das aplicações e dos componentes do kernel através da separação dos dados e dos algoritmos lógicos do kernel~\cite{Bagchi2008}. É criado um nível de indireção entre as aplicações e os dispositvos do kernel (e.g. escalonador, gerenciador de memória, etc). O núcleo do \textsc{Nano-Kernel} e os dispositivos do kernel se comunicam através de interfaces específicas que devem inicializadas na inicialização do sistema.

%RetOS
%\textsc{RETOS} implementa RDS através de relocação dinâmica de memória e ligação em tempo de execução~\cite{Cha2007}. O processo de relocação extrai informações de variáveis e funções globais em tempo de compilação (meta-informações) que são colocadas em um arquivo no formato \textsc{RETOS}. Tais informações são utilizadas pelo kernel para substituir todo endereço acessível de um módulo quando o estiver carregando. O SO possui uma tabela com endereços para funções de outros módulos. Um módulo registra, desregistra e acessa funções através desta tabela.

\begin{table}[ht]
 \footnotesize
 \begin{minipage}{0.5\textwidth}
  \centering
  \caption{Prioridades dos protocolos analisados.}
  \begin{tabular}{|l c c c|}
   \multicolumn{4}{}{} \\
   \hline
   Protocolo & Energia & Latência & Memória \\
   \hline
   MOAP   & 1º & 3º & 2º \\
   Deluge & 3º & 1º & 2º \\
   MNP    & 2º & 3º & 1º \\
   Infuse & 1º & 2º & 3º \\
   %Sprinkler & 1º & 2º & 3º \\
   \hline
  \end{tabular}
  \label{tab:prot}
 \end{minipage}
 \begin{minipage}{0.45\textwidth}
  \centering
  \caption{Processo de reconfiguração nos SOs analisados.}
  \begin{tabular}{{|c|p{5.8cm}|}}
   \multicolumn{2}{}{} \\
   \hline
   \textbf{SO} & \multicolumn{1}{c|}{\textbf{Processo de Reconfiguração}} \cr\hline
   \textsc{TinyOS}      &  \multicolumn{1}{c|}{Sem suporte direto.} \cr\hline
   %\textsc{RETOS}       & \multicolumn{1}{c|}{Relocação dinâmica e ligação em tempo de execução} \cr\hline
   %\textsc{Nano-Kernel} & \multicolumn{1}{c|}{Módulos reconfiguráveis} \cr\hline
   \textsc{SOS}         & \multicolumn{1}{c|}{Módulos reconfiguráveis.} \cr\hline
   \textsc{Contiki}     & \multicolumn{1}{c|}{Módulos reconfiguráveis.} \cr\hline
  \end{tabular}
  \label{tab:reconf2}
 \end{minipage}
\end{table}
