\documentclass{SBACpaper} 
\usepackage{epsf}

\newcommand{\tild}{\raisebox{-.75ex}{\~{}}}
\newcommand{\putfig}[5]{
  \begin{figure}[hbt]
  \centerline{\epsfxsize=#2\epsfysize=#3\epsfbox{#1}}
  \caption{\label{#4}#5}
  \end{figure}
}

\begin{document}
\pagestyle{empty}

\title{High Performance Application-Oriented\\Operating Systems -- the {\sc Epos} Approach\thanks{This research has been partially supported by Federal University of Santa Catarina, by CAPES Foundation grant no. BEX 1083/96-1 and by Deutsche Forschungsgemeinschaft grant no. SCHR 603/1-1.}}

\author{Ant\^onio Augusto Fr\"ohlich\inst{1},
Wolfgang Schr\"oder-Preikschat\inst{2}}

\institute{GMD FIRST\\
Rudower Chaussee 5\\
12489 Berlin, Germany\\
{\tt guto@first.gmd.de}
\and
University of Magdeburg\\
Universit\"atsplatz 2\\
39106 Magdeburg, Germany\\
{\tt wosch@cs.uni-magdeburg.de}}

\maketitle

\begin{abstract}

This paper presents the {\sc Epos} approach to bring object-oriented operating systems closer to high performance parallel applications. The gap between them originates from the complexity of assembling an operating system out of a complex collection of complex classes. {\sc Epos} aims to deliver, whenever possible automatically, a customized runtime support system for each application. In order to achieve this, {\sc Epos} introduces the concepts of {\em scenario-independent system abstractions}, {\em scenario adapters} and {\em inflated interfaces}. An application designed and implemented following the guidelines behind these concepts can be submitted to a tool that will proceed syntactical and data flow analysis to extract a blueprint for the operating system. This blueprint is then refined by dependency analysis against information about the execution scenario acquired from the user via visual tools. The outcome of this process is a set of {\em selective realize keys} that will support the generation of the application-oriented operating system.

\end{abstract}


\begin{keywords}
Object-oriented operating systems, parallel operating systems, high performance computing.
\end{keywords}


\section{Introduction}

Until some years ago, high performance was an attribute associated basically to platforms running scientific computations and databases. Nowadays, more and more applications demand for such platforms: virtual reality, Web servers and even embedded systems are pushing hardware and support software for parallelism. In this context, many research projects are trying to produce low overhead operating systems that do not impact applications as much as their all-purpose relatives. 

	Our experiences developing runtime support systems for parallel applications~\cite{Preikschat:book:94} convinced us that adjectives such as ``all-purpose'' and ``generic'' do not fit together with ``high performance'' and ``parallel'', whereas different parallel applications have quite different requirements regarding the operating system. Even apparently flexible designs, like $\mu$-kernel based operating systems, may imply in waste of resources that otherwise could be used by applications. These observations regarding parallel applications must also hold for any application demanding non-conventional support services. Therefore, each application must have its own runtime support system, specifically designed and implemented to satisfy its requirements (and nothing but its requirements).

	This paper presents the {\sc Epos} approach to deliver a high performance, application-oriented operating system to each parallel application. The following sections describe the motivation for {\sc Epos}, its fundamentals, its design and its implementation. Afterwards, some preliminary results are presented together with an outline for the project continuation.


\section{Motivation for EPOS}

Automatic tailoring an operating system for a given application is a challenging task that starts with the fabrication of the building blocks that will be used to assemble the operating system. A straightforward approach to conceive building blocks is to take on object orientation and its corresponding tools. In this case, reusable operating system building blocks are implemented by classes and are stored in a repository (often a class library). This approach does not produce an operating system, but a collection of classes that can be specialized and combined to yield a variety of operating systems.

	Although effective, the development of operating systems based on object-oriented building blocks brings along a new issue: how to put the building blocks together. The intrinsic nature of this approach also gives rise to a gap between that what the building blocks repository offers and that what the application programmers are looking for. Paradoxically, this gap grows proportionally to the system evolution, since the most the system evolves, the larger is the number of components in the repository and the more complex they are  (due to an increase in the abstraction level).

	Expecting an application programmer to browse a class repository to select and adapt (by aggregation or inheritance) the classes that would conduct to the best, or at least to a good, operating system for his application is not realistic. {\sc Epos} main goal is to automate the process of selecting and adapting building blocks to yield an application-oriented operating system.

	{\sc Epos} is actually an extension of the {\sc Pure}~\cite{Schoen:98} family based operating system, since {\sc Pure} supplies the building blocks that {\sc Epos} utilizes to assemble application-oriented operating systems. The approach followed by {\sc Pure} is to understand an operating system as a {\em program family}~\cite{Parnas:79} and to use {\em object orientation}~\cite{Wegner:86} as the fundamental implementation discipline. {\sc Pure} building blocks are implemented as C++ classes and are designed to be portable and not to incur in unnecessary overhead. Therefore, {\sc Pure} classes are ideal to construct any sort of operating system.

	However, {\sc Pure} has not been conceived to be used by application programmers. As an example of the complexity of generating an operating system out of {\sc Pure} classes, let us consider a simple nucleus to support preemptive multi-threading in a C 167 $\mu$-controller: the nucleus would be comprised by more than 100 classes exporting over 600 methods~\cite{Beuche:99}. Although the resulting nucleus would not be larger than 4 Kbytes, generating it is not a trivial task.

\section{Fundamentals of EPOS}

In order to deliver application-oriented operating systems, {\sc Epos} adhere to the following guidelines:

\begin{itemize}
\item High performance: {\sc Epos} shall give each application its own runtime support system, which shall include only those components that are really necessary to support it. Operating system components shall be as adaptable as possible, thus granting the lowest possible overhead. Besides implying in tools to analyze and generate the operating system, this goal also demands for a comprehensive repository of system components.

\item Invisibility: when requested to support the execution of parallel applications formerly implemented to run on a {\sc Unix} system, specially those conforming to the MPI standard for message passing, {\sc Epos} shall support them without being visible, i.e., without requiring any modification in the application's source code. Invisibility is achieved in {\sc Epos} by supporting some {\sc Unix} APIs, including runtime libraries ({\tt libc}, {\tt libm}, {\tt libstdc++} and {\tt libf2c}), {\sc Posix} file handling, and MPI. However, as {\sc Epos} does not share any development aspect with {\sc Unix}, most of its invisibility is gained by either porting libraries or implementing abstraction layers. For instance, {\sc Posix} is supported by stubs that redirect file operations to a file server running on an I/O node, and a subset of MPI is supported as an interface on top of {\sc Epos} communication abstractions. The little scientific character of this goal gives it a low priority.

\item Static configuration: guided by the high performance goal of {\sc Epos}, we decided that static configuration will have priority over dynamic. This decision arises from the fact that very few dynamic reconfigurations, in a high performance scenario, pay off the overhead to support them. Even the adoption of a dynamic prototype that would collect information about an ideal static system configuration has been suppressed, since the intrinsic overhead of a dynamic system would distort the figures for the static one. Instead, {\sc Epos} shall take on profiling to enable static reconfiguration towards the optimal.

\item Parallelism in distributed memory architectures: {\sc Epos} shall extend {\sc Pure} to include abstractions to support parallel computing in distributed memory architectures. This is an open goal that starts with the definition of abstractions for processes, synchronization and communication and shall evolve with applications.
\end{itemize}


\section{Design of EPOS}

{\sc Epos} has been designed to reduce the gap between {\sc Pure} building blocks and parallel applications. However, differently from {\sc Pure}, that adopts the {\em program families} design strategy and relies on object orientation solely as an implementation discipline, {\sc Epos} follows the fundamentals of object-oriented design as proposed by Booch~\cite{Booch:94}. The design strategy of {\sc Epos} defines three main elements: {\em scenario-independent system abstractions}, {\em scenario adapters}, and {\em inflated interfaces}. The two first elements tackle the gap by hiding {\sc Pure} building blocks and by supporting an efficient way to construct application-ready system abstractions; the third element exports the system abstraction repository in a fashion tractable by application programmers.

\subsection{Scenario-independent System Abstractions}

By observing {\sc Pure} class repository, we concluded that several classes are not of interest to application programmers. Moreover, we concluded that, differently from an application programmer, a system programmer could easily configure a bulk of application-ready classes. In {\sc Epos}, we name these application ready classes {\em system abstractions} and we define that it is due to the system development team to construct them. This definition, besides establishing a clear boundary between {\sc Pure} and {\sc Epos}, will render a system abstractions repository with fewer components than the respective {\sc Pure} building blocks repository.

	In turn, when we analyzed our first abstractions, we observed that those designed to present the same functionality in different execution scenarios are indeed quite similar. Moreover, abstractions conceived to support the same scenario often differ from each other following a pattern. For instance, two {\em thread} abstractions, one targeting a single-task and the other a multi-task environment, present several similarities. Likewise, a {\em thread} abstraction targeting a multi-processor scenario reveals synchronization mechanisms that can also be found in the {\em mailbox} abstraction, since invoking methods of both abstractions implies in synchronizing eventual parallel invocations (from different processors). In this way, we propose system abstractions to be implemented as independent from the execution scenario as possible. These adaptable and scenario-independent system abstractions would then be put together with the aid of some sort of ``glue'' specific to each scenario. We named these ``glues'' {\em scenario adapters}, since they will adapt an existing system abstraction to a certain execution scenario.


\subsection{Scenario Adapters}

Being able to design and implement scenario-in\-depen\-dent system abstractions gives us a chance to considerably save development time, since many system abstraction can now be reused in different execution scenarios. However, writing aspect independent abstractions and adapting them to new scenarios is everything but trivial. So far, we succeeded in adapting system abstractions to specific execution scenarios by wrapping them with {\em scenario adapters}. Actually, scenario adapters are not restricted to wrap system abstractions; they can also wrap, when necessary, lower level building blocks. With this strategy we have implemented, for example, a {\em thread} abstraction that can be adapted to be used with single or with multiple address spaces, that can be linked to the application or integrate a $\mu$-kernel, and that supports either local or remote invocation.

	In general, aspects such as application/operating system boundary crossing, concurrent invocation synchronization, remote object invocation, debugging and profiling can be easily modeled with the aid of scenario adapters, thus making system abstractions, even if not for complete, independent from execution scenarios.

	The approach to write pieces of software that are independent from certain aspects and later adapt them to a given scenario has been referred to as {\em Aspect-Oriented Programming}~\cite{Kiczales:97}. We refrain from using this expression because for {\sc Epos}, differently from AOP, factors such as languages to describe aspects and tools to automatically adapt components ({\em weavers}) are irrelevant. If ever present in {\sc Epos}, AOP would give means, not goals. Currently, scenario adapters are implemented in {\sc Epos} using the same language used to implement system abstractions, and most of them are implemented by hand.


\subsection{Inflated Interfaces}

The combination of scenario-independent system abstractions and scenario adapters reduces the number of components in the system abstraction repository, yields application-ready abstractions and enables the automatic generation of new abstractions. However, this is not enough to bring the process of operating system construction to the application programmer level. In {\sc Epos}, this task is due to a set of automatic tools, in such a way that application programmers are no longer requested to browse repositories and to specialize or combine classes. The concept of {\em inflated interfaces} enables these tools and gives programmers a better way to express their applications' needs.

	An {\sc Epos} {\em inflated interface} embraces most of the consensual definitions for a system abstraction. It is inflated because it brings together not a single view of the abstraction it exports, but a collection of its most usual representations. Examples of inflated interfaces are {\em thread}, {\em task}, {\em address space} and {\em communication channel}. The inflated interface for the {\em thread} abstraction gathers several different views of it, including, for example, {\em pthreads} and native {\sc Pure} {\em threads}. Multiple interfaces for an abstraction are only introduced when incoherent views have to be exported. {\sc Epos} inflated interfaces are extracted from classical computer science books and system manuals, nevertheless, our users, i.e., application programmers, are welcome to suggest modifications or extensions at any time.

	The adoption of inflated interfaces for system abstractions enables the application programmer to express his expectations regarding the operating system simply by writing down well-known system object invocations (system calls in non object-oriented systems). It is important to notice that inflated interfaces are mere tools to export system abstractions. They are never implemented as they are seen by the programmer, i.e., as a single class, but as a set of scenario specific classes. When configuring the system, each inflated interface is bound to one of its scenario specific implementations.


\subsection{Selective and Partial Realize Relationships}

In order to support system design based on inflated interfaces, we propose two new object-oriented design notations: {\em partial realize} and {\em selective realize}. Both notations represent relationships taking place between an inflated interface and a class that realizes that interface. However, as the name suggests, a class participating in a partial realization implements only a specific subset of the corresponding inflated interface. In this scope, selective realization means that only one of several possible realizations is connected to the inflated interface at a time. These two design notations are depicted in figure \ref{realize}.

\putfig{fig/realize.eps}{84mm}{0mm}{realize}{Partial realize (a) and selective realize (b) relationships.}

	Each class joining a selective realize relationship is tagged with a key. By defining a value for this key, a specific, usually partial, realization for that interface is selected. However, during system design, these keys are not supposed to assume any value, so that an inflated interface is considered to be bound to any of its realizations. The definition of selective realize keys are due the operating system generator and are not considered at design time.

	Partial and selective realize design notations have their counterparts for system implementation, so that configuring an operating system can be done simply by defining values for selective realize keys. These keys are defined in a single configuration file and make conditional compilations and ``makefile'' customizations obsolete. Furthermore, the implementation of these relationships may be used to bind non object-oriented inflated interfaces to object-oriented implementations. This is useful, for instance, to bind an application written in Fortran or C to {\sc Epos}.

\section{Implementation of EPOS}

With the design techniques described earlier, we can now consider the automatic generation of an appli\-ca\-tion-oriented operating system. Our strategy begins top-down at the application, when the programmer implicitly specifies the operating system requirements simply by designing and coding his application while referring to the set of inflated interfaces that exports the system abstractions repository. An application designed and implemented in this fashion can then be submitted to an analyzer (figure \ref{analyzer}) that will conduct syntactical and data flow investigations to determine which system abstractions are really necessary and how they are invoked. The outcome of this analysis is a blueprint for the operating system to be constructed, and will define, for instance, the use of multi-tasking instead of single-tasking, of multi-threading instead of single-threading, of  protected address spaces instead of a single unprotected address space and so on.

\putfig{fig/analyzer.eps}{84mm}{0mm}{analyzer}{Extracting an operating system blueprint.}

	Our primary operating system blueprint is, unfortunately, not complete, since there are aspects that cannot be deduced while analyzing the application. For example, the decision of whether the operating system will include support for multi-tasking or not, cannot be made based only on the application. The fact that the application does not show any evidence that multiple processes may need to run concurrently in a single processor does not necessarily mean that this situation will not occur. The multi-tasking support may be required because the application needs more processors than what is available. Several other relevant factors are often not expressed inside the application and therefore we still need user intervention to describe the application's execution scenario. However, in {\sc Epos}, the description of available resources is due to the operating system development team and the interaction with the user is done through visual tools. 

	Refining the operating system blueprint, by way of dependency analysis while taking in consideration the context information acquired from the user, renders a much more precise description of how the ideal operating system for a given application should look like. This refined blueprint can now be used to bind the inflated interfaces referred in the application to scenario specific implementations. For example, the inflated thread interface from the first step may have included remote invocation and migration, but reached the final step as a simple single-task, priority-scheduled thread for a certain $\mu$-controller. The organization of an application-oriented operating system generated according to this model is depicted in the figure \ref{epos_application}.

\putfig{fig/epos_application.eps}{54mm}{0mm}{epos_application}{Organization of an application tailored {\sc Epos}.}

	 It is important to understand that, at the early stages of the operating system development, very often a required system abstraction will not yet be available. Even then, the proposed strategy is of great value, since the operating system developers get a precise description for the missing system abstractions. In many cases, a missing system abstraction will be quickly (automatically) adapted from another scenario using the scenario adapters described earlier.

	Only if the operating system developers are not able to deliver the requested system abstractions in a time considered acceptable by the user, either because a system abstraction with that functionality have not yet been implemented for any scenario, or because the requested scenario is radically different from the currently supported scenarios, the user will be asked to select the best option from the available set of system abstractions (scenario adapters) and to adapt his program. In this way, our strategy ends where most configurable operating systems begin. Moreover, after some development effort, the combination of scenario adapters and system abstractions shall satisfy the big majority of parallel applications.
	

\section{Preliminary Results}

So far we have implemented several system abstractions and scenario adapters that have been put together to assemble a few application-oriented operating systems. Perhaps, the most interesting example we can now cite is a communication channel implemented for our cluster of SMP PCs interconnect by a Myrinet network~\cite{Froehlich:euromicro:98}. Very often we face the assertion that moving communication to user level alone can bring the figures for communication close to the best. However, this affirmation is usually stated in disregard to the restrictions imposed by ordinary operating systems, like Unix and Windows NT. These systems always operate in multi-task mode, requiring the memory to be paged and avoiding the direct use of DMA to transfer a user message from host memory to the memory in the network adapter. A copy to a contiguously allocated buffer or the translation of addresses (for each memory page) has to be carried out.

	However, if we consider parallel applications, which usually run on a single-task-per-node basis, the multi-task ``feature'' of the operating system turns into pure overhead. For multi-threaded applications, the situation is even worse, because the pipeline implemented by the most efficient user-level communication packages for Myrinet running on Unix~\cite{Prylli:98, Tezuka:97}, which should hide the extra message copy overhead, loses its effectiveness when the pipeline stage responsible for the copy concurs with other threads for the memory bus.

	We measured performance of the same communication abstraction in two execution scenarios: single-task and multi-task. The communication abstraction is the same in both cases, but a scenario adapter that performs a copy to a temporary buffer wraps it in the second case. The figures for sending messages from one node to another are depicted in figures \ref{latency} and \ref{bandwidth}, and show a difference, in favor of the single-task configuration, of about 22\% for messages of 16 bytes and 46\% for 64 Kbytes messages. Besides demonstrating the featherweight structure of {\sc Epos}, this example shows that it is worthwhile to give each application its own operating system.

\putfig{gnu/latency.eps}{84mm}{0mm}{latency}{Time to send a message in {\sc Epos}.}

\putfig{gnu/bandwidth.eps}{84mm}{0mm}{bandwidth}{Send bandwidth in {\sc Epos}.}


\section{Related Work}

Several research projects aim to deliver operating systems that can be configured to better support a given application. They usually follow one of two strategies: kernel extensions or component based system construction. We discuss some of these projects according to the strategy they follow.

	Operating system kernel extensions are usually accomplished by a $\mu$-kernel, which implements a small set of functionality, and by a mechanism that enables applications to extend its functionality according to their needs. {\sc Spin}~\cite{Bershad:sosp:95} supports system functions, written in a specific language, to be safely downloaded into the kernel from any application.  {\sc Vino}~\cite{Seltzer:osdi:96} supports application code to run in the kernel address space and uses software fault isolation as a safety mechanism to avoid malicious extensions. {\sc Exokernel}~\cite{Engler:sosp:95} focuses on the separation of protection and management so that physical resources are securely exported to be managed by applications at user-level.

	Projects in the second alternative, component based construction, usually relies on an object-oriented framework that supports system construction from a set of reusable classes. {\sc Choices}~\cite{Campbell:87}, one of the pioneers with this strategy, demonstrated the viability to build complex operating systems in an object-oriented framework. {\sc Peace}~\cite{Preikschat:pc:94} follows a family based design to implement an operating system family that comprise members to deal with specific classes of parallel applications. {\sc Flux}~\cite{Ford:sosp:97} abolishes the ``core of functionality'' and defines a framework in which a large set of components can be used to assemble an operating system.

	EPOS approach is orthogonal to the monolith/$\mu$-kernel/library organization, since a proper organization can be selected for each system. Just like in {\sc Flux}, the concept of a core of functionality is absent in {\sc Epos}. It differs from {\sc Spin}, {\sc Vino}, {\sc Exokernel} and {\sc Flux} in the sense it aims to deliver application-ready operating systems, while these systems only support constructing them. Similarly to {\sc Choices} and {\sc Peace}, {\sc Epos} defines an object-oriented framework, however, since it benefits from {\sc Pure} fine-grain building blocks to implement its system abstractions, {\sc Epos} framework supports the construction of true application-oriented operating systems.


\section{Further Work}

The strategy to generate application-oriented operating systems proposed by {\sc Epos} can drastically improve application performance, because applications get only the operating system components they really need, and also because these components are fine-tuned to the aimed execution scenario. However, our strategy is not able to deliver an {\em optimal} operating system. Consider, for instance, the decision for a thread scheduling policy: several thread implementations, with different scheduling policies, may fit into the blueprint extracted by our tools, as long as they match the selected interfaces and satisfy the dependencies. Nevertheless, it is unnecessary to say that there is an optimal scheduling policy for a given set of threads running in a given scenario.

	The decision of which variant of a system abstraction to select when several accomplish the application's requirements is, in the current system, arbitrary. Further development of {\sc Epos} shall include {\em profiling} primitives to collect runtime statistics. These statistics will then drive operating system reconfigurations towards the optimal. To grant an {\em optimal} system, however, would imply in formal specification and validation of our system abstractions, what is not in the scope of {\sc Epos}.


\section{Conclusion}

In this paper we presented the {\sc Epos} approach to deal with the gap between object-oriented operating systems, specifically {\sc Pure}, and high performance parallel applications. {\sc Epos} utilizes {\sc Pure} building blocks to implement a set of {\em scenario-independent system abstractions} that can be adapted to a given execution scenario with the aid of {\em scenario adapters}. These abstractions are collected in a repository and are exported to the application programmers via {\em inflated interfaces}. This strategy, besides drastically reducing the number of exported abstractions, enables the programmers to easily express their application's requirements in regard to the operating system.

	An application designed and implemented according to the strategy proposed in this paper can be submitted to a tool that proceeds syntactical and data flow analysis to extract a blueprint for the operating system to be generated. The blueprint is then refined by dependency analysis against information about the execution scenario acquired from the user via visual tools. The outcome of this process is a set of {\em selective realize} keys that supports the compilation of the application-oriented operating system. 

	The results obtained so far demonstrate the viability of constructing application-oriented operating systems and also the benefits an application can get by running on its own  system. However, {\sc Epos} is now closer to its beginning than to its end: we have quite few scenario adapters implemented and the tools described in this paper are under construction. 

\bibliographystyle{alpha}
\bibliography{operating_systems,software_engineering,communication,guto}
 
\end{document}







