%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[english,a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{times}
\usepackage{graphicx}
\usepackage{url}
\usepackage[right=2.5cm,left=2.5cm,top=2.5cm,bottom=2.5cm,nohead]{geometry}

\newcommand{\fig}[3][htbp]{
  \begin{figure}[#1] {\centering\scalebox{1}{\includegraphics{fig/#2}}\par}
    \caption{#3\label{fig:#2}}
  \end{figure}
}

\title{On Operating Systems for Reconfigurable Computing}

\author{Antonio Augusto Frohlich and Wolfgang Schröder-Preikschat}

\begin{document}

\maketitle

\begin{abstract}

The abstract ...

\paragraph{Keywords:} keywords ...

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction\label{sec:intro}}

% Make the case for reconfigurable computing
The forthcoming of dynamically reconfigurable hardware architectures is
motivating several research projects and is coining a new term:
\textbf{reconfigurable computing}. In currently available
Field-Programmable Gate Arrays (FPGAs), elementary functional units
physically implemented in hardware can be grouped together, or
programmed, to shape more sophisticated components, whose purpose is
dictated by particular system needs. Some FPGAs allow for partial
reprogramming of specific blocks on-the-fly, while others retain their
original program, thus leading to the notion of "reconfigurable
computing", in which the computer as a whole, software and hardware, can
be dynamically adapted according to varying application requirements
during its operation time \cite{Compton:2002}. More recent
architectures, such as those based on MRAM, forecast an even broader
scenario for reconfiguration as they allow for dynamic modification in
the wiring of elementary functional units, taking reconfiguration to the
level of individual gates \cite{Koch:2005}.

% State the problem: operating system support
% - Application-driven and Instruction-level are just parts of the problem
% - OS-level abstractions can improve on it: well defined building-blocks for ReComp

% State the solution: reuse previous knowledge
% - Basic infrastructure for reconfiguration
% - Plus services that resemble resource management
%   - Traditional OS resources: CPU time, memory, disk, etc
%   - ReComp resources: traditional plus chip area, energy, performance
% - What we need is a component architecture capable of embracing all this

% Describe the paper

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reconfigurable Computing\label{sec:recomp}}

% Make the case for reconfigurable computing
The forthcoming of dynamically reconfigurable hardware architectures is
motivating several research projects and is coining a new term:
\textbf{reconfigurable computing}. In currently available
Field-Programmable Gate Arrays (FPGAs), elementary functional units
physically implemented in hardware can be grouped together, or
programmed, to shape more sophisticated components, whose purpose is
dictated by particular system needs. Some FPGAs allow for partial
reprogramming of specific blocks on-the-fly, while others retain their
original program, thus leading to the notion of "reconfigurable
computing", in which the computer as a whole, software and hardware, can
be dynamically adapted according to varying application requirements
during its operation time \cite{Compton:2002}. More recent
architectures, such as those based on MRAM, forecast an even broader
scenario for reconfiguration as they allow for dynamic modification in
the wiring of elementary functional units, taking reconfiguration to the
level of individual gates \cite{Koch:2005}.

% Application-driver reconfigurable computing
The inherent flexibility of reconfigurable computing has the
potentiality to sustain a new generation of electronic devices that are
able to self-modify themselves according to user's needs. A cell phone,
for instance, could be reconfigured to perform the functions of a PDA,
MP3 player, digital camera, navigation system, game pad, among others.
Note that this is a scenario completely different from nowadays'
multipurpose gadgets, which require specific circuitry to be integrated
for each function they are supposed to perform. A reconfigurable cell
phone would instead reprogram its hardware and software building blocks
on-the-fly, just as the user selects a different function. If the gadget
were to perform as an MP3 player, reprogramming would give rise to a
specific audio decoder. While performing a game pad, reprogramming would
probably build a kind of graphics processing unit (GPU). In this
example, reconfiguration is directly dictated by the distinct
applications, which explicitly activate the reprogramming of building
blocks as they are activated \cite{Agarwal:1999}.

% Instruction-level reconfigurable computing
Another reconfigurable computing scenario that has been consistently
explored by researchers regards the implicitly reconfiguration of
hardware components without direct intervention by applications. This
perspective of reconfigurable computing is based on the constant
monitoring of hardware operational conditions, so as to initiate a
pre-programmed reconfiguration whenever the associated conditions are
observed. A good example of this kind of reconfiguration is a processor
that is able to instantiate additional functional units as it detects
overload situations. For instance, an application that runs into a heavy
floating-point operations cycle would induce the processor to
instantiate an additional floating-point unit (FPU) along with the
structures needed to operate both units in parallel \cite{Taylor:2004}.

% OS supported reconfigurable computing
In both scenarios, the main benefit associated to reconfigurable
computing techniques is the possibility of reusing hardware and software
components for multiple purposes, eliminating undesirable resource
replications and allowing the system to go with requirements that were
not initially taken in consideration. Eliminating replicated components
directly improves metrics such as size and power consumption, while
increasing reusability and flexibility directly affect non-recurring
engineering costs. Nonetheless, in order to achieve these benefits, it
is not enough that designers base their projects on FPGAs that support
partial reconfiguration: a complete infrastructure, at both sides
software and hardware, is necessary to support a truly reconfigurable
computer.

% It went wrong once (Apertos), will it work now?
A dynamic reconfiguration support system able to identify "which",
"when" and "how" hardware and software components must be reconfigured
in order to adapt a computing system to particular application demands
is still far away. Indeed, some researchers predict that the
computational cost of such infrastructure is more likely to overwhelm
the benefits associated with the technology \cite{???}. This prediction
is perhaps motivated by the history of dynamically reconfigurable
operating systems of the 80s and 90s, like \textsc{Apertos}
\cite{Yokote:1992} and \textsc{Ethos} \cite{Szyperski:1992}, whose
reconfiguration infrastructure incurred in very high run-time overhead,
preventing them from reaching the market despite all claimed advances.
Notwithstanding, the actual scenario for reconfigurable computing is
more hardware-bound then that of the 90s and is bringing about new
opportunities that must be investigated from a more contemporary
perspective.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Operating Systems for Reconfigurable Computing\label{sec:os}}

% Demystify ReCOS: resources are resources

% Infrastructure for ReComp: replugging of components

% Granularity of components: AOSD

% Introduce the basic idea for software/hardware coexistence as regards
% application requirements such as real-time, advanced algorithms,
% energy consumption, etc

% Reasoning about things that can be reused/adapted from todays OOSS

\subsection{Scheduling\label{sec:sched}}

% Schedulers implemented in hardware can tackle on TLBs (associative
% memory) in order to search the ready queue in parallel, yielding high
% determinism and low jitter

% Hardware-Software interaction:
% - Hardware: running, ready queue, timers, policy, traps the software
%   for context switch
% - Software: context switch, insertion/remotion in ready queue,
%   suspended queue

\subsection{Synchronization\label{sec:sync}}

% Synchronizers implemented in hardware can tackle on a state machine to
% overcame the traditional two-memory-cycle mechanisms (e.g. tsl, finc,
% xchg): each thread access a different element of the synchronizer by
% combining the target address with the thread ID

% Hardware-Software interaction:
% - Hardware: state machine and slot table with one slot per thread
% - Software: reads the synchronizer state
 
\subsection{Memory\label{sec:mem}}

% A memory model can be devised such that complex elements (e.g. MMU)
% are enabled on demand. If memory allocation for single task is kept
% track by the OS, than an MMU can be instantiated when multiple tasks
% are required by the application (e.g. by a fork syscall).

\subsection{I/O\label{sec:io}}

% Components are instantiated on demand: UART, Ethernet, etc

\subsection{Coprocessors\label{sec:coproc}}

% An Instruction Set Architectures can feature advanced instructions
% that are executed by coprocessors (e.g. FPU, MMX) that are only
% instantiated when such instructions are decoded.

\subsection{Interaction with Applications\label{sec:app}}

% If the OS encapsulate complex functional units as components (e.g.
% filesystem, dsp, multimedia), than usage can be tracked as to decide
% when a software component must be replaced by its counterpart in
% hardware and vice-versa.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Software-Hardware Architecture for Reconfigurable Computing\label{sec:arch}}

\subsection{Components\label{sec:components}}

% pre-compiled software and hardware components

% automatic partitioning in languages such as SystemC are yet far away

% Infrastructure for dynamic reconfiguration is needed

\subsection{Component Replugging\label{sec:replug}}

% Component plugs and component outlets

% Component state save/restore

\subsubsection{Extension\label{sec:replug-ext}}

% Demand loading

\subsubsection{Contraction\label{sec:replug-cont}}

% Garbage collection

\subsubsection{Replacement\label{sec:replug-rep}}

% Context save, contraction, extension

\subsection{Component Repository\label{sec:repository}}

% Components usually cannot be preloaed into RAM, for ucontrollers simply don't have enough of that

\subsubsection{Local\label{sec:local}}

% Flash with a repository of pre-compiled software and hardware components

\subsubsection{Remote\label{sec:remote}}

% Dynamic fetch over the net

\subsection{Performance X Area X Energy\label{sec:fpga}}

% Just like memory management? 

% Usage counters not only for energy management, but also for garbage collection of components no longer in use


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Works\label{sec:related}}

% Case studies

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Perspectives\label{sec:conslusion}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{selection}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
