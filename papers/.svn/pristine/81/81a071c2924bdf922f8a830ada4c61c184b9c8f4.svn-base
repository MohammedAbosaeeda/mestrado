% ------------------------------------------------------------------------------
\subsection{Dedicated hardware}
% ++ Dedicated hardware
% Describes how data transference is implemented: buses, etc.
% Describes how synchronization is implemented: Barriers like mechanisms
% implemented in hardware
In the last few years, advances in \textit{electronic design automation}~(EDA) tools are allowing
hardware synthesis from high-level behavioral models. This process is known as \textit{high-level
synthesis}~(HLS) and allows designers to describe hardware components using languages like C++, and
higher-level techniques, such as \textit{Object-Oriented Programming}~(OOP). In this work we
leverage on HLS technology to obtain a dedicated hardware implementation of DMEC. The main goal of
providing hardware DMEC is to show that the same interface defined for the previous
implementations can also be used in this case. Additionally, this section highlights the reusability
and flexibility of our implementation. Through a simple code refactoring process, we have converted
our multicore implementation to a synthesizable behavioral hardware model.

Figure \ref{fig:dmec_hw_hls} gives an overview of the HLS process and the refactored code. The HLS
tool we have used (Calypto's CatapultC~\cite{Calypto:Catapult}) does not work with the concept of
tasks and threads, but it extracts parallelism by exploiting the parallelization of \emph{loops}. To
cope with such approach, we have serialized the execution of the tasks performed by the
\emph{Coordinator} and the \emph{Workers}. The \emph{SynchronizationManager} now defines internal
buffers for the pictures and the resulting motion estimation vectors, coordinating the transfer
of data between these elements and the main memory. The ME algorithm is implemented in a loop in
which each iteration performs the task of one \emph{Worker}. By using \emph{synthesis
directives} we can guide the HLS process in order to obtain parallelism. Figure
\ref{fig:dmec_hw_hls}
shows that the directive \emph{UNROLL} is set for the \emph{workers\_loop}, indicating that this
loop should be fully unrolled. In the HLS context, fully unrolling a loop means that all
iterations are performed in parallel. There are other forms of loop parallelization. For instance, 
loops can be pipelined in order to reduce hardware area while keeping the same throughput. To match
the multicore behavior in which all workers execute in parallel, we have chosen to fully unroll
only the top-lovel loop. Additional directives were set to pipeline inner parts of the ME algorithm
whenever possible. 

\fig{0.6}{dmec_hw_hls}{High-level synthesis process for the generation of a dedicated hardware
implementation}

The output of the HLS process are \emph{register transfer level}~(RTL) descriptions in
VHDL or Verilog that can be used as input for most RTL
synthesis tools. CatapultC also generates cycle- and bit-accurate SystemC models
for design verification and evaluation. Figure \ref{fig:dmec_hw_eval} shows a block diagram of the
final RTL implementation generated by CatapultC and its integration with the evaluation
infrastructure.

\fig{0.6}{dmec_hw_eval}{HW DMEC evaluation infrastructure}

The final component uses a simple handshaking mechanism for input/output data. This interface is
adapted for the AMBA AXI4 bus, a widely used standard for on-chip interconnect of functional
blocks. Our performance evaluation is based on simulation of the SystemC model generated by
CatapultC. A model of the AXI4 bus model is provided for interfacing the cycle-accurate hardware
simulation with the remaining infrastructure.

In the software side, an implementation of the \emph{PictureMotionEstimator} interface serializes
the pictures and copies the data to the hardware component internal buffers using a memory mapped
interface. Once the ME is complete, the motion vectors are read and used to build the
\emph{PictureMotionCounterPart} object which is returned to the test application.


% ------------------------------------------------------------------------------
