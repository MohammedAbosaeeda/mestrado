<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="description" CONTENT="Mitteilungen">
   <META NAME="keywords" CONTENT="feb98">
   <META NAME="resource-type" CONTENT="document">
   <META NAME="distribution" CONTENT="global">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; SunOS 5.5.1 sun4m) [Netscape]">
   <TITLE>Mitteilungen  </TITLE>
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<LINK REL=STYLESHEET HREF="feb98.css">
</HEAD>
<BODY LANG="DE">
<IMG SRC="next_motif_gr.gif" ALT="next" HEIGHT=24 WIDTH=37 ALIGN=BOTTOM>&nbsp;<A NAME="tex2html1" HREF="../"></A><A HREF="http://www.inf.fu-berlin.de/gi/fb3/fa31/fg314/mitteilungen/" NAME="tex2html1"><IMG SRC="up_motif.gif" ALT="up" HEIGHT=24 WIDTH=26 ALIGN=BOTTOM></A>&nbsp;<IMG SRC="previous_motif_gr.gif" ALT="previous" HEIGHT=24 WIDTH=63 ALIGN=BOTTOM>
<BR><B>Up:</B>&nbsp;<A NAME="tex2html2" HREF="../"></A><A HREF="http://www.inf.fu-berlin.de/gi/fb3/fa31/fg314/mitteilungen/" NAME="tex2html2">Mitteilungen
der Gi Fachgruppe 3.1.4 - Betriebssysteme</A>

<P><IMG SRC="gi-logo.gif" ALT="GI-Logo" HSPACE=10  ALIGN=LEFT>
<H3>
Gesellschaft&nbsp;<BR>
f&uuml;r Informatik e.V.</H3>
<B>Leitung der Fachgruppe 3.1.4</B>
<BR><B>Betriebssysteme</B>
<CENTER>
<H3>
Einladung</H3></CENTER>
zum Fr&uuml;hjahrstreffen
<BR>am 16./17. M&auml;rz 1998 in Berlin

<P>Die Schwerpunkte des Treffens sind diesmal:
<CENTER></CENTER>

<CENTER>``Betriebssysteme f&uuml;r Eingebettete Systeme'' und</CENTER>

<CENTER>``Objektorientierung in Betriebssystemen''</CENTER>
Zur Teilnahme f&uuml;llen Sie bitte das beiliegende Anmeldeformular aus
und schicken es bis sp&auml;testens

<P><B>2. 3. 1998</B>

<P>an den lokalen Organisator
<BLOCKQUOTE><TT>Friedrich Sch&ouml;n</TT>
<BR><TT>GMD FIRST</TT>
<BR><TT>Rudower Chaussee 5</TT>
<BR><TT>D-12489 Berlin</TT></BLOCKQUOTE>

<PRE><B>Tagungsort:</B>&nbsp; GMD FIRST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rudower Chaussee 5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D-12489 Berlin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Geb&auml;ude 13.10
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seminarraum 006
<B>Beginn:</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16. 3. 1998, 13.00 Uhr
<B>Ende:</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17. 3. 1998, 16.00 Uhr</PRE>
<B>Hotelreservierungen</B> m&uuml;ssen selbst vorgenommen werden. F&uuml;r
weitere Hotelhinweise und An- und Abreisem&ouml;glichkeiten steht Ihnen
die Web-Seite <TT><A HREF="http://www.first.gmd.de/~fs/gifg314">http://www.first.gmd.de/~fs/gifg314</A></TT>
zur Verf&uuml;gung. Herr Sch&ouml;n (Tel. <TT>030-6392-1838</TT>) oder
Herr Dr. Nolte (Tel. <TT>030-6392-1841</TT>) helfen Ihnen bei Fragen gerne
weiter. Die Fax-Nr. in beiden F&auml;llen lautet <TT>030-6392-1805</TT>.

<P><IMG SRC="gi-logo.gif" ALT="GI-Logo" HSPACE=10  ALIGN=LEFT>
<H3>
Gesellschaft&nbsp;<BR>
f&uuml;r Informatik e.V.</H3>
<B>Fachgruppe 3.1.4</B>
<BR><B>Betriebssysteme</B>

<P>Herrn
<BR>Friedrich Sch&ouml;n
<BR>GMD FIRST
<BR>Rudower Chaussee 5
<BR>D-12489 Berlin
<CENTER>
<H3>
Anmeldung</H3></CENTER>
zum Treffen der GI-Fachgruppe ``Betriebssysteme'' am 16./17. M&auml;rz
1998 in Berlin.

<P><IMG SRC="img1.gif" ALT="tabular100" HEIGHT=248 WIDTH=604 ALIGN=BOTTOM>

<P><IMG SRC="img2.gif" ALT="tabular127" HEIGHT=15 WIDTH=599 ALIGN=BOTTOM>

<P><IMG SRC="gi-logo.gif" ALT="GI-Logo" HSPACE=10  ALIGN=LEFT>
<H3>
Gesellschaft&nbsp;<BR>
f&uuml;r Informatik e.V.</H3>
<B>Leitung der Fachgruppe 3.1.4</B>
<BR><B>Betriebssysteme</B>

<P><B>Programm</B>

<P><IMG SRC="img3.gif" ALT="tabular164" HEIGHT=782 WIDTH=644 ALIGN=BOTTOM>

<P><IMG SRC="gi-logo.gif" ALT="GI-Logo" HSPACE=10  ALIGN=LEFT>
<H3>
Gesellschaft&nbsp;<BR>
f&uuml;r Informatik e.V.</H3>
<B>Leitung der Fachgruppe 3.1.4</B>
<BR><B>Betriebssysteme</B>

<P><B>Kurzfassungen</B>
<BR>&nbsp;
<BR>der Beitr&auml;ge zum Fr&uuml;hjahrstreffen
<BR>am 16./17. M&auml;rz 1998 in Berlin
<OL>
<LI>
<B>OSEK/VDX: Ein Betriebs- und Kommunikationssystem f&uuml;r den Einsatz
in Kraftfahrzeugen</B>, R. Kern, Georg-Simon-Ohm-Fachhochschule N&uuml;rnberg</LI>


<P>OSEK (Offene Systeme und deren Schnittstellen f&uuml;r die Elektronik
im Kraftfahrzeug) = OSAN (Open Systems in Automotive Networks). VDX (Vehicle
Distributed Executive, franz&ouml;sisches Partnerprojekt).

<P>Bei OSEK handelt es sich um ein Gemeinschaftsprojekt von Automobilindustrie,
Hochschulen, Hardware- und Software- Herstellern mit dem Ziel, einen Industrie-Standard
f&uuml;r eine ,,offene`` (herstellerunabh&auml;ngige) Architektur f&uuml;r
verteilte Systeme zur Steuerung von Fahrzeugen zu entwickeln. Die Implementierung
der spezifizierten Schnittstellen bleibt frei und ist damit dem Wettbewerb
unterworfen. Sie soll mit minimalem Hardware-Aufwand (insbesondere beim
RAM) auskommen, aber engen Zeitbedingungen gen&uuml;gen k&ouml;nnen. Die
OSEK-Spezifikation umfa&szlig;t drei Hauptbestandteile:
<OL>
<LI>
OSEK-OS (OSEK operating system): Konzept und Aufrufschnittstelle (API)
f&uuml;r ein spezialisiertes (lokales) Echtzeit-Betriebssystem. Hauptmerkmale:</LI>

<UL>
<LI>
Nur f&uuml;r eingebettete (statische) Anwendungssysteme gedacht, daher</LI>

<LI>
&nbsp;keine dynamische Betriebsmittelverwaltung,</LI>

<LI>
&nbsp;sehr stark eingegrenzter Funktionsumfang,</LI>

<LI>
&nbsp;eingeschr&auml;nkte Fehlerbehandlung,</LI>

<LI>
&nbsp;stattdessen auf geringen Speicherbedarf und schnelle Reaktionsf&auml;higkeit
getrimmt,</LI>

<LI>
&nbsp;flexible Konfigurationsm&ouml;glichkeiten,</LI>

<LI>
&nbsp;Erleichterung der Portierbarkeit auf Anwendungsebene durch vorgegebene
Konformit&auml;tsklassen.</LI>
</UL>

<LI>
OSEK-COM (OSEK communication): Kommunikationssystem auf Feldbusbasis im
Kraftfahrzeug (in Anlehnung an den CAN-Bus, aber auch f&uuml;r andere Bussysteme
offen). In diesem Teil ist auch die lokale Interproze&szlig;kommunikation
enthalten (Ortsunabh&auml;ngigkeit).</LI>

<LI>
&nbsp;OSEK-NM (OSEK network management): Netz-Management auf der Basis
von OSEK-COM.</LI>


<P>Die OSEK-Komponenten sollen durch komfortable Werkzeuge f&uuml;r
<UL>
<LI>
Entwicklung,</LI>

<LI>
&nbsp;Konfiguration,</LI>

<LI>
&nbsp;statische Fehlererkennung und</LI>

<LI>
&nbsp;Test und Simulation</LI>
</UL>
erg&auml;nzt werden, die aber durch OSEK nicht n&auml;her spezifiziert
sind.</OL>

<LI>
<B>Ein Kommunikationsrahmenwerk als Teil eingebetteter Systeme</B>, F.
Sch&ouml;n, GMD FIRST</LI>


<P><I>Beitrag wird nachgeliefert.</I>
<LI>
<B>Generische Komponenten zur Konstruktion anwendungsangepa&szlig;ter Laufzeitplattformen</B>,
L. Baum, M. Becker, L. Geyer, G. Molter, Universit&auml;t Kaiserslautern</LI>


<P>Betriebssysteme bilden die Realisierungsgrundlage f&uuml;r ann&auml;hernd
jede Art von Softwarel&ouml;sung. Das Spektrum der von Betriebssystemen
zu erbringenden Leistungen beispielsweise betreffend Funktionalit&auml;t,
Performance oder adquate Programmierschnittstellen variiert dabei u.U.
erheblich. Gerade bei eingebetteten Systemen besteht aufgrund verschr&auml;fter
Ressourcenknappheit ein besonderes Interesse, die eingesetzten Laufzeitplattformen
optimal auf die Anforderungen der Anwendung abzustimmen.

<P>Eine derartige Maschneiderung eines Betriebssystems ist im weitesten
Sinne eine Konfigurationsaufgabe. Unser vornehmliches Augenmerk liegt dabei
auf einer statischen Konfiguration, d.h. der Zusammenstellung und Anpassung
einer geeigneten Laufzeitumgebung zum Entwicklungszeitpunkt des Systems.
Die Maschneiderung soll sowohl bez&uuml;glich funktionaler Aspekte (erbrachte
Funktionalit&auml;t, Schnittstellen, etc.) als auch nicht-funktionaler
Aspekte (Zeit- und Speicherkomplexit&auml;t, Fehlertoleranz, etc.) durch
Anwendungsanforderungen gesteuert erfolgen. Hierbei ist eine weitgehende
Werkzeugunterst&uuml;tzung des Vorgangs bis hin zu einer Teilautomatisierung
w&uuml;nschenswert. Der von uns verfolgte Ansatz beruht auf der Komposition
ma&szlig;geschneiderter Laufzeitplattformen aus geeignet zu konfigurierenden
generischen Komponenten. Generische Komponenten sind hierbei Softwarebausteine,
deren funktionale Schnittstellen und nichtfunktionale Eigenschaften in
begrenztem Umfang angepa&szlig;t werden k&ouml;nnen, ohne notwendigerweise
manuelle Ver&auml;nderungen am Komponentenkode vornehmen zu m&uuml;ssen.
Wesentliche Bestandteile generischer Komponenten sind sogenannte generische
Parameter, die der Wahl der Komponenteneigenschaften dienen. Wir unterscheiden
hierbei grunds&auml;tzlich drei Typen solcher Parameter: Selektionsparameter,
Generierungsparameter und Kodeparameter.

<P>Selektionsparameter w&auml;hlen diskrete Elemente wie Datenstrukturen,
Algorithmen, kleinere Kodeteile oder ganze Komponenten aus einer endlichen
Menge vordefinierter Varianten. So l&auml;&szlig;t sich beispielsweise
&uuml;ber einen Selektionsparameter einer Speicherverwaltungskomponente
eine geeignete Variante w&auml;hlen, die sowohl den zu Verf&uuml;gung stehenden
Ressourcen wie Speicherplatz und Rechenzeit, als auch den diesbez&uuml;glichen
Charakteristika der geplanten Anwendung m&ouml;glichst gut Rechnung tr&auml;gt.
Diesem Parametertyp liegt ein Ansatz zugrunde, der generische Komponenten
als eine Menge vorimplementierter Komponentenvarianten auffa&szlig;t. Selektionsparameter
w&auml;hlen dabei genau eine solche Variante aus, ohne daran Ver&auml;nderungen
vorzunehmen. In einer verfeinerten Sichtweise kann eine solche Auswahl
nicht nur vollst&auml;ndige Komponenten, sondern auch einzelne Komponententeile
betreffen.

<P>Generierungsparameter steuern die werkzeugunterst&uuml;tzte Erzeugung
von Komponenten mit gew&uuml;nschten Eigenschaften. Einfache Generatoren
k&ouml;nnen auf diese Weise z.B. Zahlenkonstanten einf&uuml;gen, Quelltextoptimierungen
vornehmen oder Funktionsnamen anpassen. Leistungsf&auml;higere Generatoren
sind in der Lage, Komponentenkode aus abstrakteren Beschreibungen zu erzeugen.
Beispielsweise kann f&uuml;r eine Scheduler-Komponente die Implementierung
einer anwendungsspezifischen Schedulingstrategie aus einer vom Benutzer
vorgegebenen SDL-Spezifikation generiert werden. Im Gegensatz zur Verwendung
vorimplementierter Varianten werden hierbei generische Parameter als Platzhalter
in einer abstrakten formalen Beschreibung, der sogenannten Gerstinformation,
aufgefa&szlig;t. Diese Gerstinformation kann selbst z.B. aus Quelltext
oder einer SDL-Spezifikation bestehen. Die Anpassungsm&ouml;glichkeiten
beschr&auml;nken sich in diesem Fall nicht mehr auf den Austausch existierender
Komponentenvarianten bzw. ihrer Bestandteile, sondern werden durch die
F&auml;higkeiten der Generatoren bestimmt.

<P>Wo hochgradig individuelle Anpassungen erforderlich sind, die nicht
automatisiert durch Generatoren vorgenommen werden knnen, erlauben es Kodeparameter,
individuelle Ver&auml;nderungen am Komponentenkode vorzunehmen. Der Benutzer
einer Komponente kann mit diesen Parametern z.B. eine selbstdefinierte
Proze&szlig;kontrollblock-Datenstruktur zur Feinanpassung einer Scheduling-Komponente
oder einen nicht vorimplementierten Algorithmus einf&uuml;gen. Kodeparameter
sind mit einem Realisierungsansatz f&uuml;r generische Komponenten korelliert,
der die Bereitstellung vordefinierter Implementierungsl&uuml;kken vorsieht.
Der Anwender hat an diesen Stellen die M&ouml;glichkeit, selbst in die
Komponentenimplementierung einzugreifen, mu&szlig; sich im Regelfall aber
auch an bestimmte Randbedingungen wie vorgegebene Schnittstellen halten.
Allen drei genannten Parametertypen ist die Tatsache gemein, da Komponenten
mit den gew&uuml;nschten Eigenschaften in einem werkzeugunterst&uuml;tzten
Instanziierungsvorgang aus generischen Komponenten respektive ihren Gerstinformationen
und den Belegungen ihrer generischen Parameter gewonnen werden. Die unterschiedlichen
Parametertypen spiegeln sich lediglich im Ablauf des Instanziierungsschrittes
wieder. Im Falle von Selektionsparametern besteht die Gerstinformation
aus den vorimplementierten Varianten, von denen entsprechend der Parameterbelegung
eine unver&auml;ndert &uuml;bernommen wird; das Instanziierungsergebnis
ist identisch mit einem Teil der Gerstinformation. Bei der Verwendung von
Generierungsparametern wird aus Gerstinformation und Parameterwerten neuer
Kode erzeugt, und im Falle von Kodeparametern sind Parameterwerte unver&auml;ndert
zu &uuml;bernehmende und in die Gerstinformationen einzuf&uuml;gende Kodeteile.
Ein Instanziierungsschritt kann das Entstehen einer wiederum generischen
Komponente mit neuen, anderen generischen Parametern zur Folge haben, was
eine iterative Anwendung der Instanziierung nach sich zieht. Die genannten
Parametertypen k&ouml;nnen dabei in beliebiger Kombination auftreten.

<P>Auf Implementierungsebene k&ouml;nnen generische Parameter durch eine
Reihe von Mechanismen unterst&uuml;tzt werden. Selektionsparameter lassen
sich im einfachsten Fall durch die Verwendung separater Quelltextdateien
modellieren. Pr&auml;prozessoren erlauben dar&uuml;ber hinaus die einfache
Auswahl von Quelltextteilen und unterst&uuml;tzen somit feingranularere
Selektionsparameter. Spezialisierte Werkzeuge k&ouml;nnen mit Hilfe geeigneter
Markierungen im Quelltext die Funktion von Standard-Pr&auml;prozessoren
&uuml;bernehmen und spezifisch erweitern. Auf diese Weise werden neben
Selektionsparametern auch Generierungsparameter unterst&uuml;tzt, sofern
die Gerstinformation selbst aus Quelltext besteht. Neben diesen Verfahren
zur Auswahl und Manipulation von Quelltext bietet die Mehrzahl der Programmiersprachen
Konzepte zur generischen Programmierung an, beispielsweise mittels Templates,
Vererbung oder Casting. Mit diesen programmiersprachlichen Mitteln werden
die Voraussetzungen f&uuml;r Kodeparameter geschaffen, z.B. durch Vorgabe
von Interfaces oder Spezifikationen.

<P>Die generische Auslegung von Komponenten erlaubt deren einfache Anpa&szlig;barkeit
an unterschiedliche Anforderungen und somit ihren Einsatz in verschiedenen
Systemumgebungen. Einem erh&ouml;hten Anfangsaufwand f&uuml;r die initiale
Bereitstellung derart flexibler Softwarekomponenten steht somit eine Steigerung
des Wiederverwendungspotentials gegen&uuml;ber, die eine Vereinfachung
der Konstruktion anwendungsangepa&szlig;ter Laufzeitplattformen f&uuml;r
eingebettete Systeme bis hin zu einer Teilautomatisierung verspricht.
<LI>
<B>Werkzeuggest&uuml;tzte Konfigurierung und Adaptierung</B>, R. Meyer,
Universit&auml;t Potsdam</LI>


<P>Betriebssysteme operieren in einer extrem heterogenen Umwelt. Dies gilt
sowohl f&uuml;r die zugrundeliegende Hardware als auch f&uuml;r die durch
Applikationen gestellten Anforderungen. Zum einen wird eine effizienzorientierte
Betriebssystemsicht immer danach trachten, die L&uuml;cke zwischen den
Applikationsanforderungen und der existierenden Hardware durch jeweils
dediziert entwickelte Abstraktionen schlie&szlig;en zu wollen. Dem steht
jedoch der Wunsch nach Wiederverwendbarkeit und vertrauten und damit beherrschbaren
Programmiermodellen entgegen. Einen hoffnungsvollen Ansatz zur L&ouml;sung
dieses Dilemmas bietet das Konzept der Programmfamilien. Die Idee, jeweils
in einzelnen Familienmitgliedern nur eine minimale Basis an Funktionalit&auml;ten
zu implementieren, die jeweils nur um unumg&auml;nglich notwendiges minimal
erweitert werden, lie&szlig; sich erfolgreich auch auf Betriebssysteme
&uuml;bertragen (PEACE, PURE).

<P>Bisher kaum erforscht in diesem Umfeld ist ein konsistenter Ansatz zur
Konfigurierung solcher Systeme, der sowohl eine Erstkonfigurierung (incl.
Generierung) als auch die dynamische Rekonfigurierung, insbesondere Adaptierung
zur Laufzeit umfa&szlig;t.

<P>Im Vortrag soll ein im Rahmen eines Promotionsvorhabens entwickelter
Ansatz vorgestellt werden, der die dynamische Rekonfigurierung (von au&szlig;en
gesteuert) sowie die automatische Adaptierung an eine sich &auml;ndernde
Umgebung erm&ouml;glicht. Hierzu wird ein eigenst&auml;ndiges Konfigurierungsmodell
angewandt, welches Applikations- bzw. Systemcode von konfigurierendem Code
explizit unterscheidet. Konfigurierungscode wird in diesem Modell in Konfigurierungsobjekten
gekapselt. Da sich Konfigurierungsma&szlig;nahmen durchaus &auml;hneln,
wiederholen oder gar repliziert erscheinen, wird Wiederverwendbarkeit von
Konfigurierungsobjekten durch erweiterbare Konfigurierungsklassen angestrebt,
welche in Bibliotheken gesammelt werden sollen.

<P>Dieser Ansatz wird in einen an den Universit&auml;ten Magdeburg und
Potsdam in der Entwicklung befindlichen Betriebssystembaukasten integriert
werden. Dieses Projekt einer in C++ implementierten ,,Werkbank`` zur Generierung
und Rekonfigurierung von familienorientierten Betriebssystemen wird auch
einen grafischen Editor zur dynamischen Konfigurierung beinhalten, der
es dem Benutzer erlaubt, Rekonfigurierungsma&szlig;nahmen direkt auszul&ouml;sen
und zu kontrollieren. Hierbei wird das zugrundeliegende Konfigurierungsmodell
direkte Anwendung finden.
<LI>
<B>Werkbank zum Bau ma&szlig;geschneiderter Betriebssysteme</B>, D. Beuche,
U. Haack, W. Schr&ouml;der-Preikschat, O. Spinczyk, Otto-von-Guericke-Universit&auml;t
Magdeburg</LI>


<P>Unter ,,ma&szlig;geschneiderten Betriebssystemen`` verstehen wir Betriebssysteme,
die sich in Struktur und Funktionalit&auml;t den Bed&uuml;rfnissen gegebener
Anwendungen und Hardware-Plattformen optimal anpassen k&ouml;nnen. Entsprechend
der klassischen Vermittlerrolle zwischen Anwendungen und Hardware bedeutet
dies die Anpa&szlig;barkeit ,,nach oben`` <I>und</I> ,,nach unten``. Dabei
wird die Forderung nach dynamischer Anpa&szlig;barkeit zur Laufzeit zun&auml;chst
einmal als zweitrangig angesehen, obgleich ihre technische Umsetzung eine
gro&szlig;e Herausforderung im Betriebssystembau darstellt. Im Gegensatz
dazu wird der statischen Anpa&szlig;barkeit des Betriebssystems zur &Uuml;bersetzungs-
bzw. Bindezeit eine vorrangige Bedeutung beigemessen, da sie die Voraussetzung
f&uuml;r die dynamische Variante darstellt. Die G&uuml;te der statischen
Anpa&szlig;barkeit ist eine Frage der Software-Struktur, insbesondere des
Grades der Modularit&auml;t und der Komplexit&auml;t der Moduln. Ma&szlig;geschneiderte
Betriebssysteme sind anwendungsorientierte und ,,schlanke`` Betriebssysteme,
die genau aus nur den Moduln bestehen, die zur Erbringung der durch den
Einsatzbereich geforderten Funktionalit&auml;t auch notwendig sind.

<P>Der Trend geht hin zu anwendungsbezogenen Betriebssystemen, d.h. es
werden Systeme angestrebt, die in Art und Umfang der angebotenen Funktionalit&auml;t
variabel sind, um so eine Vielzahl verschiedenartigster Anwendungen m&ouml;glichst
optimal unterst&uuml;tzen zu k&ouml;nnen. Dabei gibt es unterschiedliche
Auffassungen &uuml;ber den Umfang einer gemeinsamen Basis der verschiedenen
Betriebssystemauspr&auml;gungen. Die Werkbank setzt dabei auf einen extrem
kleinen Umfang (,,Skalierung nach unten``). Auf diese Weise wird effiziente
System-Software insbesondere auch f&uuml;r kleinste eingebettete Systeme
bereitgestellt. Es soll ein <I>Baukasten</I> und dazugeh&ouml;rige Werkzeuge
entwickelt werden f&uuml;r die Konstruktion <I>ma&szlig;geschneiderter</I>,
problemorientierter <I>Betriebssysteme</I>. Dadurch soll ein Anwender bzw.
ein Systemkonstrukteur in die Lage versetzt werden, sich aus einer Menge
extrem feingranular strukturierter Betriebssystemfunktionalit&auml;ten
das f&uuml;r seine Zwecke optimal passende System zu generieren. Dar&uuml;ber
hinaus sollen dynamisch Ver&auml;nderungen im System vorgenommen werden
k&ouml;nnen, d.h., es sollen bei Bedarf zur Laufzeit Funktionalit&auml;ten
hinzugef&uuml;gt bzw. entfernt werden k&ouml;nnen.
<LI>
<B>Experiences with a PC SMP Cluster</B>, A. A. Fr&ouml;hlich, GMD FIRST</LI>


<P>This talk presents preliminary results on our experiences to support
high performance computing using a PC SMP Cluster. Our cluster comprises
eight dual-Pentium II PCs interconnected by Myrinet and Fast Ethernet networks.
For the first experiments we selected Solaris as the operating system and
some user level communication packages, including Illinois Fast Messages
and Berkeley's Active Messages, to support applications and higher level
packages, like MPI. With this this environment we collected statistics
that pointed out weakness on both, hardware and software. However, we believe
we can achieve reasonable performance with this inexpensive software, as
long as the proper software, mostly still to be developed, is adopted.
<LI>
<B>Die Erforschung der Langsamkeit: Vernachl&auml;ssigte System-Resourcen
und ihre Beherrschung</B>, F. Bellosa, Universit&auml;t Erlangen-N&uuml;rnberg</LI>


<P>Die Umgebung, innerhalb der ein Computer sinnvolle Arbeit verrichten
kann, ist durch die Hardwareressourcen und die Software bestimmt, welche
diese Ressourcen verwaltet. In den letzten 40 Jahren konzentrierte sich
die Betriebssystemforschung auf die Verwaltung der Basis-Ressourcen Prozessor,
Hauptspeicher und Ein/Ausgabe. Abstraktionen wie Aktivit&auml;tstr&auml;ger,
Adre&szlig;r&auml;ume, Dateisysteme und virtuelle Kommunikationskan&auml;le
wurden geschaffen, um die Handhabung dieser Basis-Ressourcen zu vereinfachen
und allgemeine Schnittstellen anzubieten.
<BR>Doch neue Anforderungen an Rechensysteme zwingen zur Einf&uuml;hrung
von neuen Hardwarekomponenten und zur Entwicklung von Verwaltungssoftware
f&uuml;r Ressourcen, die bislang als nicht als ,,manage-w&uuml;rdig`` eingestuft
wurden. Exemplarisch soll an den beiden Ressourcen <B>Energie</B> und <B>Speicherbandbreite</B>
aufgezeigt werden, da&szlig; Betriebssysteme noch lange nicht erforscht
sind, sondern sich die Forschung auf diesem Gebiet immer wieder neuen Herausforderungen
stellen mu&szlig;.

<P>Stromversorgung und K&uuml;hlung ist eine Voraussetzung f&uuml;r den
Betrieb von Rechnern, die in der Vergangenheit als stets und konstant verf&uuml;gbare
Umgebungsbedingung unabh&auml;ngig von der Art des Betriebs angenommen
wurde. Diese Annahme ist nicht mehr zutreffend f&uuml;r tragbare Rechner
mit beschr&auml;nkter Stromversorgungs- und K&uuml;hlkapazit&auml;t.
<BR>Die <B>Energie</B>, die integrierte Schaltungen f&uuml;r ihren Betrieb
brauchen, ist proportional zur Anzahl der Gatter und der Taktfrequenz,
mit der sie betrieben werden. Ein Hochleistungsprozessor ben&ouml;tigt
zur Zeit zwischen 26W (UltraSPARC-II mit 250Mhz) und 60W (alpha 21264 mit
300 MHz). Angesichts des Trends zu steigenden Taktfrequenzen und steigender
Chipkomplexit&auml;t, tauchen zwei Fragen auf: K&ouml;nnen zuk&uuml;nftige
Systeme noch mit gen&uuml;gend Energie versorgt werden (z.B. in Notebooks
und PDAs) und kann die Energie durch passive K&uuml;hlung noch abgef&uuml;hrt
werden? Ist es m&ouml;gliche, die Energieaufnahme durch ausgekl&uuml;gelte
Proze&szlig;- und Energie-Verwaltungstechniken zu drosseln?
<BR>Einige der heutigen Prozessorarchitekturen bieten die M&ouml;glichkeit
der reduzierten Taktfrequenz, um Energie zu sparen. Die Reduzierung der
Taktfrequenz bewirkt eine lineare Reduzierung der Energieaufnahme, aber
auch eine entsprechende Reduktion der Rechenleistung. So bleibt ein einfaches
Ma&szlig; f&uuml;r die Rechenleistung pro Energieeinheit definiert in Millionen
Instruktionen pro Joule (MIPJ) konstant. Bei einer Reduzierung der Taktfrequenz
l&auml;&szlig;t sich aus technischen Gr&uuml;nden auch die Betriebsspannung
reduzieren. Damit bietet eine reduzierte Taktfrequenz die M&ouml;glichkeit
zu einer quadratischen Energieeinsparungen, da die Energie quadratisch
zur Betriebsspannung ist. Die Prozessverwaltung kann daher die Taktfrequenz
f&uuml;r jeden Rechenauftrag bestimmen und so den Stromverbrauch kontrollieren.
Der Stromverbrauch bestimmt einerseits die Betriebszeit eines Rechensystems
als auch die Leistungsreserven des Systems f&uuml;r die nahe Zukunft, da
der Rechner nur w&auml;hrend kurzer Hochlastphasen mit voller Leistung
gefahren werden kann. Die Kunst des Betriebssystems besteht also darin,
mit minimaler Taktfrequenz eine bestimmte Dienstg&uuml;te aufrecht zu erhalten
und zeitabh&auml;ngige Dienste vor Ihrer Deadline auszuf&uuml;hren. Bislang
wurde dieser Aspekt der ,,slow and cool execution`` nicht in Betriebssystemen
ber&uuml;cksichtigt.

<P>Die Fortschritte in der Speichertechnologie in Bezug auf Geschwindigkeit
konnten nicht mit denen in der Prozessortechnologie mithalten. Prozessoren,
die mit mehreren hundert Megahertz getaktet sind, k&ouml;nnen wesentlich
mehr Anforderungen an das Speichersubsystem stellen, als dieses erf&uuml;llen
kann. Die <B>Speicherbandbreite</B> ist die Datenmenge, die vom/zum Speicher
in einem Zeitintervall transferiert werden kann. Die Anzahl der erf&uuml;llbaren
Speicheranforderungen pro Zeitintervall und damit die Speicherbandbreite
ist begrenzt.
<BR>Ein Prozessor, der mehr Speicheranforderungen stellt, als erf&uuml;llt
werden k&ouml;nnen, mu&szlig; Wartezyklen einlegen, welche die Effizienz
reduzieren. In einem Multiprozessorsystem wird die verf&uuml;gbare Speicherbandbreite
von allen Prozessoren und DMA Ger&auml;ten geteilt. Folglich k&ouml;nnen
sich die Prozessoren gegenseitig behindern und in ihrer Effizienz beeinflussen.
Wir nennen diesen Effekt <I>Memory Preemption</I>.
<BR>Die Anzahl der Speicherzugriffe, die ein Prozessor pro Zeitintervall
t&auml;tigen kann, wird durch die Taktfrequenz und die Speicher-Referenz-Muster
bestimmt. Wenn wir die Kenngr&ouml;&szlig;en des Hauptspeichers kennen
und die individuellen Zugriffsmuster einzelner Tasks messen k&ouml;nnen,
kann diese Information im Scheduler genutzt werden, um den Effekt der Memory
Preemption vorherzusagen und zu kontrollieren. Die Kontrolle kann durch
das Einf&uuml;gen von Idle-Zyklen im Prozessor erfolgen, um den Speicherzugriff
von Tasks mit geringer Priorit&auml;t zu drosseln. Den gleichen Effekt
bei gleichzeitiger Energieeinsparung h&auml;tte eine Reduzierung der Taktfrequenz.

<P>Die zwei vorgestellten Beispiele zeigen eindrucksvoll, da&szlig; es
Ressourcen wie Energie, K&uuml;hlung und Hauptspeicherbandbreite gibt,
die bislang nicht von Betriebssystemen behandelt wurden. Im Vortrag werden
L&ouml;sungsans&auml;tze vorgestellt und erste Ergebnisse und Messungen
pr&auml;sentiert.
<LI>
<B>Reflexion als Strukturierungsprinzip objektorientierter verteilter Systeme:
Das metaXa Projekt</B>, M. Golm, J. Klein&ouml;der, S. Reitzner, Th. Riechmann,
Universit&auml;t Erlangen-N&uuml;rnberg</LI>


<P>Objektorientiertes Design und objektorientierte Programmierung haben
sich bei der Entwicklung komplexer Systeme als vorteilhaft erwiesen. Die
Unterteilung der Applikation in Objekte bzw. Klassen erleichtert das Verst&auml;ndnis
und die Erweiterbarkeit der Applikation. Jede objektorientierte Sprache
beruht auf einem bestimmten Objektmodell. Das Objektmodell beschreibt die
syntaktischen und semantischen Eigenschaften der Sprache. Das Objektmodell
legt zum Beispiel fest, ob Objekte persistent und aktiv sein k&ouml;nnen,
ob Methodenaufrufe an entfernten Objekten oder Objektmigration unterst&uuml;tzt
werden. Ein fest vorgegebenes Objektmodell kann die klare Strukturierung
einer Anwendung aber auch behindern, wenn bestimmte, f&uuml;r die Anwendung
ben&ouml;tigte Objekt-Eigenschaften im Objektmodell fehlen und dehalb bei
der Anwendungsprogrammierung Objektmodell-Mechanismen nachgebildet werden
m&uuml;ssen. Es existiert kein Objektmodell, welches f&uuml;r alle Anwendungen
ausreichend w&auml;re. Traditionell werden Systeme durch ein Schichtenmodell
strukturiert. Untere Schichten (z.B. ein Betriebssystem, dar&uuml;ber evtl.
Middleware) implementieren Dienste, die h&ouml;here Schichten (z.B. eine
Anwendung) &uuml;ber Schnittstellen (Application Programmer Interface,
API) benutzen. Die Trennung durch fest definierte Schnittstellen sichert
die Unabh&auml;ngigkeit der Implementierungen der verschiedenen Ebenen,
hat aber den Nachteil, da&szlig; h&ouml;here Schichten Dienste tieferer
Schichten lediglich benutzen, aber kaum Einflu&szlig; auf deren Verhalten
oder Implementierung nehmen k&ouml;nnen. Die Folge sind Performanceverluste
des Gesamtsystems sowie die Neuprogrammierung nicht passender Dienste in
anderen Schichten. Performanceverluste werden besonders deutlich, wenn
&uuml;ber einer Betriebsystemschicht beispielsweise eine virtuelle Maschine
(wie die Java VM) l&auml;uft, die die eigentlichen Anwendungen ausf&uuml;hrt.
In aktuellen Forschungsprojekten wurde versucht, den Performanceverlust
durch Integration der virtuellen Maschine in das Betriebsystem zu beseitigen
- d.h. es werden zwei Schichten verschmolzen. Das metaXa-Projekt versucht,
eine L&ouml;sung f&uuml;r dieses Problem durch Erweiterung und &Ouml;ffnung
der Java Virtual Machine (JVM) f&uuml;r die Anwendungsebene zu finden.

<P>Auch die JVM implementiert ein bestimmtes Objektmodell. So sind Objekte
z.B. transient und passiv, k&ouml;nnen als Monitor verwendet werden, etc.
Die metaXa-VM erlaubt es, diese Eigenschaften an Anwendungsanforderungen
anzupassen. F&uuml;r diesen Zweck wird Reflexion verwendet. Reflexion erm&ouml;glichst
es Programmen, ihre Struktur und ihr Verhalten zu beobachten und zu ver&auml;ndern.
Die Implementierung des Objektmodells, die &uuml;blicherweise durch ein
Laufzeitsystem erfolgt, ist f&uuml;r Anwendungsprogramme zugreifbar und
&auml;nderbar. MetaXa unterst&uuml;tzt zum einen Reflexion, indem es Metaobjekten
den Zugriff auf Namen und Typen von Instanzvariablen, Methodennamen und
Signaturen sowie Typinformationen von Objektreferenzen erm&ouml;glicht
(<I>structural reflection</I>). In diesem Sinne &auml;hnelt metaXa recht
stark dem Reflection-API von Sun JDK 1.1. Zus&auml;tzlich bietet metaXa
aber auch die M&ouml;glichkeit, in den Berechnungsvorgang einzugreifen
(<I>behavioral reflection</I>). Dies geschieht dadurch, da&szlig; interessante
Aktionen der Anwendung ein Ereignis (<I>Event</I>) ausl&ouml;sen k&ouml;nnen.
An ein Java-Objekt (<I>Basisobjekt</I>) kann zur Laufzeit des Programms
ein <I>Metaobjekt</I> gebunden werden. Reflexion &uuml;ber das Basisobjekt-Verhalten
wird m&ouml;glich, indem bei folgenden Mechanismen ein Event-Handler des
Metaobjektes aufgerufen wird: Methodenaufrufe, Variablenzugriffe, Betreten
und Verlassen von Objektmonitoren, Erzeugen von Objekten, Laden von Klassen.
Diese Mechanismen k&ouml;nnen durch das zust&auml;ndige Metaobjekt abweichend
vom Java-Objektmodell implementiert werden. Metaobjekte modellieren Basisebenen-Objekte,
d.h. sie enthalten Informationen bezgl. Struktur und Verhalten der Objekte.

<P>Die Verwendung von Metaobjekten bedeutet im Schichtenmodell, da&szlig;
die Anwendungsschicht eigene Implementierungen f&uuml;r Teile der Schicht
der virtuellen Maschine installiert. Durch die Trennung von Basisobjekten
und Metaobjekten bleibt die Gliederung in verschiedene Schichten aber erhalten.

<P>Um die Vorteile unserer reflexiven Architektur zu demonstrieren, haben
wir Metasysteme f&uuml;r Fernaufruf, Replikation, Sicherheit, Koordinierung,
Persistenz, aktive Objekte und Just-in-time Compiler implementiert.
<H5>
<A NAME="SECTION00000001000000000000"></A>Replikation</H5>
Replikation wird im Java Objektmodell nicht unterst&uuml;tzt. Wir haben
Metaobjekte implementiert, die einen Methodenaufruf in einen Multicast
umwandeln (aktive Replikation), oder den Zugriff auf Instanzvariablen an
die Replikate verteilen (passive Replikation). Zur Koordinierung nebenl&auml;ufiger
Zugriffe ersetzt das Metaobjekt den Lock-Mechanismus des replizierten Objektes
durch eine eigene Implementierung. Weitere, spezielle Replikationsprotokolle
k&ouml;nnen jederzeit hinzugef&uuml;gt werden und innerhalb einer Anwendung
k&ouml;nnen f&uuml;r verschiedene Objekte unterschiedliche Replikationsstrategien
eingesetzt werden.
<H5>
<A NAME="SECTION00000002000000000000"></A>Sicherheit</H5>
Java verwendet Capabilities als prim&auml;ren Sicherheitsmechanismus: Eine
Objektreferenz in Java ist eine Capability f&uuml;r die Methoden des Zielobjektes.
Leider kann man diese Capabilities in keiner Weise einschr&auml;nken. Restriktion
auf bestimmte Methoden, Revokation, Konfiguration begrenzter G&uuml;ltigkeit
und Verbreitungskontrolle fehlen. Diese zus&auml;tzlichen Konfigurationsm&ouml;glichkeiten
lassen sich durch sogenannte Sicherheitsmetaobjekte erreichen: Objektreferenzen
k&ouml;nnen mit Sicherheitsmetaobjekten versehen werden.

<P>Alle sicherheitsrelevanten Operationen werden dann zun&auml;chst von
dem Metaobjekt &uuml;berpr&uuml;ft. Ein solches Metaobjekt kann Methodenaufrufe
zulassen oder verweigern und dadurch Restriktion, Revokation und begrenzte
G&uuml;ltigkeit der Capabilities realisieren. Es kann &uuml;bergebene Parameter
und R&uuml;ckgabewerte ebenfalls mit Metaobjekten versehen und dadurch
eine Verbreitungskontrolle von Objektreferenzen und transitive Sicherheitsstrategien
realisieren. Die Programmierung der Metaobjekte kann unabh&auml;ngig von
der Applikationsprogrammierung stattfinden: Man kann zun&auml;chst die
Applikation ohne spezielle Sicherheitsbetrachtungen entwickeln oder Bibliotheken
verwenden, die ohne Sicherheitsanforderungen entwickelt wurden. Diese k&ouml;nnen
dann nachtr&auml;glich durch passende Sicherheitsmetaobjekte auf die speziellen
Sicherheitsanforderungen, unter denen die Applikation oder die Bibliothek
eingesetzt werden soll, angepa&szlig;t werden. Die Konfigurierung ist extrem
feingranular m&ouml;glich: bei jeder Objektreferenz kann separat eine Sicherheitsstrategie
festgelegt werden.
<H5>
<A NAME="SECTION00000003000000000000"></A>Koordinierung</H5>
Die Integration von Koordinierung in eine objektorientierte Sprache geschieht
meist auf der Ebene der Objekte oder sogar der Methoden. Diverse Arbeiten
haben gezeigt, da&szlig; das objektorientierte Paradigma der Vererbung
mit Koordinierungsmechanismen kollidieren kann. Das Resultat ist, da&szlig;
man bei der Vererbung von einer koordinierten Klasse einen Teil der Basisklasse
reimplementieren mu&szlig;, nur weil sich die Koordinierung in der Subklasse
geringf&uuml;gig &auml;ndert. Diese Erscheinung wird als <I>Vererbungs
Anomalie</I> bezeichnet.

<P>Unsere Idee ist es, das nebenl&auml;ufige Objekte in ein Objekt, das
den algorithmischen Teil enth&auml;lt (Basisobjekt) und ein Koordinierungsobjekt
(Metaobjekt) aufzuspalten. Das Basisobjekt spezifiziert die Stellen, an
denen Koordinierungs-Events ausgel&ouml;&szlig;t werden sollen. Treten
solche Events auf, so ist im algorithmischen Objekt spezifiziert, welche
Aktionen im Koordinierungsobjekt angesto&szlig;en werden m&uuml;ssen. Das
Koordinierungsobjekt blockiert die Ausf&uuml;hrung dieser Aktionen solange,
bis das Ereignis koordiniert ist und gibt dann die Kontrolle an das algorithmische
Objekt zur&uuml;ck. Dieses kann die Arbeit fortsetzen und braucht sich
um die Koordinierung nicht weiter zu k&uuml;mmern.

<P>Die Abbildung von Ereignissen auf Koordinierungsaktionen nennt man das
<I>Event Mapping</I>. Dieses Mapping ist virtuell, was bedeutet, da&szlig;
eine Unterklasse das Mapping von Basisklassen-Ereignissen ver&auml;ndern
kann. Das gew&auml;hrleistet, da&szlig; eine &Auml;nderung der Koordinierung
in der Subklasse nicht die Reimplementierung der gesamten Basisklassenmethode
erzwingt, sondern nur der Koordinierungsanteil ver&auml;ndert werden mu&szlig;.
Dieses Vorgehen bewirkt eine erhebliche Reduzierung der Anomalien.
<LI>
<B>Objekte in Windows-NT</B>, W. Kalfa, Technische Universit&auml;t Chemnitz-Zwickau</LI>


<P><I>Beitrag wird nachgeliefert.</I>
<LI>
<B>A Topology-Based Approach to Coordinated Multicast Operations</B>, J.
Nolte, GMD FIRST</LI>


<P>Multicasts are a powerful means to implement coordinated operations
on distributed data-sets as well as synchronized reductions of multiple
computed results. In this paper we present a topology based approach to
implement parallel operations on distributed data-sets as multicasts. Multicast
groups are described as reusable application-specific topology classes
that coordinate both the spreading of multicast messages and the collection
(reduction) of the computed results. Thus global operations are controllable
through applications and existing communication topologies as well as synchronization
patterns can effectively be reused.</OL>

<HR><IMG SRC="next_motif_gr.gif" ALT="next" HEIGHT=24 WIDTH=37 ALIGN=BOTTOM>&nbsp;<A NAME="tex2html1" HREF="../"></A><A HREF="http://www.inf.fu-berlin.de/gi/fb3/fa31/fg314/mitteilungen/" NAME="tex2html1"><IMG SRC="up_motif.gif" ALT="up" HEIGHT=24 WIDTH=26 ALIGN=BOTTOM></A>&nbsp;<IMG SRC="previous_motif_gr.gif" ALT="previous" HEIGHT=24 WIDTH=63 ALIGN=BOTTOM>
<BR><B>Up:</B>&nbsp;<A NAME="tex2html2" HREF="../"></A><A HREF="http://www.inf.fu-berlin.de/gi/fb3/fa31/fg314/mitteilungen/" NAME="tex2html2">Mitteilungen
der Gi Fachgruppe 3.1.4 - Betriebssysteme</A>
</BODY>
</HTML>
