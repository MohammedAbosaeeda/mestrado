\title{Implementation of the AES cipher using the unified design strategy}
\author{
        Rodrigo Schmitt Meurer \\
        \small Software/Hardware Integration Lab - LISHA\\
        \small Federal University of Santa Catarina,\underline{Brazil}\\
        \small rmeurer@lisha.ufsc.br
}
\date{}
\documentclass[12pt,a4paper]{article}
\usepackage{multicol}
\usepackage{cite}
\usepackage{multirow}
\usepackage{graphicx}
\begin{document}
	\maketitle
	\bibliographystyle{unsrt}
	\begin{abstract}
		This paper proposes to implement the AES in hardware. By using the unified design approach, we aim to create a unified description of the AES component. As a result of the experiment we created a description of the AES and compared the implementation with other related works. The implementation from the description has a small overhead compared to other implementations, however it compensates in ease of implementation. With the results we can conclude that, if the programmer is able to sacrifice a little of performance or area, HLS techniques and the unified design strategy are a very suitable alternative.
		\\
		
		\textbf{Keywords:} FPGA, AES, HLS, Encryption, Hardware, Unified Design.
	\end{abstract}
	\section{Introduction}
		
		The AES algorithm is widely adopted for various aplications and the number of Hardware architectures to implement this cipher is becoming each time higher. The AES is used in applications from high-end computers to low power portable devices. Because of it's wide range of applications, sometimes the architectures have to meet some requirements such as High-Throughput, Low area, Low power or have good relation between Speed/Area.
		
		On the other hand, writing RTL code to synthesize a component in hardware can be very complex. In order to deal with this complexity, embedded system designs are being pushed to the system-level In this scenario, a convergence between hardware and software design methodologies is desirable, since a unified modeling approach would enable one to take decisions about hardware/software partitioning later in the design process, maybe even automatically.
		
		In this experiment, we propose to find an unified description for the AES components. By isolating similar aspects, we can create a description using the unified design strategy ~\cite{unified} in a way that this description of the component can be easily synthesized in both software and hardware.
		
		
		
	\section{Background and Related Work}
		\subsection{Advanced Encryption Standard}
			The AES is a symmetric block cipher, which uses the same key for both encryption and decryption. It has been broadly used for different applications such as, smart cards, mobile phones, websites, computers and wireless. Similar to other symmetric ciphers, the algorithm applies round operations iteratively. The input can be a plaintext or a ciphertext. The algorithm round consists of four transformation. SubBytes, ShiftRow, MixColumn and AddRoundKey each round key is derived from the cipher key. More information can be obtained from ~\cite{lowAreaAES}.
			\begin{figure}[h]
				\begin{center}
					\includegraphics[scale=0.32]{fig/aes.png}
					\caption{AES Encryption/Decryption Flow}
					\label{flow}			
				\end{center}
			\end{figure}		
			
		\subsection{Unified Design}
		
			Components designed using that unified design methology are susceptible to both software and hardware generation using standard compilers and HLS tools. This is possible through the isolation of specific hardware and software characteristics (resource allocation and communication interface) into aspect programs which are weaved with the unified descriptions only during the final stages of the design process. The proposed mechanisms were implemented using only standard C++ features and generative programming {2} techniques such as static metaprogramming, thus facilitating compatibility with different C++/C-based HLS tools.			
			
	\section{Implementation}
		In this section we describe the stages of the implementation. This description includes both schemes and purposes of each step.
		\subsection{Software}
			We started the experiment by implementing a reference version of the AES cipher from it's specification ~\cite{lowAreaAES}. Figure \ref{flow} shows the scheme of the implementation. The cipher was implemented in C++. We then, compared the reference version (non optimized) with an advanced implementation optimized for software. The results are shown in table \ref{softResult} .
			\begin{table}[h]
			\begin{center}							
				\begin{tabular}{|l|c|c|c|}
					\hline
					& Reference & Advanced 1 & Advanced 2 \\ \hline
					Exec Time: & 10 & 8 & 9 \\ \hline
					Code Lines: & 1000 & 5000 & 600 \\ \hline
					OTHER: & 123 & 555 & 888\\ \hline
				\end{tabular}
				
				\caption{Table of imaginary software results}			 
			\end{center}	
			\label{softResult}		
			\end{table}
		
			**analysis of the results**
		\subsection{Hardware}
			With the software implementations, we used the HLS tool CatapultC \cite{CatapultC} to synthesize the C++ codes into RTL. The tool allows us to set some directives. By setting these directives we can synthesize different hardware architectures for the same software specification. Table \ref{hardResult} shows the obtained results for each architecture of each implementation.
			
			\begin{table}[h]
			\begin{center}							
				\begin{tabular}{|l|c|c|c|c|}
					\hline
					& & Reference & Advanced 1 & Advanced 2 \\ \hline
					\multirow{4}{*}{Serial:} & LUTs: & & & \\ \cline{2-5}
					& Flip-Flops: & & & \\ \cline{2-5}
					& Cycles per Sample: & & & \\ \cline{2-5}
					& Máx Frequecy: & & & \\ \hline
				
					\multirow{4}{*}{Parallel:} & LUTs: & & & \\ \cline{2-5}
					& Flip-Flops: & & & \\ \cline{2-5}
					& Cycles per Sample: & & & \\ \cline{2-5}
					& Máx Frequecy: & & & \\ \hline
					
					\multirow{4}{*}{Pipelined:} & LUTs: & & & \\ \cline{2-5}
					& Flip-Flops: & & & \\ \cline{2-5}
					& Cycles per Sample: & & & \\ \cline{2-5}
					& Máx Frequecy: & & & \\ \hline
					
				\end{tabular}
				
				\caption{Table of imaginary hardware results}			 
			\end{center}	
			\label{hardResult}		
			\end{table}
			
			**analysis of the results**
		
		\subsection{Aspect Identification}
			With the hardware and software implementations, we can identify similar aspects. We done a different process for each component of the AES. In the SubBytes component, we identified .......... as similar....
	\section{Results and conclusions}
	
		The experiment resulted in a unified description for the components of the AES. These descriptions allow us to implement the components in software or hardware in a much simpler way. We can implement each one of them by only using standard compilers and HLS tools. 
		
		The implementations from the description, on the other hand, had a small overhead in area, performance and energy consumption. This is caused due to the method of aspect isolation used ....
		
		Finally, we can see that the unified design methodology is a very powerful strategy. Once the description of a component is made, further implementations become very easy to synthesize. The implementation generated may not be as optimized as an implementation in hardware, but if the objective allows a small overhead, implementing using the unified design strategy would save the programmer a lot of time.
	\bibliography{bib.bib}
\end{document}