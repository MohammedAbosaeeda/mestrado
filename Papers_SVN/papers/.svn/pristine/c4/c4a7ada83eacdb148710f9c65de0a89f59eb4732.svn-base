----------------------------------
Reviewer 1:
----------------------------------

Recommendation: Revise and Resubmit as "new"
Manuscript rate: Fair

-Basicamente não conseguiu compreeender como os mecanismos podem ser aplicados de uma maneira sistematizada em casos diferentes dos mostrados no paper. Segundo ele, as contribuições principais do paper são: "the usage of safe pointers and static polymorphism in high-level synthesis as well as dispatching of hardware functions using aspect-oriented programming". 

+O problema apontado realmente mina o paper. A solução seria explicar melhor a parte do "domain engineering process" e expandir mais o exemplo do scheduler, mostrando um passo-a-passo de como chegamos no design atual.

-----------------------------------
Reviewer 2:
-----------------------------------

Recommendation: Author Should Prepare A Major Revision For A Second Review
Manuscript rate: Good
 
-Sentiu falta de uma explicação melhor sobre os trabalhos anteriores. De certa forma ele assumiu que os pontos criticados pelo review 1 eram explicados nesses trabalho, mas  não encontrou um boa interface até eles. Outro problema importante apontado é uma explicação melhor sobre como os mecanismos mostrados funcionam na prática e detalhes sobre como a invocação remota é implementada

+Mesma solução do review 1 + incorporar partes do paper que vai pra FPGA'13. Esse paper trata justamente das questões técnicas que o revisor sentiu falta.

----------------------------------
Review 3:
-----------------------------------

Recommendation: Author Should Prepare A Minor Revision
Manuscript rate: Excellent

-Alogiou o paper e não apontou nenhum problema crítico. Contudo fez vá sugestões, as principais:
+Explicar alguns conceitos de OOP , AOP e UML para facilitar a leitura do paper, ou prover ponteiros.
+Mostrar outras alternativas além de static metaprogramming pra implementar a proposta (macros, pragmas, etc) e ressaltar melhor as vantagens da nossa abordagem
+Como outros aspectos poderiam ser tratados pela abordagems proposta ? bit-accurate types, synthesis directives, etc.

--------------------------------------------------------------------------------------
Comentários
--------------------------------------------------------------------------------------

------------------------------
Review 1:

only some illustrative examples are given without providing more general guidelines, the paper looks more like a case study presentation than a research paper.

the main weakness of the paper lies in the presentation of proposed solution in section 4. Instead of giving general guidelines, the authors only present sample code snippets, which provide solutions for their running example. Often, the code snippets are even not discussed at all, which makes it difficult to even comprehend this particular solution. Especially, I do have problems understanding the Traits example on page six in the right column. The applicability of the solution and its limitations remain unclear.

Review 2:

Section 4.2 aims at defining C++ unified description. This section appears to focus only on some specific issues like the use of pointers, static polymorphism, allocation, and dispatching. These issues are indeed important but the overall description of the unified description is missing. The presented techniques from template meta programming are interesting, but the description is not sufficient for understanding how these techniques are applied in a systematic way in an overall unified description.

Without reading the previous work of the authors it is very hard to get a deeper understanding of the technical concept and soundness of the approach. Section 3 should better aim on giving an introduction to the general concepts of aspects and aspect weaving. Currently section 3 points to previous work and gives only little high-level/abstract information.

Review 3:

On the general approachability of the text. The authors seem to assume that readers understand many concepts like "aspect-oriented programming", and do not really explain these concepts in the paper. 

For someone who does not have prior knowledge of C++ template and UML (Many embedded designers use languages like C instead of C++), these will only create confusion. 
More explanations on the concepts of OOP/UML and C++ template will be helpful. If space is a problem, the author should at least say something like "we assume that the readers are comfortable with C++ templates and UML diagrams in the reset of this paper. For information on these, please see [xx] and [yy] for more explanation."

-----------------------------

Review 1:

No alternative solutions are discussed. This would have been interesting especially for the static allocation and dispatching aspects. In particular, the proposed dispatching strategy is very specific for the CatapultC high-level synthesis. Nearly all other HLS tools do not use a single function signature for describing hardware components. They typically require to present hardware components as SystemC modules having signal ports or transaction sockets. In this case, the proposed solution could not be applied directly. Moreover, why do the authors define their own allocation class while the standard template library is already providing a ready to use implementation? In summary, by only providing some examples, it is not clear what exact solution is proposed. 

Review 3:

While the proposed method could work well for the purpose of describing hardware and software in a unified way, comparison with other methods for the same purpose is missing. For example, it is possible to use C (with extensions/pragmas) to describe both hardware and software (I know people in the industry doing so), and I believe what static metaprogramming offers can also be achieved using C language constructs, like macros and #ifdef blocks. Discussion on the advantage of the proposed approach should be elaborated, with comparison to possible alternatives (not necessarily experiemtal comparison). For example, one of the advantages I can see is that the proposed approach is more systematic and thus can potentially offer better checking at the syntax level; i.e., a domain-specific compiler may easily inform the designer about missing constructs. Yet, a disadvantage could be that a coding style using static-metaprogramming can be difficult to debug. Comparisons like this could help the reader better understand the proposed method and appreciate its unique advantages.


------------------------------

Review 2:

In Section 4.1 the comparison of TLM-based communication and communication in object-oriented modes seems to be a little strange. Without giving further details on the methodology behind the presented approach (incl. different models for the application, execution platform and the mapping of application elements to component of the execution platform) this comparison is dangerous. Communication in object-oriented application models describe application specific communication, while TLM models describe how communication is realized in the execution platform through physical channels.
I.e. object-oriented communication at application layer can be mapped to platform communication resources that implement this communication.

--------------------------------

Review 2:

Section 4.2.3 presents the idea of a Remote Method invocation with marshaling and unmarshaling services. It remains unclear how these techniques are supported by the presented methodology. Nothing about interrupt handling for software calls is mentioned. A Trait is a very generic template meta programming technique. It remains unclear how this technique solves the problem of HW/SW communication.

--------------------------------

Review 3:

There are more differences in hardware design and software design that may need attention. For example, for high-level synthesis, bit-accurate data types are very useful. By using only enough bit widths for operators, storage elements and interconnects, significant saving in resource/power can be achieved. On the other hand, software compilers usually only use 8/16/32/64 bit for integers. The tool used in your experiments, Catapult-C, supports the ac_int/ac_fixed datatypes in C++. I wonder if bit-accurate datatypes are used in your experimental evaluation? How do you unify the hardware/software description if bit-accurate datatypes are needed? There can be subtle issues when overflow occurs.

The approach, as a coding style, can be applied to a more general class of "module selection" problem. The scenarios considered do not have to be limited to either "software" or "hardware". In high-level synthesis, the design space can be explored by using different pragmas (like loop unrolling/pipeling), and each implementation could be a scenario. Some of the techniques described in this paper can actually encode multiple sets of implementation options in a unified description.

--------------------------------

Review 2:

The main focus of the case-study is on the comparison of component implementations using C++ with the presented unified C++ approach. The evaluation is quite extensive and could be reduced. 




--------------------------------------------------------------------------------------
Minor comments:
--------------------------------------------------------------------------------------

Review 1:
- Page 6, left column, line 28: to use to use => to use

Review 2:
- In the case-study error bars should be added to measured execution times.
- In the last part a hybrid partitioning is presented that sound very interesting. The results presented in Table 5 are hard to understand.
