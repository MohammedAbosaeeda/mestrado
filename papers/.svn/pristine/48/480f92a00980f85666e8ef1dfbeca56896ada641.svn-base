\section{Análise do programa exemplo}
\label{sec:exemplo}

Inicialmente, analisamos em detalhes um programa disponibilizado como exemplo na
documentação do \boundt~pelo qual é possível observar características e
limitações da ferramenta para o ARM7. O exemplo consiste de dois arquivos
\texttt{C}, \texttt{main.c} e \texttt{routines.c}. Há também três
\textit{headers} (*.h) e um arquivo em linguagem de montagem do ARM7,
\texttt{Startup.s}. O código destes arquivos estão disponíveis no site da
Tidorum~\cite{Tidorum:BoundT_ARM7}~\footnote{Por limitação no número de páginas,
listagens de código-fonte foram removidos deste documento, porém estão
disponíveis através da Internet.}. O programa analisado é composto por diversas
chamadas de função, sendo o grafo destas chamadas o apresentado na
Figura~\ref{fig:cg_main}.

\fig{cg_main}{Grafo de chamadas do programa exemplo.}{width=\columnwidth}

Alguns pontos neste exemplo devem ser destacados por serem importantes no
processo de análise estática do programa:
\begin{itemize}
  \item Na função \texttt{Count} há um laço cujo número de iterações depende do
  valor de um dos parâmetros da função (\texttt{u});
  \item Na função \texttt{Ones} há um laço cujo número de iterações depende da
  posição do bit não nulo mais significante dentro de um dos seus parâmetros
  (\texttt{x}). A função conta o número de bits não nulos em \texttt{x};
  \item Na função \texttt{Solve} há um laço cujo número de iterações é limitado
  por uma constante (\texttt{8}). Contudo, o laço pode ser terminado mais cedo
  por um \texttt{break}.
\end{itemize}

Para compilar e ligar o programa, a Tidorum utilizou o Keil/ARM RealView (armcc)
em ambiente Windows. Como nós utilizamos o Gnu GCC, no Linux, foi necessário
remover o arquivo \texttt{Startup.s}, que estava fora do padrão do nosso
compilador/montador. Para substituí-lo, foi utilizado código de inicialização
disponibilizado pelo próprio GCC.

O \textsc{Bound-T} não conseguiu determinar um limite de tempo para o programa
automaticamente, precisando para isso de anotações sobre o comportamento de
alguns pontos do programa. Estas anotações estão na Figura~\ref{prg:assertions},
e são comentadas abaixo:
\begin{itemize}
  \item Na função \texttt{Ones}, uma anotação é necessária para determinar o
  número de repetições do laço \texttt{while(x)} que repete uma vez para cada
  bit não nulo de \texttt{x}. Como \texttt{x} é um valor de 32-bits, o laço
  repete, no máximo, 32 vezes;
  \item Na função \texttt{Solve}, uma anotação é necessária para determinar o
  número de repetições do laço \texttt{for}. Como \texttt{k} é o número de bits
  '1' em \texttt{*x}, que é um valor de 32 bits, \texttt{k} é no máximo 32. Este
  valor limita o parâmetro \texttt{u} da chamada de \texttt{Count}, e define um
  limite para o laço em \texttt{Count};
  \item Na função \texttt{main} há um laço eterno para bloquear o programa ao
  final. Uma anotação é necessária para evitar que o \textsc{Bound-T} pare a
  análise do programa. Como neste ponto toda a computação desejada já deve ter
  sido feita, uma anotação é incluída para que a análise considere apenas uma
  iteração para este laço.
\end{itemize}

\prg{TeX}{assertions}{Anotações do \boundt~para o programa exemplo.}

O resultado da análise do WCET deste programa é de 12.680 ciclos de máquina.
Também foi possível obter a profundidade máxima da pilha do programa, que foi de
44 bytes. A saída da ferramenta para esta análise é a que foi apresentada na
introdução.


\section{Análise do \textit{benchmark} WCET do MRTC}
\label{sec:benchmark}

O grupo MRTC (Mälardalen Real-Time research Centre), da Universidade de
Mälardalen, Suécia, desenvolveu um benchmark para avaliação de ferramentas de
análise de WCET no contexto do projeto SWEET~\cite{Gustafsson:2010}. Muitos dos
programas deste benchmark foram utilizados no \textit{WCET Challenge 2006}. Os
programas estão disponíveis publicamente~\cite{MRTC:Benchmark}.

Os programas foram compilados utilizando o Gnu GCC conforme a linha abaixo, ou
seja, para o processador ARM7-TDMI, sem otimizações (-O0) e com informação de
depuração (-g):
\begin{verbatim}
   arm-gcc -mcpu=arm7tdmi -O0 -g -o <saída>.elf <entrada>.c
\end{verbatim}

Em seguida foram submetidos à análise pelo \boundt~conforme a linha abaixo, onde
``main'' é a função cujo WCET deseja-se estimar:
\begin{verbatim}
   boundt_arm7 -arm7 <entrada>.elf main
\end{verbatim}

A Tabela~\ref{tab:benchmark} mostra os resultados da análise de WCET para alguns
programas do benchmark. Não foram feitas tentativas de adicionar anotações para
resolver os problemas encontrados nestes benchmarks. O objetivo era avaliar até
onde o \boundt~seria capaz de ir automaticamente. Basicamente, exceto para o
programa ``crc'', em que a ferramenta deixou de funcionar durante a análise, os
problemas encontrados foram a impossibilidade de determinar limites de valores
para variáveis controladoras de laços (\textit{Unbounded}), presença de grafos
de fluxo de execução irredutíveis (\textit{Irreductible Flow Graph}) e a
presença de recursão no código (\textit{Recursion}). Para os programas que o
\boundt~conseguiu realizar a análise é apresentado o valor do WCET em ciclos de
máquina.

\tab{benchmark}{Benchmark WCET da MRTC da Universidade de Mälardalen.}

Ainda nesta tabela, é apresentado um índice de complexidade do programa em
questão. Tal índice foi montado utilizando uma soma ponderada de fatores
considerados complicantes do processo de análise estática de código-fonte de
modo que, quanto maior a complexidade atribuída ao programa, mais difícil é o
processo de análise estática do mesmo. Como exemplo de fatores complicantes de
análise estática pode-se citar a presença de recursão, ponteiros para funções ou
relação com bibliotecas externas ao programa (e.g., \texttt{libc}). Os fatores
empregados são os mesmos apresentados pelo MRTC na descrição dos programas
propostos~\cite{MRTC:Benchmark}.

%\section{Programa proposto para o desafio de WCET}
No contexto em que estes testes foram realizados, a disciplina de Sistemas de
Tempo-Real do Programa de Pós-Graduação em Engenharia de Automação e Sistemas da
Universidade Federal de Santa Catarina, diversos grupos de alunos propuseram
desafios para serem analisados por diversas ferramentas de análise de WCET.
Sendo assim, o problema apresentado como desafio para disciplina e analisado com
sucesso pelo \boundt~é uma execução sequencial dos programas considerados mais
complexos pela análise apresentada na Tabela~\ref{tab:benchmark}, ou seja,
\texttt{qsort-exam}, \texttt{select} e \texttt{fac} do benchmark apresentado
acima.

Para resolver o problema proposto no \boundt~foi necessário adicionar as
anotações apresentadas na Figura~\ref{prg:anotacoes_desafio}. O subprograma
``sort'' apresenta uma série de laços alinhados, que podem ser facilmente
expressos pela linguagem de anotações do \boundt~conforme apresentado na figura.
No caso do ``sort'', anotações foram necessárias para limitar o laço principal
(\texttt{loop that contains (loop that contains loop)}) e os cinco laços
aninhados (\texttt{all 5 loops in (\ldots)}). Anotações similares foram
realizadas para viabilizar a análise do subprograma ``select''.

\prg{TeX}{anotacoes_desafio}{Anotações do \boundt~para o programa desafio
proposto.}

Para possibilitar a análise do subprograma ``fac", contudo, outro tipo de
anotação se fez necessária. O \boundt~não resolve recursões sozinho. Para
resolver as chamadas recursivas à função que calcula o fatorial (\texttt{fac}),
foi necessário quebrar as chamadas em 2, conforme apresentado na
Figura~\ref{prg:fac}, e anotar que estas chamadas não repetem nunca. Assim, o
WCET pode ser calculado manualmente ao final. Os resultados obtidos foram
5.496.330 ciclos para o subprograma \texttt{qsort}, 1.107.269 ciclos para o
subprograma \texttt{select} e 30 ciclos para o subprograma \texttt{fac},
totalizando 6.603.648 ciclos para todo o desafio. O WCET real, contudo, precisa
levar em conta o número de repetições da função recursiva. Para obtê-lo, rodamos
o analisador apenas sobre a função da recursão, considerando o tempo de
\texttt{fac} como zero:

\begin{verbatim}
$  boundt_arm7 -arm7  -assert annotations.txt  desafio facA
Wcet:desafio:desafio.c:facA:220-225:24
\end{verbatim}

Como os subprograma \texttt{fac} calcula 6 valores de fatorial (fatoriais de 0 a
5), o tempo final é dado por $WCET = (6 \times 24) + 6.603.648 = 6.606.528$
ciclos.

\prg{C++}{fac}{Código modificado para permitir a análise de recursão.}


\section{Análise dos desafios propostos}

Esta seção apresenta os resultados obtidos na análise pelo \boundt~dos desafios
propostos pelas outras equipes da disciplina de tempo-real. Cada subseção
seguinte trata de um dos desafios, com uma rápida descrição de cada um, o
arquivo de anotações necessário para a análise e o resultado. A
Tabela~\ref{tab:resultados} sumariza os resultados gerados pelo \boundt~para o
WCET dos desafios propostos. Como pode ser observado, a ferramenta não foi capaz
de avaliar os programas em dois dos desafios\footnote{Devido às limações em
número de páginas, o código-fonte dos desafios aqui apresentados foram
suprimidos e disponibilizados online em:
\texttt{http://www.lisha.ufsc.br/$\sim$arliones/WCET\_Fontes.zip}}.

\tab{resultados}{Resultados gerados pelo \boundt~para os desafios.}


\subsection{Tabela Hash}

Este desafio apresenta algoritmos para a manipulação de uma tabela hash. Uma
anotação foi necessária para amarrar o laço na linha 90 do programa. Como já
constava no comentário existente no código, o limite de iterações do laço está
associado ao tamanho máximo de uma string, que está definido no arquivo
\texttt{main.h} como 512 bytes, logo, o laço repete 512 vezes. 

Outro problema encontrado que necessitou de anotações foi a existência de
chamadas dinâmicas a funções, ou seja, uso de ponteiros para funções. O
\boundt~permite resolver este problema através de uma anotação específica em que
se passam os valores que estes ponteiros podem assumir, ou seja, as funções que
podem ser atribuídas a estes ponteiros. O arquivo de anotações gerado está na
Figura~\ref{prg:renan_assert}.
% A saída gerada pelo \boundt~para esta análise está na
% Figura~\ref{prg:renan_output}. Como pode ser visto, mesmo com anotações para
% ``driblar'' as chamadas dinâmicas, o Bound-T continua emitindo avisos de que
% estas chamadas estão ocorrendo.
O WCET para a função main do desafio ``Tabela Hash'' foi de 54.272 ciclos.

\prg{TeX}{renan_assert}{Anotações para análise de WCET do desafio Tabela Hash.}

%\prg{TeX}{renan_output}{Saída da análise de WCET do desafio Tabela Hash.}

\subsection{Float bit a bit}

Este desafio implementa algumas operações binárias sobre uma variável de ponto
flutuante (\emph{float}) implementadas através de uma função que é invocada
através de um ponteiro. Também são realizadas cópias de memória utilizando a
função \texttt{memcpy} da libc. Uma anotação foi necessária para resolver a
chamada dinâmica a função. Esta anotação mapeia o ponteiro \texttt{pf} a seu
único valor possível: \texttt{fe}. As outras anotações foram necessárias para
resolver os limites dos laços de cópia de memória dentro da função
\texttt{memcpy} da \texttt{libc}. Analisando o código fonte da aplicação, o pior
caso de chamada ao \texttt{memcpy} realiza a cópia de 23 bytes. As anotações da
Figura~\ref{prg:delcino_assert} levam isto em consideração. O resultado da
análise foi um WCET de 2.870 ciclos.

\prg{TeX}{delcino_assert}{Anotações para análise de WCET do desafio float bit a
bit.}

%\prg{TeX}{delcino_output}{Saída da análise de WCET do desafio float bit a
%bit.}


\subsection{Transformada Discreta de Fourier}

A Transformada de Fourrier é largamente utilizada em diversos cenários,
geralmente, para decompor sinais em suas componentes de frequência e amplitude.
A implementação apresentada neste desafio é uma versão da Transformada Discreta
de Fourrier operando sobre variáveis inteiras (ponto fixo).

O desafio proposto faz uso intensivo da biblioteca matemática \texttt{libm} que,
por sua vez, faz uso de uma série de estruturas e funções internas do GCC e da
\texttt{libc}. A análise deste código se mostrou um desafio praticamente
impossível. Vale destacar que, nestes casos, abordages que utilizam técnicas de
medição ao invés de análise estática de código são mais indicadas. Nestes casos
estas dependências pouco influenciam nos resultados de
análise~\cite{Wilhelm:2008}.

Acreditamos que, devido à complexidade dos grafos de fluxo e chamadas de função
gerados para esta aplicação pela interação com a \texttt{libm} o \boundt~não foi
capaz de gerar uma análise confiável. O principal problema encontrado dentro do
código das bibliotecas foi a existência de uma série de chamadas dinâmicas a
funções. Outro erro que nos levou a acreditar que o \boundt~estava operando de
forma inconsistente foi ele ter alegado a existência de uma recursão na função
\texttt{fft} do desafio. Analisando o código, contudo, não fomos capazes de
encontrar esta recursão.
% Os erros apresentados pelo \boundt~na análise desta aplicação estão na
% Figura~\ref{prg:fred_output}.

% \prg{TeX}{fred_output}{Saída da análise de WCET do desafio transformada de
% Fourier discreta.}

\subsection{Codec ADPCM}

Este desafio implementa algoritmos de codificação e decodificação do formato
ADPCM (Adaptive Differential Pulse-Code Modulation). Aparentemente, um bug no
\boundt, a análise da função main deste programa falhou. Descobrimos que, se
incluirmos limites por anotações às funções \texttt{\_\_aeabi\_ui2f} e
\texttt{\_\_aeabi\_i2f}, o bug não ocorria. Logo, analisamos os WCET destas
funções em separado, obtendo 42 ciclos como WCET da \texttt{\_\_aeabi\_ui2f} e
40 ciclos como WCET da \texttt{\_\_aeabi\_i2f}, podendo assim incluir estes WCET
como anotações (Figura~\ref{prg:juliano_assert}) e proceder a análise e
resolução dos demais laços cujos limites não puderam ser definidos.

A partir daí, vários laços cujos limites não puderam ser definidos surgiram para
as funções matemáticas \texttt{\_\_divsf3} e \texttt{\_\_mulsf3}. A
implementação destas funções, internas ao compilador GCC para ARM, estão em
linguagem de montagem no arquivo \texttt{ieee754-sf.S}, cuja análise se mostrou
uma tarefa bastante complexa. Sendo assim, visando completar a análise da
aplicação, consideramos tempo de execução zero para estas funções. Para obter
resultados mais precisos, contudo, uma análise mais detalhada destas funções em
linguagem de montagem é necessária. Como consequência, a análise de tamanho de
pilha da ferramenta deixa de funcionar adequadamente.

Os laços nas funções \texttt{factorial}, \texttt{power} e \texttt{cosine}
tiveram seus limites máximos (de pior caso) definidos baseados no valor do
iterador \texttt{i} utilizado na função \texttt{cosine}. Haviam também chamadas
dinâmicas a funções através de ponteiros para funções. Contudo, estes ponteiros
são inicializados no início da função \texttt{main}, logo, têm um único
comportamento, facilmente definido por anotações. As anotações utilizadas estão
na Figura~\ref{prg:juliano_assert}.

% \prg{TeX}{juliano_output2}{Saída da análise de WCET das funções matemáticas do
% desafio Codec ADPCM.}

Mesmo acreditando que todas as anotações estejam corretas, não foi possível
estimar o WCET desta aplicação porque a ferramenta \boundt~não finalizou a
análise. Todas as demais análises terminaram em menos de 5 segundos de execução.
A análise desta aplicação rodou por, aproximadamente, 1 hora até consumir toda a
memória disponível na máquina (4 GB). Provavelmente isto deve estar relacionado
a um bug da ferramenta.

% \prg{TeX}{juliano_output1}{Saída com erros da análise de WCET do desafio Codec
% ADPCM.}

\prg{TeX}{juliano_assert}{Anotações para análise de WCET do desafio Codec
ADPCM.}

% \prg{TeX}{juliano_output3}{Saída da análise de WCET do desafio Codec ADPCM
% com anotações.}

% 
% \subsection{Programa cnt.c do Benchmark do MRTC}
% 
% Este programa popula e soma uma matriz 10x10 de números inteiros. Novamente,
% alguns laços cujos limites não puderam ser definidos surgiram para funções
% matemáticas, sendo desta vez para a função \texttt{\_\_aeabi\_ddiv}. A
% implementação desta função também está no arquivo \texttt{ieee754-sf.S}, cuja
% análise em linguagem de montagem se mostrou uma tarefa bastante complexa.
% Sendo assim, visando completar a análise da aplicação, consideramos tempo de
% execução zero para esta função (Figura~\ref{prg:anton_assert}). Assim como na
% aplicação anterior, estas anotações tiveram como consequência o
% comprometimento da análise de pilha. O WCET deste desafio foi de 12.881
% ciclos.
% 
% \prg{TeX}{anton_assert}{Anotações para análise de WCET do desafio cnt.c.}
% 
% %\prg{TeX}{anton_output}{Saída com erros da análise de WCET do desafio cnt.c.}
