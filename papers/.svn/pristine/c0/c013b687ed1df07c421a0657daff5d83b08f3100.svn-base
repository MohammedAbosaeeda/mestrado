%% This LaTeX-file was created by <guto> Wed Dec 15 15:26:17 1999
%% LyX 0.12 (C) 1995-1998 by Matthias Ettrich and the LyX Team

%% Do not edit this file unless you know what you are doing.
\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\newcommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\spacefactor1000}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
  {\begin{list}{}{
    \setlength{\rightmargin}{\leftmargin}
    \raggedright
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \ttfamily\small}%
   \item[]}
  {\end{list}}

\makeatother

\begin{document}


\title{Inflated Interfaces: a Configuration Strategy for Component-Based Systems}


\author{Antônio Augusto Fröhlich and Wolfgang Schröder-Preikschat}

\maketitle

\section{Introduction}

Component-based software engineering is enabling the long dreamed production
of sofware as an assemblage of ordinary components. Similarly to other industries,
software developers can now reuse components, reduccing costs and accelerating
production. Moreover, in comparision to other component-based scenarios, for
instance to the largely aclaimed automotive industry, component-based software
engineering shows a significative advantage: software componentes, besides being
reused, can easiy be reconfigured to match particular requirements. This, for
the car industry, would mean having a single engine that could be configured
either to propel a limousine or a small city car.

This new software development strategy offers several possibilities to achieve
the configuration level needed to support high performance computing, since
componentes can be selected and configured according to specific applications
needs. Conceiving a software system as an assemblage of configurable components,
however, raises new challanges. How to manage the component repository, which
granularity should components have, how should they be configured, how should
they be put together, and how to grant that an assemblage of components matches
the requisites are some important questions that have to be answered in order
to make this strategy really effective.

This paper concentrates on the questions about how to configure components and
how to put them together. 


\section{Static x Dynamic Configuration}

Most software developers have a ready answer for the question whether static
or dynamic configuration should be applied. The answer, influenced mainly by
the workstation world, is in favor of the more flexible, but also more expensive,
dynamic configuration. In a workstation environment, it is usually impossible
to determine which application will be running at a given time. This dynamic
environment certainly demands for dynamic reconfigurations, also called adaptrations. 

Parallel and embedded systems share a different reality, since it is usually
possible to determine the set of applications that may be running at a given
time. In parallel systems, applications tend to live long enough to justify
restarting the system with an proper configuration. Embedded systems, disconsidering
firmware upgrades, usually don't suffer modifications on the set of possible
applications. Knowing the set of applications that may run on a system, in many
cases, allows for static reconfigurations without flexibility loss. 

Certaing system aspects, such as communication protocols and scheduling policies,
may certainly change during application execution. Support for dynamic adaptations
of such aspects shall always be present a configurable system. In the other
hand, aspects such as the number of processors, the need for address space protection
or for reliable communication, can usually be configured previous to application
execution.

An ideal model for component-based parallel or embedded systems, and of course
for embedded parallel systems too, should expose components that can be configured
either statically or dynamically, but should enables as many components as possible
to be statically configured. Cases in which a single realization of an interface
exists, should always be configured at compile time.


\section{Fine x Coarse Components}

The decision about how complex components should be has direct implications
on performance, configurability and maintainability. A system made up of a large
amount of fine components will certainly achieve bether performance than one
made up of a couple of coarse components, but it will also be more complex to
configure and maintain. To determine an ideal compromise for component granularity
is, and probably will always be, an untractable matter. To the confurability
prisma, however, there are some plausible assumptions. We propose to split components
in, at least, two groups: application-ready components and system components.

An application-ready components exports methods that are of direct interest
to applications, while system components counts for all the rest. 

Nevertheless, to make the problem of configuration 

virtually 


\section{Inflated Interfaces}

Inflated interfaces is a mechanism to export a component repository with fewer
interfaces and also to support static reconfigurations. 

\begin{lyxcode}
class~Network\_Adapter:~public~System\_Abstraction

\{

~~public:

~~~~//Constructors/destructors

~~~~Network\_Adapter();

~~~~Network\_Adapter(System\_Abstraction\_Unit~unit);

~~~~Network\_Adapter(const~Network\_Adapter~\&adapter);

~~~~\~{}Network\_Adapter();

~

~~~~//~Status/control~~~~

~~~~int~get\_status(Network\_Adapter\_Status~{*}status);

~~~~int~reset();

~~~~

~~~~//~Datagrams

~~~~int~send(Network\_Adapter\_Id~to,~void~{*}buffer,~unsigned~int~length);

~~~~int~receive(Network\_Adapter\_Id~{*}from,~void~{*}buffer,~unsigned~int~{*}length);

~

~~~~//~Streams~~~

~~~~int~connect(Network\_Adapter\_Id~destination,~Network\_Connection\_Id~{*});

~~~~int~disconnect(Network\_Connection\_Id);

~~~~int~write(Network\_Connection\_Id,~void~{*},~unsigned~int);

~~~~int~~read(Network\_Connection\_Id,~void~{*},~unsigned~int{*});

~

~~~~//~Active~messages

~~~~int~invoke(Network\_Adapter\_Id,~Active\_Message\_Handler~\&,~void~{*},~unsigned~int);

~

~~~~//~Distributed~shared~memory

~~~~int~export(void~{*}global,~void~{*}local,~unsigned~int~length);

~~~~int~import(void~{*}global,~void~{*}local,~unsigned~int~length);

~~~~int~lock(void~{*}global);

~~~~int~unlock(void~{*}global);

\};
\end{lyxcode}
An \{\char`\\{}sc Epos\} \{\char`\\{}em inflated interface\} for a system abstraction
embraces most of the consensual definitions for that abstraction. It is inflated
because, instead of a single representation, it brings together the most usual
representations for the abstraction it exports. Examples of inflated interfaces
are \{\char`\\{}em thread\}, \{\char`\\{}em task\}, \{\char`\\{}em address space\}
and \{\char`\\{}em communication channel\}. The inflated interface for the \{\char`\\{}em
thread\} abstraction gathers several different views of it, including, for example,
\{\char`\\{}em pthreads\} and native \{\char`\\{}sc Pure\} \{\char`\\{}em threads\}.
Multiple interfaces for an abstraction will only be present when incoherent
views have to be exported. \{\char`\\{}sc Epos\} inflated interfaces are extracted
from classical computer science books and system manuals, nevertheless, our
users, i.e., application programmers, are welcome to suggest modifications or
extensions to these interfaces at any time.

The use of inflated interfaces for system abstractions shall enable the application
programmer to express his expectations regarding the operating system simply
by writing down well-known system object invocations (system calls in non object-oriented
systems) while referring to its inflated interface. It is important to notice
that inflated interfaces are mere tools to export system abstractions. They
will never be implemented as a single class, but as a (possibly huge) set of
scenario specific ones. A tool shall bind (reduce) inflated interfaces to one
of its specific implementations.


\section{Applications Requirement Analisys}


\section{Reconfiguration}

\end{document}
