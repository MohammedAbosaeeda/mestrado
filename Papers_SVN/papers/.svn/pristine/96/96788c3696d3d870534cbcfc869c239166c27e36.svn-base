\section{Power Management API}\label{sec:api}

% PM at design-time
% PM API in other systems
% - Automatic (ignores designer's knowledge)
% - At the hardware interface level
% - Non portable
% Proposed PM API
% - User-visible abstractions
% - No distinction from software and hardware components
% - Operational modes
%   - Arbitrary x semantic modes
% - Process throttling
%   - DVS

% Design of Energy-aware Embedded Systems
In order to introduce a discussion about power management
\emph{Application Programming Interfaces}~(API), let us first recall how
energy consumption requirements arise during the design of an
energy-aware embedded system and how they are usually captured. In such
systems, designers look for available energy-efficient components and,
eventually, specify new components to be implemented. During this
process, they inherently acquire knowledge about the most adequate
operating strategy for each component and for the system as a whole.
Whenever the identified strategies are associated to modifications in
the energy level of a given component, this can be captured in
traditional design diagrams, such as sequence, activity and timing, or
by specific tools~\cite{Chou:2002}.

% Example
% - Summary
% - Block diagram
Now let us consider the design of a simple application, conceived
specifically to illustrate the translation of energy constraints from
design to implementation. This application realizes a kind of remote
monitoring system, capable of sensing a given property (e.g.
temperature), reporting it to a control center, and reacting by
activating an actuator (e.g. external cooler) whenever it exceeds a
certain limit.  Interaction with the control center is done via a
communicator (e.g.  radio). The system operates on batteries and must
run uninterruptedly for one year. A block diagram of the system is shown
in figure~\ref{fig:example-block_diagram}.

\fig{example-block_diagram}{scale=0.75}{Example monitoring system block
  diagram.}

% Example
% - Description
% - Diagrams
The application is modeled around four tasks whose behavior is depicted
in the sequence diagrams of
figures~\ref{fig:example-sequence_diagram-main} through
\ref{fig:example-sequence_diagram-recovery}: \texttt{Main} allocates
common resources and creates threads to execute the other three tasks;
\texttt{Monitor} is responsible for periodic temperature monitoring
(every second), for reporting the current temperature to the control
center (every 10 seconds), and, in case the temperature threshold is
exceeded, for triggering the emergency handling thread; \texttt{Trigger}
is responsible for triggering the emergency handling thread on command
of the control center; and \texttt{Recovery}, the emergency handling
thread, is in duty of firing an one-shot actuator intended at restoring
the temperature to its normal level. Coordination is ensured by properly
assigning priorities to threads and by the \texttt{emergency}
semaphore. % (see figure~\ref{fig:example-coordination}).

\fig{example-sequence_diagram-main}{scale=0.75}{Main thread sequence
  diagram with power management actions.}
\fig{example-sequence_diagram-monitor}{scale=0.75}{Monitor thread sequence
  diagram with power management actions.}
\fig{example-sequence_diagram-trigger}{scale=0.75}{Trigger thread sequence
  diagram with power management actions.}
\fig{example-sequence_diagram-recovery}{scale=0.75}{Recovery thread sequence
  diagram with power management actions.}

% PM at design-time
% - PM knowledge from designer
% - Expressible in UML
In the sequence diagrams of
figures~\ref{fig:example-sequence_diagram-main}
through~\ref{fig:example-sequence_diagram-recovery}, energy-related
actions captured during design are expressed by messages and remarks.
For instance, the knowledge that the \texttt{Thermometer} component uses
a low-cost thermistor and therefore must perform 64 measurements before
being able to return a temperature value within the desired precision is
expressed as a note associated with the method
(figure~\ref{fig:example-sequence_diagram-monitor}).  In order to be
energetically efficient, the circuitry behind \texttt{Thermometer} (i.e.
ADC and thermistor) should be kept active during all the measurement
cycle, thus avoiding repetitions of the electrical stabilization
phase\footnote{In a typical ADC/thermistor configuration, the electrical
  stabilization phase accounts up to 98\% of the measurement cycle, both
  in terms of time and in terms of energy~\cite{Panasonic:ERTJ:2004}.}.

The diagrams also show power management hints for the
\texttt{Communicator} component (figures
\ref{fig:example-sequence_diagram-monitor},
\ref{fig:example-sequence_diagram-trigger}, and
\ref{fig:example-sequence_diagram-recovery}), which is mostly used to
listen for a message from the control center and thus can be configured
on a listen-only state for most of the time. And, indirectly, also for
the \texttt{CPU} component, which must operate in the maximum frequency
while running the \texttt{Recovery} thread, but can operate in lower
frequencies for the other threads
(figure~\ref{fig:example-sequence_diagram-main}). With this information
in hand, the system can be implemented to be more efficient in terms of
energy, either by the programmer himself or by means of an automatic
power manager.

% Example
% - Energy estimates
% - Power management
Considering the functional properties described so far and the execution
period of each thread, it is possible to estimate duty cycles for each
of the major components in the example system.  This information can
then be combined with energy consumption estimates of individual
components to calculate the power supply required by the system. This
procedure is summarized in table~\ref{tab:example-energy_estimates},
which shows hypothetical energy consumption estimates, duty cycles and
energy consumption for the four major components in the
system\footnote{Estimates were based on the Mica2 sensor
  node~\cite{Hill:2004}}.

\tab{.9\textwidth}{example-energy_estimates}{Example monitoring system energy
  consumption estimates.}

In order to match the requirement of operating uninterruptedly for one
year, the system would demand a battery capable of delivering
approximately 3576~mAh (at 3~V). For comparison, the same system
operating with all components constantly active, that is, without any
power saving strategy, would require about 142 Ah, almost 40 times more.

\subsection{Current APIs}

% Current APIs
% - Low level -> breaks portability
% - OS-driven -> ignores designer's knowledge
Few systems targeting embedded computing can claim to deliver a real
Power Management API. Nevertheless, most systems do deliver mechanisms
that enable programmers to directly access the interface of some
hardware components. These mechanism, though not specifically designed
for power management, can be used for that purpose at the price of
binding the application to hardware details.

% uClinux
% - 
\textsc{$\mu$Clinux}, like many other \textsc{Unix}-like systems, does
not feature a real power management API. Some device drivers provide
power management functions inspired on ACPI. Usually these mechanisms
are intended to be used by the kernel itself, though a few device
drivers export them via the \texttt{/sys} or \texttt{/proc} file
systems, thus enabling applications to directly control the operating
modes of associated devices.

\prg{C}{example-source-uclinux}{\texttt{Thermometer::sample()} method
  implementation for \textsc{$\mu$Clinux}.}

The source code in figure~\ref{prg:example-source-uclinux} is a
user-level implementation of the \texttt{Thermometer::sample()} method
of our example monitoring system. In this implementation, programmers
must explicitly identify the driver responsible for the ADC to which
the thermistor is connected. Besides the overhead of interacting with
the device driver through the \texttt{/sys} file system,
\textsc{$\mu$Clinux} PM API creates undesirable dependencies and would
fail to preserve the application in case the thermistor gets connected
to another ADC channel or in case the ADC in the system gets replaced by
another model.


% TinyOS
% - Low-level, good performance, non-portable
\textsc{TinyOS}, a popular operating system in the wireless sensor
network scene, allows programmers to control the operation of hardware
components through a low-level, architecture-dependent API. Though not
specifically designed for power management purposes, this API ensures
direct access to the hardware and thus can be used in this sense. When
compared to \textsc{$\mu$Clinux}, \textsc{TinyOS} delivers a lighter
mechanism, more adequate for most embedded system, yet suffers from the
same limitations in respect to usability and portability. The use of
\textsc{TinyOS} hardware control API for power management is illustrated
in figure~\ref{prg:example-source-tinyos}, which depicts the
implementation of the \texttt{Trigger} thread of our example.

\prg{C}{example-source-tinyos}{\texttt{Trigger} thread implementation
  for \textsc{TinyOS}.}

% MantisOS
% - 
\textsc{Mantis}, features a \textsc{Posix}-inspired API that abstracts
hardware devices as \textsc{Unix} special files. Differently of
\textsc{$\mu$Clinux} and \textsc{TinyOS}, however, \textsc{Mantis} does
not propose that API to be used for power management purposes: internal
mechanisms automatically deactivate components that have not been used
for a given time, or perform an ``on-act-off'' scheme, thus implementing
a sort of OS-driven power manager. This strategy can be very efficient,
but makes it difficult for programmers to express the knowledge about
energy consumption acquired during the design process.  This is made
evident in the implementation of the \texttt{Thermometer::sample()}
depicted in figure~\ref{prg:example-source-mantis}. Unaware of the
precision required for the temperature variable, \textsc{Mantis} cannot
predict that the ADC is being used in a loop and misses the opportunity
to avoid the repetition of the expensive electrical stabilization phase
of the thermometer operation.

\prg{C}{example-source-mantis}{Thermometer::sample() method implementation
  for \textsc{Mantis}.}

%\clearpage

Some systems assume that architectural dependencies are intrinsic to the
limitations of typical embedded systems, however, this is exactly the
share of the computing systems market that could benefit from a large
diversity of suppliers~\cite{Tennenhouse:2000} and therefore would
profit from quick changes from one architecture to another.  This, in
addition to the fact that current APIs do not efficiently support the
expression of design knowledge during system implementation, led us to
propose a new PM API.


\subsection{Proposed API}

The Power Management API proposed here arose from the observation that
currently available APIs require application programmers to go down to
the hardware whenever they want to manage power, inducing unnecessary
and undesirable architectural dependencies between application and the
hardware platform. In order to overcome these limitations, we believe a
PM API for embedded systems should present the following
characteristics:

\begin{itemize}
\item Enable direct application control over energy-related issues, yet
  not excluding delegation or cooperation with an autonomous power
  manager;

\item Act also at the level of user-visible components, instead of being
  restricted to the level of hardware component interfaces, thus
  promoting portability and usability;

\item Be suitable for both application and system programming, thus
  unifying power management mechanisms and promoting reuse;

\item Include, but not be restricted to, semantic modes, thus enabling
  programmers to easily express power management operations while
  avoiding the limitations of a small, fixed number of operating modes
  (as is the case of ACPI).
\end{itemize}

With these guidelines in mind, we developed a very simple API, which
comprises only two methods, and an extension to the methods responsible
for process creation. They are:

\bigskip

\texttt{Power\_Mode power(void)}

\smallskip

\texttt{void power(Power\_Mode)}

\bigskip

The first method returns the current power mode of the associated object
(i.e., component), while the second allows for mode changes.  Aiming at
enhancing usability, four power modes have been defined with semantics
that must be respected for all components in the system: \emph{off},
\emph{stand-by}, \emph{light} and \emph{full}. Each component is still
free to define additional power modes with other semantics, as long as
the four basic modes are preserved. Enforcing universal semantics for
these power modes enables application programmers to control energy
consumption without having to understand the implementation details of
underlying components (e.g., hardware devices). Allowing for additional
modes, on the other hand, enables programmers to precisely control the
operation of special components, whose operation transcend the
predefined modes.

The introduction of these methods in user-visible components such as
files and sockets certainly requires some sort of propagation mechanism
and could itself introduce undesirable dependencies. We describe a
strategy to implement them using a combination of \emph{Aspect-Oriented
  Programming} techniques and \emph{Hierarchical Petry Nets} later in
section~\ref{sec:infra}. For now, lets concentrate on the
characterization of the API, not the mechanisms behind it.

Table~\ref{tab:api-modes} summarizes the semantics defined for the
four universal operating modes. A component operating in mode
\emph{full} provides all its services with maximum performance,
possibly consuming more energy than in any other mode. Contrarily, a
component in mode \emph{off} does not provide any service and also
does not consume any energy. Switching a component from \emph{off} to
any other power mode is usually an expensive operation, specially for
components with high initialization and/or stabilization times. The
mode \emph{stand-by} is an alternative to \emph{off}: a component in
\emph{stand-by} is also not able to perform any task, yet, bringing it
back to \emph{full} or \emph{light} is expected to be quicker than
from mode \emph{off}. This is usually accomplished by maintaining the
state of the component ``alive'' and thus implies in some energy
consumption.  A component that does not support this mode natively
must opt between remaining active or saving its state, perhaps with
aid from the operating system, and going off.

\tab{.75\textwidth}{api-modes}{Semantic power modes of the proposed PM API.}

Defining the semantics for mode \emph{light} is not so
straightforward. A component in this mode must deliver all its services,
but consuming the minimum amount of energy. This definition brings about
two important considerations. First, if there is a power mode in which
the component is able to deliver all its services with the same quality
as if it was in mode \emph{full}, then this should be mode \emph{full}
instead of \emph{light}, since it would make no sense to operate in a
higher consumption mode without arguable benefits.  Hence, mode
\emph{light} is often attained at the cost of performance (e.g., through
DVS). This, in turn, brings about a second consideration: for a
real-time embedded system, it would be wrong to state that a component
is able to deliver ``all its services'' if the added latency is let to
interfere with the time requirements of applications. Therefore, mode
\emph{light} shall not be implicitly propagated to the CPU
component. Programmers must explicitly state that they agree to slow
down the processor to save energy, or a energy-aware, real-time
scheduler must be deployed~\cite{Wiedenhoft:ETFA:2007}.

Besides the four operating modes with predefined, global semantics, a
component can export additional modes through the API. These modes are
privately defined by the component based on its own peculiarities, thus
requiring the client components to be aware of their semantics in order
to be deployed.  The room for extensions is fundamental for hardware
components with many operating modes, allowing for more refined energy
management policies. For instance, the \emph{listen-only} radio mode in
our example (see figure~\ref{fig:example-sequence_diagram-trigger})
relies on such an extension.

The proposed API also features the concept of a \texttt{System}
pseudo-component, which can be seen as a kind of aggregator for the
actual components selected for a given system instance. The goal of
the \texttt{System} component is to aid programmers to express global
power management actions, such as putting the whole system in a given
operating mode, perhaps after having defined specific modes for
particular components.


\fig{api-hierarchy}{width=\textwidth}{Power Management API
  utilization example.}

Figure~\ref{fig:api-hierarchy} presents all these interaction modes in a UML
communication diagram of a hypothetical system instance. The
application may access a global component (\texttt{System}) that has
knowledge of every other component in the system, triggering a
system-wide power mode change (execution flow 1). The \textsc{API} can
also be accessed to change the operating mode of a group of components
responsible for the implementation of a specific system functionality
(in this example, communication functionality through execution flow
2). The application may also access the hardware directly, using the
API available in the device drivers, such as \textit{Network Interface
Card} (\texttt{NIC}), \texttt{CPU}, \texttt{ADC} (in the figure,
application is accessing the CPU through the execution flow 3). The
\textsc{API} is also used between the system's components, as can be
seen in the figure.

\prg{C++}{example-source-epos}{Example monitoring system
  implementation using the proposed PM API.}

In a system that realizes the proposed API, the monitoring system
introduced earlier could be implemented as show in
figure~\ref{prg:example-source-epos}, a rather direct transcript of the
sequence diagrams of figures~\ref{fig:example-sequence_diagram-main}
through~\ref{fig:example-sequence_diagram-recovery}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pm"
%%% End:
