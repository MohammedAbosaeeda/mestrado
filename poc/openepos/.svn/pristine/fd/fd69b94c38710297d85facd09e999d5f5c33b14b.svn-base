//
//  NanoVM, a tiny java VM for the Atmel AVR family
//  Copyright (C) 2005 by Till Harbaum <Till@Harbaum.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

//
//  stack.c


//#include "types.h"
#include "debug.h"
#include "config.h"
#include "error.h"
#include "nvmfile.h"
#include <system.h>
#include "vm.h"
#include "stack.h"
#define nvm_ref2stack(x) (x)
#define nvm_stack2ref(x) (x)

#ifdef NVM_USE_FLOAT
nvm_stack_t nvm_float2stack(nvm_float_t val);
nvm_float_t nvm_stack2float(nvm_stack_t val);
#endif
//#include "heap.h"

__USING_SYS

// the stack
/*static nvm_stack_t *stack;     // the pysical base of the whole stack (incl. statics)
static nvm_stack_t *sp;        // the current stack pointer
static nvm_stack_t *stackbase; // the base of the runtime stack (excl. statics)
*/
//#ifdef NVM_USE_STACK_CHECK

#include <alarm.h>
int StackVm::_magic = 64;

void StackVm::print() {

    for (int i = 0 ; i < 7 ; i++)
        db<VM> (TRC) << "Address: " << hex << this->stack + i << endl <<
                        "Value: " << hex << (unsigned int)*(this->stack + i) << endl;

}

int StackVm::copy(StackVm * stack){

    int i = 0;
    for ( nvm_stack_t* addr =  stack->stack ; addr <= stack->sp ; addr++){
   //     db<VM> (TRC) << "Copying stack: \n Address -> " << hex << addr <<
     //                   "Value: "<<  hex << *addr << endl;

//
  //     db<VM>(TRC) << "this->stack address: " << hex << (this->stack + i) << endl <<
    //                   "Old this->stack value: " << hex << *(this->stack + i) << endl;

        *(this->stack + i) = (unsigned int) *addr;
    //    db<VM> (TRC) << "new this->stack value: " << hex << *(this->stack + i) << endl;

        i++;


      //  Alarm::delay(1000000);
    }

   // db<VM> (TRC) << "Old sp: " << hex << this->sp << endl;
   // this->sp = this->sp + i - 4;
    //db<VM> (TRC) << "New sp: " << hex << this->sp << endl;
  //  Alarm::delay(5000000);
    return i;
}


StackVm::StackVm(){}
// save current stack pointer
void StackVm::stack_save_sp(void) {
  if(sp_saved != 0) {
    db<VM>(INF) << "sp_saved already in use\n";
    error(ERROR_VM_STACK_CORRUPTED);
  }

  sp_saved = sp;  // save stack pointer
}

// check if current stack pointer equals saved one
void StackVm::stack_verify_sp(void) {
  if(sp != sp_saved) {
    db<VM>(INF) << (u08_t*)sp-(u08_t*)sp_saved << " bytes on stack\n";
    error(ERROR_VM_STACK_CORRUPTED);
  }
  sp_saved = 0;
}
//#endif

void StackVm::init(){

    db<VM> (TRC) << " +++ StackVM::init() +++" << endl;

    this->stack = (nvm_stack_t*) HeapVM::getInstance()->heap_get_base() + _magic;
    this->sp = stack  -1;
    _magic = _magic + _magic;
    db<VM> (TRC) << "stack => "  << stack << endl;
    db<VM> (TRC) << "sp: " << sp << endl;

}

void StackVm::stack_init(u08_t static_fields) {
  //stack = 0x10;
  //stackbase = 0x110;
  //sp = 0x10;
  // the stack is generated by stealing from the heap. This
  // is possible since the class file tells us how many stack
  // elements the call to a method requires
  this->stack =  (nvm_stack_t*) HeapVM::getInstance()->heap_get_base();
  this->sp = stack-1;
  db<VM> (TRC) << "stack => "  << stack << endl;
  db<VM> (TRC) << "sp: " << sp << endl;


  // db<VM> (TRC) << "StackBase => " << stackbase << endl;

  // steal one item for mains args and the space required for
  // the static fields
  HeapVM::getInstance()->heap_steal((1+static_fields)*sizeof(nvm_stack_t));

  // increase stack pointer behind static fields
  this->sp += static_fields;
  void * spAdress = sp;
  db<VM> (TRC)<< "sp + static fields: " << spAdress << endl;
   stack_get_depth();
}

// push an item onto the vms stack
void StackVm::stack_push(nvm_stack_t val) {
  *(++sp) = val;

}

// pop an item from the vms stack
nvm_stack_t StackVm::stack_pop(void) {
  return *(sp--);
}

// pop an item from the vm stack
nvm_int_t StackVm::stack_pop_int(void) {
    return this->nvm_stack2int(*(sp--));
}

// peek into the nvm stack
nvm_stack_t StackVm::stack_peek(u08_t index) {
  return sp[-index];
}

// peek into the stack and expand 15->16 bits
nvm_int_t StackVm::stack_peek_int(u08_t index) {
    return nvm_stack2int(sp[-index]);
}

// pop address from stack
void * StackVm::stack_pop_addr(void) {
    nvm_ref_t ref = *(sp--);
    //cuidado nao verificando erros que estao na classe VM
     if((ref & NVM_TYPE_MASK) == NVM_TYPE_HEAP)
    return HeapVM::getInstance()->heap_get_addr(ref);


     NvmFile* nvmFile = NvmFile::instance();
     return NVMFILE_SET(nvmFile->nvmfile_get_addr(ref & ~NVM_TYPE_MASK));
}

// peek into the nvm stack for address
void * StackVm::stack_peek_addr(u08_t index) {
    return HeapVM::getInstance()->heap_get_addr(sp[-index]);
}

# ifdef NVM_USE_FLOAT
nvm_float_t StackVm::stack_pop_float(void)
{
    return nvm_stack2float(*(sp--));
}

nvm_float_t StackVm::stack_peek_float(u08_t index)
{
    return nvm_stack2float(sp[-index]);
}
#endif


#ifdef NVM_USE_FLOAT
nvm_stack_t StackVm::nvm_float2stack(nvm_float_t val)
{
  nvm_union_t v;
  v.f[0]=val;
  //printf("float = %f == 0x%x", v.f[0], v.i[0]);
  uint8_t msb = (v.b[3]&0x80)?0x40:0x00;
  v.b[3] &= 0x7f;
  if (v.b[3]==0x7f && (v.b[2]&0x80)==0x80)
    msb |= 0x3f;
  else if (v.b[3]!=0x00 || (v.b[2]&0x80)!=0x00)
    msb |= v.b[3]-0x20;
  v.b[3]=msb;
  //printf(" -> encoded = 0x%x\n", v.i[0]);
  return v.i[0];
}

nvm_float_t StackVm::nvm_stack2float(nvm_stack_t val)
{
  nvm_union_t v;
  v.i[0]=val;
  //printf("encoded = 0x%x", v.i[0]);
  uint8_t msb = (v.b[3]&0x40)?0x80:0x00;
  v.b[3] &= 0x3f;
  if (v.b[3]==0x3f && (v.b[2]&0x80)==0x80)
    msb |= 0x7f;
  else if (v.b[3]!=0x00 || (v.b[2]&0x80)!=0x00)
    msb |= v.b[3]+0x20;
  v.b[3]=msb;
  //printf(" -> float = %f == 0x%x\n", v.f[0], v.i[0]);
  return v.f[0];
}
#endif

nvm_int_t StackVm::nvm_stack2int(nvm_stack_t val) {
  if(val & (NVM_IMMEDIATE_MASK>>1))
    val |= NVM_IMMEDIATE_MASK;   // expand sign bit
  return val;
}



// the following two routines are used during method invocation and return
// they are used to make space for local variables on the stack
// and to determine the current stack address to be used for the local
// variables
void StackVm::stack_add_sp(s08_t offset) {
  sp += offset;
}

nvm_stack_t * StackVm::stack_get_sp(void) {
  return sp;
}

// static variables are allocated at vm startup on the stack. the following
// two routines provide access to these variables
nvm_stack_t StackVm::stack_get_static(u16_t index) {
  return stack[index];
}

void StackVm::stack_set_static(u16_t index, nvm_stack_t value) {
  stack[index] = value;
}

// our way to determine if the java application is being
// finished is to check if the return instruction would cause the
// stack to underflow. this happens, since the main method ends
// with a return statement like any other method. the following
// two methods are used to save the state of the empty stack (there
// may be already the static variables be on the stack) and to check
// whether the stack is filled with the static variables only (it is empty)
void StackVm::stack_save_base(void) {
  stackbase = stack_get_sp();
  db<VM> (TRC) << "Base of stack: " << hex <<(int) stackbase << endl;
}

bool_t StackVm::stack_is_empty(void) {
    db<VM> (TRC) << "stack base depth: " << hex <<
                    (int) ((int)sp)- ((int)stackbase) << endl;
  return(sp == stackbase);
}

//#ifdef DEBUG
u16_t StackVm::stack_get_depth(void) {
  //  db<VM> (TRC) << "get depth: " << endl;
  //  db<VM>(TRC) <<"sp: " << sp << endl << "stack: " << stack << endl;


  return sp-stack;
}
//#endif

#ifdef NVM_USE_HEAP_IDMAP
void StackVm::stack_mark_heap_root_ids(void) {
  u16_t i;

  // DEBUGF("stack_mark_heap_root_ids()\n");
  // since the locals are physically part of the stack we only need
  // to search the stack
  for(i=0;i<sp-stack+1;i++) {

    // we are searching for heap objects only
    if((stack[i] & NVM_TYPE_MASK) == NVM_TYPE_HEAP)
      heap_mark_id(stack[i] & ~NVM_TYPE_MASK);
  }
}
#else
bool_t StackVm::stack_heap_id_in_use(heap_id_t id) {
  // we are searching for heap objects only
  u16_t i;
  nvm_ref_t id16 = id | NVM_TYPE_HEAP;

  // since the locals are physically part of the stack we only need
  // to search the stack
  for(i=0;i<sp-stack+1;i++) {
//    // DEBUGF("Stack %d == "DBG16"\n", i, stack[i]);
    if(stack[i] == id16) return true;
  }

  return false;
}
#endif
