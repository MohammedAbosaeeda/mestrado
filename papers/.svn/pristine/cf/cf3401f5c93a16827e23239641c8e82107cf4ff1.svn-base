\section{Background}
%\section{QoS: The Role of Energy}
\label{sc:proposta}

%- Atender o tempo de duração do sistema. Através da utilização de técnicas da computação imprecisa. Parte obrigatória e Parte opcional... (Explicar o que é em 2 ou 3 parágrafos). 

%Este trabalho tem como proposta o desenvolvimento de uma abordagem para garantir que o tempo de vida da bateria de sistemas embarcados possa durar o tempo desejado pela aplicação com os \deadlines{} atendidos de, no mínimo, tarefas essenciais especificadas previamente pelo usuário. Para isso, nosso escalonador deve realizar diminuições controladas dos níveis de \qos{} da aplicação com objetivo de economizar energia quando é detectada que a carga da bateria não será suficiente para atender o tempo especificado pela aplicação. Neste trabalho, o controle da diminuição dos níveis de \qos{} da aplicação é inspirado nos mecanismos da computação imprecisa~\cite{Liu:1994}, que divide as tarefas em duas partes: uma parte obrigatória e outra parte opcional. O escalonador proposto é baseado no algoritmo de escalonamento \textsc{EDF} (\emph{Earliest Deadline First}) com objetivo de atender os \deadlines{} das partes obrigatórias. 

This work aims at guaranteeing that the batteries used in an embedded system
can last at least the time required by the application and yet preserving the
deadlines of essential tasks, i.e., the deadlines of hard real-time tasks.
%meeting the deadlines of essential tasks as defined by the embedded system developer. 
%This work developed an approach to guarantee that embedded systems' batteries lifetime can last time desired by application with deadlines met of at least essential 
Our scheduler
starts to decrease \qos{} levels in order to save energy when it detects
that batteries will not last long enough to satisfy a previously defined
expected system lifetime. The decreased control of application \qos{} levels is
based on imprecise computation mechanisms~\cite{Liu:1994}, which divide tasks
into two subtasks: a mandatory one and an optional one. The proposed scheduler 
is based on the \textsc{EDF} (\emph{Earliest-Deadline First}) scheduling algorithm.
%in order to meet the mandatory subtasks deadlines.

%A seção~\ref{sc:proposta:imprecisa} descreve a computação imprecisa e a inspiração para a energia. Seção~\ref{sc:proposta:edf} aborda o algoritmo de escalonamento \textsc{EDF}. Seção~\ref{sc:proposta:proposta} apresenta a proposta com maiores detalhes, bem como o algoritmo do escalonador e as equações que devem ser respeitadas para as tarefas serem escalonáveis.

% Comentário Lucas: este segundo índice tá forcado! Acho que elimina!

%Section~\ref{sc:proposta:imprecisa} describes the imprecise computation and the
%inspiration for energy. Section~\ref{sc:proposta:edf} gives an insight on
%scheduling algorithm \textsc{EDF}. Section~\ref{sc:proposta:proposta} presents
%the scheduler algorithm with more details and the equations that must be
%respected to the tasks being scalable.


\subsection{Imprecise Computation}
\label{sc:proposta:imprecisa}

%A computação imprecisa é uma técnica de escalonamento originalmente proposta para atender os requisitos temporais das tarefas de tempo real através de diminuições controladas dos níveis de \qos{}. O controle dos níveis de \qos{} realizado pela computação imprecisa diminui a qualidade do resultado, não executando as partes opcionais, com objetivo de garantir que nenhum \deadline{} de execução das partes obrigatórias seja perdido. 

Imprecise computation is a scheduling technique originally proposed to
satisfy timing requirements of real-time tasks through decreasing
levels of \qos{}. The control of application \qos{} levels done by imprecise
computation worsens quality of results by not executing optional subtasks 
in order to guarantee that no mandatory subtask deadlines will be lost.

%Com a divisão de cada tarefa em duas partes, a computação imprecisa une a computação de tempo real e as técnicas de ``melhor esforço'' para, respectivamente, a parte obrigatória e a parte opcional. A parte obrigatória das tarefas gera resultados imprecisos que refletem o mínimo de \qos{} para garantir que esses resultados sejam úteis. Os resultados imprecisos têm suas qualidades elevadas quando as partes opcionais são executadas, com a geração de resultados precisos. 

With the division of each task into two parts, imprecise computation unites
real-time computing and ``best effort'' techniques for, respectively, the
mandatory and optional subtasks. The mandatory subtask of imprecise tasks
generates imprecise results which reflect the minimum of \qos{} to guarantee
that these results are useful. These imprecise results have their quality
enhanced when the optional subtask executes, generating the precise
results.

%
%- Explicar sobre os estados possíveis das partes das tarefas. Figura~\ref{fig:diagramaAutomatosFinitos} é um diagrama ...
%

%A figura~\ref{fig:diagramaAutomatosFinitos} apresenta as transições de estados da parte obrigatória e da parte opcional. O estado \textit{Esperando} indica as tarefas que esperam por um novo período. O estado \textit{Pronto} indica as tarefas que estão prontas para executarem e aguardam serem escalonadas. A tarefa no estado \textit{Executando} é aquela que está utilizando o processador. Nessa figura é possível observar que a diferença entre as transições de estados da obrigatória e da opcional é do estado \textit{Pronto} para o estado \textit{Esperando}. Essa diferença indica que a parte opcional pode ser cancelada antes mesmo de ser executada, pois ela estaria no estado \textit{Pronto} e não no estado \textit{Executando}. Além disso, a parte opcional pode ser cancelada durante a execução, ou seja, do estado \textit{Executando} para o estado \textit{Esperando}, mesmo que não tenha terminado a sua execução. A parte obrigatória só pode ir para o estado \textit{Esperando} depois que passar pelo estado \textit{Executando} e finalizar a execução no seu período.


%Figure~\ref{fig:diagramaAutomatosFinitos} presents the state transitions of the mandatory and optional subtasks. In the \textit{WAITING} state are the tasks waiting for a new period. In the \textit{READY} state are the tasks ready to execute and waiting to be scheduled. The task in the \textit{RUNNING} is the one using the processor. It is possible to observe in this figure that the difference between mandatory and optional state transitions is from state \textit{READY} to state \textit{WAITING}. This difference indicates that the optional subtask can be canceled before to be executed, because it would be in the \textit{READY} state and not in the \textit{RUNNING} state. Moreover, the optional subtask can be canceled during the execution, i.e., from \textit{RUNNING} state to \textit{WAITING} state without to finish its execution. The mandatory subtask can only go to \textit{WAITING} state after to pass in the \textit{RUNNING} state and to finalize its execution in the period. 


%\begin{figure}[!ht]
%\centering
%     {\includegraphics[scale=0.45]{figuras/statesTransitions.eps}}
%     %\caption{Transições de estados da parte obrigatória e da parte opcional.}
%     \caption{State transitions of the mandatory and optional subtasks.}
%     \label{fig:diagramaAutomatosFinitos}
%\end{figure}

%Na literatura existem diversas possibilidades de aplicações da computação imprecisa, como, por exemplo, o processamento de imagens. Neste exemplo, as partes obrigatórias gerariam uma imagem com uma qualidade mínima aceitável, enquanto que as partes opcionais aumentariam a qualidade dessa imagem. Os algoritmos ``a qualquer tempo'' são outras possibilidades de aplicações para a computação imprecisa, que incluem: os métodos numéricos, os cálculos de raízes, os cálculos de polinômios, as aproximações numéricas, e entre outros. Esses algoritmos, normalmente, implementam métodos iterativos que refinam os resultados depois de cada iteração. Nesse caso, quanto mais tempo o algoritmo é executado, melhor é a qualidade do resultado. As aplicações de controle\&conforto são outras possibilidades para a computação imprecisa. Um exemplo é o monitoramento da temperatura de uma caldeira que pode derreter ou até mesmo explodir caso ultrapasse uma certa temperatura. Nesse exemplo, o controle verifica em períodos específicos a temperatura da caldeira e aciona recursos para diminuir essa temperatura caso ultrapasse um valor. O conforto pode realizar cálculos adicionais nos dados das temperaturas obtidas, como a média das temperaturas analisadas em um determinado período, a contagem do número de vezes que a temperatura chegou a um certo nível, e entre outros. 
%Entretanto, em caso de sobrecarga no sistema, essas tarefas realizadas pelo ``conforto'' podem ser descartadas pelo maior grau de importância das tarefas realizadas pelo ``controle''. 


Literature presents several possible applications of imprecise
computation. For instance, one can use imprecise tasks to implement image
processing systems. In this example, the mandatory subtasks should generate an
image with an acceptable quality while optional subtasks could enhance
the image quality. The ``anytime algorithms'' are other possibilities of
imprecise computation which include among others: 
numeric methods, roots calculations,
polynomials calculations and numeric approximations. These algorithms usually
implement iterative methods that refine the results after each iteration. In
this case, the longer an algorithm is executed, better is the result
quality. Another set of applications are control\&comfort applications, which
the control being the mandatory subtask and the comfort being 
the optional subtask. One example is the monitoring of the boiler temperature 
that can melt or even explode. In this example, the control verifies the
temperature and triggers resources to reduce that when the temperature exceed a
threshold. The comfort can calculate information about the sampled temperature
such as the temperatures average in a period, the number of times that
temperature exceed a threshold, and among others. 


%- Explicar a possibilidade para energia na figura~\ref{fig:energiaComputacaoImprecisa}.

%A partir desse conceito de divisão de cada tarefa em parte obrigatória e parte opcional, a computação imprecisa mostra-se favorável para a utilização em nossa proposta em relação à energia. A figura~\ref{fig:energiaComputacaoImprecisa} apresenta uma tarefa que consumiria \textsc{X} unidades de energia obrigatoriamente, e quando dividida em parte obrigatória (\textsc{Y} unidades de energia) e parte opcional (\textsc{Z} unidades de energia) permite a economia de \textsc{Z} unidades de energia caso a parte opcional não seja executada.

The imprecise computation showed us favorable to use in our proposal in relation
to energy. Suppose that a task consumes \textsc{X} energy units obligatorily.
When it is divided into mandatory subtask (\textsc{Y} energy units) and optional
subtask (\textsc{Z} energy units) the scheduler can save \textsc{Z} energy units
if the optional subtask is not executed.


%Figure~\ref{fig:energiaComputacaoImprecisa} presents a task that consumes \textsc{X} energy units obligatorily. When it is divided into mandatory subtask (\textsc{Y} energy units) and optional subtask (\textsc{Z} energy units) the scheduler can save \textsc{Z} energy units if the optional subtask is not executed. Thus, the imprecise computation show us favorable to use in our proposal in relation to energy.


%\begin{figure}[!ht]
%\centering
%     {\includegraphics[scale=0.58]{figuras/energyImpreciseComputation.eps}}
%     %\caption{Computação imprecisa em relação à energia consumida.}
%     \caption{Imprecise computation in relation to energy consumed.}
%     \label{fig:energiaComputacaoImprecisa}
%\end{figure}


\subsection{\textsc{EDF}}
\label{sc:proposta:edf}


%- Utilização do algoritmo EDF para atender as partes obrigatórias. (Explicar sobre o EDF) (Posso colocar figura)

%O algoritmo \textsc{EDF} (\emph{Earliest Deadline First})~\cite{Liu:1973} é um mecanismo de escalonamento tempo real baseado em prioridades dinâmicas e muito utilizado na literatura. \textsc{EDF} distribui maiores prioridades para as tarefas com \deadlines{} mais curtos. Em tempo de projeto, um teste de escalonabilidade avalia a possibilidade de alguma tarefa perder o seu respectivo \deadline{}. Em tempo de execução, um escalonador preemptivo escolhe a tarefa em estado \textit{Pronto} de mais alta prioridade.

The \textsc{EDF} (\emph{Earliest-Deadline First})~\cite{Liu:1973} algorithm is a
real-time scheduling mechanism based on dynamic priorities and widely used in
the literature. \textsc{EDF} distributes the highest priorities to the tasks
with the shortest deadlines. At project-time a schedulability test evaluates the
possibility of any task lose its deadline. At execution-time a preemptive
scheduler selects to execute the highest priority task in \textit{READY} state.

%O modelo de tarefas para esse teste é: tarefas periódicas e independentes com o \deadline{} igual ao período.

%Um teste de escalonabilidade exato para o algoritmo \textsc{EDF} é apresentado a seguir. O sistema de tempo real considerado contém $n$ tarefas periódicas e independentes, {\Large $\tau$} = $\{\tau_0,\tau_1,...,\tau_{n-1}\}$. Cada $\tau_i$ é caracterizado por três parâmetros, $(P_i, D_i, C_i)$, onde, $P_i$ é o período em que a tarefa $i$ é escalonada, $D_i$ é o prazo (\emph{deadline}) máximo de conclusão relativo ao instante da liberação da tarefa $i$ e $C_i$ é o tempo de execução da tarefa $i$ no pior caso (incluído tempos de espera pela inversão de prioridades). Para este teste é suposto que $\forall\tau_i$, $D_i=P_i$ . A utilização $U_i$ de uma tarefa $i$ em termos de processamento é representada pela equação (\ref{eq:edf:u}).

An exact schedulability test of the \textsc{EDF} algorithm is presented below.
The real-time system considered contains $n$ periodic and independent tasks,
{\Large $\tau$} = $\{\tau_0,\tau_1,...,\tau_{n-1}\}$. Each $\tau_i$ is
characterized by three parameters, $(P_i, D_i, C_i)$, where $P_i$ is the period
in which the task $i$ is scheduled, $D_i$ is the max relative deadline of
conclusion in relation to instant of the task $i$ release and $C_i$ is the 
task $i$ execution time in the worst case which included times waiting by 
the priorities reversal.
In this test is supposed that $\forall\tau_i$, $D_i=P_i$ . The utilization $U_i$
of the task $i$ in processing terms is represented by equation (\ref{eq:edf:u}).


\begin{equation}
U_i = \frac{C_i}{D_i}
\label{eq:edf:u}
\end{equation}


%\[ U_i = \frac{C_i}{D_i} \]

%A capacidade de um processador é definida como 1, ou seja, 100\%. Um sistema com $\omega$ processadores possui capacidade $\omega$. Dessa forma, para as tarefas serem escalonáveis no algoritmo \textsc{EDF}, o somatório das utilizações de todas as tarefas deve ser menor ou igual a capacidade dos processadores, ou seja, 
The processor's capacity is set to 1, i.e., 100\%. A system with $\omega$
processors has $\omega$ capacity. Thus, in order to tasks to be schedulable 
in the \textsc{EDF} algorithm, the utilization sum of all the tasks must be less
than or equal to the processors' capacity, i.e.


\begin{equation}
\sum_{i=1}^n \left (\frac{C_i}{D_i} \right) \le \omega
\label{eq:edf:formalizacao}
\end{equation}

%\[ \sum_{i=1}^n \left (\frac{C_i}{D_i} \right) \le \omega \]

%onde $\omega = 1$ para um sistema com mono-processador. Caso $\sum_{i=1}^n U_i > \omega$, o processador estará sobrecarregado e as tarefas não são escalonáveis nesse algoritmo.

\noindent where $\omega = 1$ on a system with mono-processor. If $\sum_{i=1}^n U_i >
\omega$ , the processor will be overloaded and the tasks will not be
schedulable.  


%\input{figuras/teste.tex}

