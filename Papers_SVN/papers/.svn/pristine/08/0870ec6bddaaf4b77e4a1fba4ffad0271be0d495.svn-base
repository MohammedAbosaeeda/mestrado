	Tailor-made Operating Systems for Embedded Parallel Applications


	    Antônio Augusto Fröhlich & Wolfgang Schröder-Preikschat

		GMD FIRST		 University of Magdeburg
		Rudower Chaussee 5	 Universit\"atsplatz 2
		D-12489 Berlin, Germany	 D-39106 Magdeburg, Germany
		guto@first.gmd.de	 wosch@cs.uni-magdeburg.de


			Extended Abstract


	The boom of embedded systems in the recent years projects a near future replete of complex embedded applications, for instance navigation system and computer vision systems. Many of these applications demand performance levels that can only be achieved by parallelization  and therefore new operating systems and tools are to be conceived.

	Our experiences developing run time support systems for ordinary, i.e., non-embedded, parallel applications convinced us that adjectives such as "generic", "global" and "all purpose" do not fit together with "high performance", whereas different parallel applications have quite different requirements regarding operating systems. Even apparently flexible designs like micro-kernel based operating systems may imply in waste of resources that, otherwise, could be used by applications. The reality for embedded parallel applications can not be other and thus we should give each application its own operating system.

	The promotion of configurability has been properly addressed by the PURE operating system. PURE is designed as a collection of configurable system objects that can be saw as building-blocks to be put to together according to applications demands. In PURE, an application can get the operating system that exactly fulfills its requirements. Strategies like this, although doing much for performance, reusability and maintainability, usually are not enough to support application programmers, since, as the development of these systems advance, the number of available building-blocks grows quickly to reach hundreds or thousands, and, in such a situation, selecting and configuring the proper building-blocks becomes a nightmare. This gap between what the operating system offers and what the applications need can compromise the success of such strategies and are to be overcame.

	This paper proposes an innovative strategy to deal with this gap, both, by reducing the building-block collection  complexity and by automating the selection and configuration process. In this proposal, the application can be conceived in a more abstract and flexible way and then be submitted to a tool that will generated a tailored operating system to support its embedded parallel execution.



			Adapting System Objects


	As a tailorable operating system, PURE is designed to yield a large number of building-blocks, which in turn are to be put together to compose the tailor-made operating system. In order to achieve high performance, these building-blocks must be fine tuned to each of the execution scenarios aimed, therefore, a reasonable set of building-blocks will comprise a large number of elements. However, when we take a deeper look inside these building-blocks, we realize that those designed to present the same functionality in different scenarios are in deed very similar. We also realize that the differences often follow a pattern along members conceived to support the same scenario.

	In this way, we propose the system objects to be implemented as independent from the execution scenario as possible. They would then be put together with the aid of some sort of "glue" specific to each scenario. We named these "glue" scenario adapters, since they will adapt an existing system object to a certain scenario. These adapters are designed no to insert overhead on the path from applications to system objects.

	The approach of writing pieces of software that are independent from certain aspects and later adapting them to a give scenario has been referred to as Aspect Oriented Programming. However, there are significant differences in our proposal to make system objects adaptable. We are not proposing a language to describe aspects neither tools to automatically combine  aspects and aspect-independent components.  The problem we want to tackle is the complexity of the system objects repository, which will be reduced by isolating scenario dependencies in a separate software structure, the scenario adapters.



	    Automatically Generating  a Tailored Operating System


	Supposing we have a reasonable set of operating system building-blocks, the generation of the "best possible" operating system for a given parallel application that will execute in a given scenario could be carried out like following:

	1 - Let the application programmer select the system objects (he believes) he needs;
	2 - Let the application programmer describe the execution scenario for the application;
	3 - Resolve dependencies among the selected system objects and among them and the described scenario;
	4 - Compile (link) the just configured operating system.

	This step list, however, will not generate the "best possible" operating system because of one of the following: (a) the supposition that we have a reasonable set of system objects to select for is false and the application programmer will not find the system objects he is looking for; (b) the set of system objects is so complex that the application programmer gets confused and fail on selecting the proper objects or on describing the execution scenario. This frustrating situation becomes evident when the programmer realizes he has to moddify the application to adapt it to the so called "tailored operating system" or when he runs the application and can not see any benefit over using a standard operating system. This second remark is only not worst because, as far as we now, there are no standard operating systems, like Unix or Windows NT, to support embedded parallel applications.

	Our proposal to generate a tailored operating system starts top-down at the application. We believe the application programmer should be allowed to express his expectances regarding the operating system simply by writing down well-known system objects invocations (system calls in non object oriented systems) while coding the application. By well-know system objects invocations we mean that the operating system services will be made available to applications via objects commonly accepted by the parallel system community, such as threads, tasks, address spaces, channels, ports, etc.

	That is, during application design and implementation, the programmer will rely on a set of well-known system objects inflated interfaces. These interfaces are defined according to the fundamental law of object orientation that says: look at the real world while looking for objects. The question of where in the real world can one find a thread can be easily answered when we realize that threads are human conventions, just like numbers are, and that a couple of classical computer science books should comprise most widely accepted conventions.  Nevertheless, our users, i.e., embedded parallel application programmers, are welcomed to suggest modification or extensions for these interfaces.

	With these interfaces in hand, it should no longer be a problem for a skilled parallel application programmer to select how he wants to express process communication, thread synchronization or any other operating system service. An application conceived in this fashion can now be submitted to a tool that will extract a blueprint for the operating system to be generated. Actually, this tool has the solely task of identifying the system objects referred by the application and the methods invoked on them. The inflated interfaces described above are only used until this point. Each of the implicitly selected system objects can now be assembled using only the building-blocks that are really necessary to grant the functionality required by the invoked methods.


	Our primary operating system blueprint is, unfortunately, not complete. We got good hints about how the ideal operating system for a given application should look like, but there are aspects that can not be deduced by analyzing the application's source code. As an example, we could consider the decision of generating an operating system that supports multiple processes in protected address spaces based on a micro-kernel or an operating system for a single, possibly multi-threaded, process to be embedded on the application. The fact that the application's source does not show any syntactic evidence that multiple processes may need to run concurrently in a single processor, does not necessarily mean that this situation will not happen. The multi-task support may be required because the application may need to span more processes than the available number of processors, and this will not be perceivable until the user tell us something about the intended execution scenario. Other factors such as target architecture, number of processors available, network architecture and topology are fundamental to tailor a good operating system, but are usually not expressed inside the application. Therefore, we still need user intervention to describe the application's execution scenario, however, the description of the available resources will be due to the operating system developers and the interaction with the user will be done via visual tools. 

	Refining the blueprint obtained when analyzing the application's code with the context information acquired via this visual tool will render a precise description of how the ideal operating system for a given application should look like. This refined blueprint is still comprised of system objects interfaces to be satisfied, but those inflated interfaces we started with are now reduced to small, scenario specific ones. For example, the inflated thread interface from the first step may have included remote invocation and migration, but reached the final step as a simple single-task, priority scheduled thread for a certain microcontroller. This refined operating system blueprint can now be used to select the respective building-blocks from the repository.

	 It is important to understand that at the early stages of the operating system development, very often a required building-block will not yet be available. Even then, the proposed strategy is of great value, since the operating system developers got a precise description for the missing building-blocks. In many cases, a missing building-block will be quickly (automatically) adapted from another scenario using the scenario adapters described earlier.

	Only if the operating system developers are not able to deliver the requested building-blocks in a time considered acceptable by the user, either because a building-block with that functionality have not yet been implemented for any scenario or because the requested scenario is radically different from the currently supported scenarios, we will shock the user asking him to select the best option from the available set of system objects (scenario adapters) and to adapt his program. In this way, our strategy ends where most tailorable operating systems start. Moreover, after some development effort, the combination of scenario adapters and system objects shall satisfy the big majority of parallel embedded applications.

