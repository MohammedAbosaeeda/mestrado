/**(c)

  Copyright (C) 2005 Christian Wawersich

  This file is part of the KESO Operating System.

  It is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  Please contact wawi@cs.fau.de for more info.

  (c)**/

package keso.driver.tricore.tc1796b;

import keso.core.*;

/**
 * This class provides access to functions of the tricore PWR
 * module, also known as the System Control Unit (SCU) on
 * some variants.
 */
public final class TricorePWR {
	public static final int PWR_BASE=0xf0000000;
	public static final int PWRT_SIZE=62*4;
	public static final int PWR_OFS_PLLCLC=16*4;
	public static final int PWR_OFS_EICR=32*4;
	public static final int PWR_OFS_IGCR=37*4;

	public static final Memory pwr =
		MemoryService.allocStaticDeviceMemory(PWR_BASE, PWRT_SIZE);

	// TC1796.V101 quartz frequency is 20 MHz
	public final static int OSC_FREQ = 20000000;

	/**
	 * Unlock protected system registers by resetting the ENDINIT bit.
	 * Method is overwritten by an aspect that calls the corresponding OSEK
	 * function.
	 */
	public static void unlockSystemRegisters() { /* magic */ }

	/**
	 * Lock protected system registers by setting the ENDINIT bit.
	 * Method is overwritten by an aspect that calls the corresponding OSEK
	 * function.
	 */
	public static void lockSystemRegisters() { /* magic */ }

	/**
	 * Get the current system frequency
	 */
	public static int getSystemFrequency() {
			int frequency = getCPUFrequency();
			// CPU runs at double rate of the system clock when SYSFS bit is set 
			// to '0' (default setting)
			int pll_clc = pwr.get32(PWR_OFS_PLLCLC);
			int pllSYSFS = pll_clc & 0x00000004;	// [2] SYSFS
			if (pllSYSFS == 0)
					frequency /= 2;
			return frequency;
	}

	/**
	 * Get the current CPU frequency
	 */
	public static int getCPUFrequency() {
			int frequency = 0;
			int pll_clc = pwr.get32(PWR_OFS_PLLCLC); // read PLL_CLC register

			int pllBYPIN = pll_clc & 0x20000000; // [29] BYPIN
			if (pllBYPIN > 0) {
					// Direct Drive Mode (PLL Bypass)
					frequency = OSC_FREQ;
			} else {
					// BYPIN not set, system clock is generated by the PLL
					int kDiv = 1 + ((pll_clc & 0x00000F00) >> 8);
					int pDiv = 1 + ((pll_clc & 0x0000E000) >> 0xd);
					int nDiv = 1 + ((pll_clc & 0x007F0000) >> 0x10);
					frequency =  OSC_FREQ * nDiv / (kDiv * pDiv);
			}
			return frequency;
	}

	/**
	 * Set the CPU frequency to 150 MHz.
	 * This assumes that the oscillator is running at 20 MHz.
	 *
	 * The CPU frequency is calculated as
	 *  f = N/(K*P)
	 * in PLL mode.
	 * N in [20;100]
	 * P in [1;8]
	 * K in [1;16]
	 *
	 */
	public static void setCPUFrequency() {
		// Enable Write to PLLCLC
		unlockSystemRegisters();
		
		// activate VCO bypass (PLL_CLC.VCOBYP = 1)
		pwr.or32(PWR_OFS_PLLCLC, 0x20);
		// connect oscillator to PLL (PLL_CLC.OSCDISC = 0)
		pwr.and32(PWR_OFS_PLLCLC, ~0x01000000);
		// Configure VCO Range to 400MHz-500MHz (PLL_CLC.VCOSEL = 00)
		pwr.and32(PWR_OFS_PLLCLC, ~0xC0);

		// select PDIV (PLL_CLC.PDIV=0 => P=1)
		pwr.and32(PWR_OFS_PLLCLC, ~0xE000);

		// select NDIV (PLL_CLC.NDIV = 29 => N=30)
		pwr.and32(PWR_OFS_PLLCLC, ~0x7F0000);
		pwr.or32(PWR_OFS_PLLCLC, 29 << 16);

		// select KDIV (PLL_CLC.KDIV = 3 => K=4)
		pwr.and32(PWR_OFS_PLLCLC, ~0xF00);
		pwr.or32(PWR_OFS_PLLCLC, 3 << 8);

		// restart PLL lock detection
		pwr.or32(PWR_OFS_PLLCLC, 0x2);

		// wait for PLL lock
		int value;

		do {
			value = pwr.get32(PWR_OFS_PLLCLC);
		} while ((value & 1) ==0);

		// deactivate VCO bypass
		pwr.and32(PWR_OFS_PLLCLC, ~0x20);

		// disable write to PLLCLC
		lockSystemRegisters();
	}
}
