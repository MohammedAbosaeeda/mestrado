% ------------------------------------------------------------------------------
\section{DMEC} \label{dmec}
% + DMEC
% Describes the Distributed Motion Estimation Component (DMEC).
% Describes its parallelization Strategy (picture partition) as well the
% Coordinator-Worker model


% 1º parte independente de distribuído
% * Diagrama de classes: Interface PictureMotionEstimator                         (fig 3.1 relat tec): pme.dia
% Dizer que DMEC foi projetado seguindo os conceitos de ME.
% Engenharia de domínio da codificação de vídeo.
The Distributed Motion Estimation Component (DMEC) was developed following a
domain engineering process.
Before we explain how we have designed DMEC it is worth reviewing some
ME concepts from the domain of video encoding.
ME is a technique employed to explore the
similarity between neighboring pictures in a video sequence.
Figure \ref{fig:motion_estimation} illustrates the ME process for the neighboring
pictures \emph{A} and \emph{B}.
By searching for similarities between these two pictures, it is possible to determine
which blocks from picture \emph{A} are also found in picture \emph{B}.
Such displacement of picture blocks is encoded by \emph{motion vectors} 
(represented by the small arrows in the bottom side of
Figure \ref{fig:motion_estimation}).
Exploring the similarity between neighboring pictures allows for difference-based
encoding, thus increasing the compression rate of the generated 
bitstream \cite{citeulike:1269699}.

\fig{.4}{motion_estimation}{Motion Estimation}

Taking into consideration the concepts encompassed by the ME technique, we have
designed DMEC.
The central element of DMEC is described by the interface 
\emph{PictureMotionEstimator} shown by Figure \ref{fig:pme}.
Such interface describes entities that are responsible to perform ME of a whole
picture (or a partition of a picture).
An object of the type \emph{PictureMotionEstimator} knows all block modes of
the video standard in use (e.g. H.264), and works according to a specific
error metric, such as the Sum of Absolute Differences (SAD).
Such error metric is used to determine the similarity between neighboring
pictures.
The ME itself is computed by the \emph{match} method that takes the
current and the reference pictures
(respectively pictures \emph{A} and \emph{B} from Figure \ref{fig:motion_estimation})
and returns their ``counterpart'' which is composed by the motion vectors
and the motion cost.



% * Diagrama de classes: Retorno do match                                         (fig 3.2 relat tec): pmc.dia
% Dizer que retorna "tudo" é um componente bem auto contido.
DMEC was designed to be self contained, thus, the \emph{match} method computes ME
for all picture's macroblocks and for all block modes without any dependency
from another encoder element.
Therefore, the return of the method \emph{match}, which is conceptually shown
by Figure \ref{fig:pmc} is a multidimensional vector containing all motion
vectors and costs for each macroblock and block mode used in the ME.

\subsection{Parallelization Strategy}
% // DMEC: Parallelization Strategy //
% 2º parte distribuída
% * Figura particionamentos: todos os 6.                                          (TODO): picture_partition.XXX
% com ou sem o foreman. Pode ser sem, apenas retângulos.
% 
% * Figura threads/"atores" coordinator e workers                                 (from fig.git): dmec_thread_model-en.dia
% 
% * Diagrama de classes: módulos coordinator e workers                            (fig 3.4 relat tec): cnw.dia
% Motrar que vários algoritmos podem ser utilizados.


The parallelization strategy employed by DMEC is based on data partitioning,
in which the unit to be partitioned is the picture.
Figure \ref{fig:picture_partition} shows all picture partition modes available.
% It is worthy to mention that as all picture partitions dimensions must be 
% multiple to the macroblock dimension (16x16 pixels), it can occur having 
% partitions with distinct dimensions.
All picture partitions dimensions must be multiple to the macroblock dimension 
(16x16 pixels) to avoid having a macroblock broken between to neighboring
partitions.
If desired, it is possible to include new partition modes by specifying how the
partition should be performed.

% Fig showing all partitions types.
\fig{.2}{picture_partition}{Supported picture partitions modes}
% SINGLE_PARTITION = 1, 
% |0|
% 
% ONExTWO_PARTITION = 2,     
% |0|
% |1|
% 
% THREExONE_PARTITION = 3,
% |0|1|2|
% 
% TWOxTWO_PARTITION = 4,
% |0|1|
% |2|3|
% 
% THREE_TWOxTWO_PARTITION = 5,
% |0|1|2|
% |3 | 4|
% 
% THREExTWO_PARTITION = 6
% |0|1|2|
% |3|4|5|
% 

\fig{.4}{workers_and_bma}{Worker and Block Matching Algorithm}

In order to improve the performance of ME, each picture partition is then 
assigned to a \emph{Worker} module which executes in a specific functional unit,
such as a core of a multicore processor or a dedicated hardware element.
There is also a \emph{Coordinator} module, responsible to define the 
picture partition for each \emph{Worker} and to provide them with 
pictures to be processed.
The \emph{Coordinator} is also responsible to gather results generated by
\emph{Workers} (motion cost and motion vectors) and to deliver these results
back to the encoder. 
Figure \ref{fig:dmec_thread_model-en} illustrates the interaction
between the \emph{Coordinator} and \emph{Worker} modules.

\figtwocolumn{.4}{pme}{\emph{PictureMotionEstimator} interface}

% + Algoritmo
Each \emph{Worker} module computes ME by using a Block Matching Algorithm (BMA),
which itself also implements the \emph{PictureMotionEstimator} interface.
Thus, as shown by Figure \ref{fig:workers_and_bma}, all BMAs follow a single interface
therefore, it is possible to replace a BMA for another, according to the encoder
needs.

\subsection{Data Transference and Synchronization}
% // DMEC: Data Transference and Synchronization //
% * Diagrama de classes: TransferenceManager e SynchronizationManager             (TODO): dmec_trans_and_synch.dia
% Talvez seja um diagrama de sequencia até.
% 
% Mostrando como a transferencia de dados e sincronização são feitas.
% 
% É, diagrama de seq é bom.
% 
% Coordinator prepara pictures.
% Usa SynchronizationManager para Avisar que elas estão prontas (posso chamar de Barrier)
% Workers usam Transference Manager para obter as Pictures.
% Calculam ME e usar Transference Manager para divulgar os resultados
% Avisam Coordinator usando SynchronizationManager que o trabalho está pronto.
% 
% É meio um repeteco da figura thread model, mas é interessante para mostrar as
% interfaces de TransferenceManager e SynchronizationManager que serão implementadas
% pelo CELL, PC e Hardware...
The memory model used to exchange data between \emph{Coordinator} and
\emph{Worker} modules is a kind of shared memory, although, in practice, such
memory can be implemented as a memory block in a single address space 
(as is the case for our implementation for the IA32 architecture and
dedicated hardware), or
can be constituted by multiple memory blocks, each one using its own address
space
(as is the case for our implementation for the Cell BE architecture).

Figure \ref{fig:dmec_trans_and_synch} details the interaction between 
\emph{Coordinator} and \emph{Worker} modules.
At the beginning of the ME operation DMEC assumes that all pictures are in the
main memory.
Using the \emph{TransferenceManager} interface, \emph{Worker} modules can
obtain the samples of their picture partitions.
In the case of a memory block in a single address space, the operations of
\emph{TransferenceManager} are just pointer manipulations.
On the other hand, while using memory blocks in distinct address spaces, the
operations of \emph{TransferenceManager} are mapped to real 
memory transferences, such as Direct Memory Access (DMA) requisitions.
Also, by using the \emph{TransferenceManager}, \emph{Worker} modules 
can publish the computed motion vectors and motion costs.
% 
\emph{Worker} modules should wait for a signal from the \emph{Coordinator}
module indicating that there are pictures to the processed.
Similarly, the \emph{Coordinator} module should wait for the ME results 
generated by the \emph{Worker} modules.
Such synchronization operations are implemented by the 
\emph{SynchronizationManager} interface, which specifies barrier-like
mechanisms, which can be implemented using operating system operations or using
directly dedicated hardware elements.
In the case of a sequential operation with a single partition containing the
whole picture, the operations of \emph{SynchronizationManager} are canceled. 


% ------------------------------------------------------------------------------
% 
% Some notes
% DMEC Interfaces:
% 
% \emph{PictureMotionEstimator}
% 
% \emph{TransferenceManager}
% 
% \emph{SynchronizationManager}
% 
% 
% \emph{Coordinator} implements \emph{PictureMotionEstimator}
% 
% \emph{Worker} kind of implements \emph{PictureMotionEstimator}.
% The interface is other but it also performs match.
% The \emph{Worker} interface has a entry point ``run'', a match method,
% and some methods to gather the pictures and put the pictures back.
% 
% A \emph{Worker} uses the interfaces
% \emph{TransferenceManager} and \emph{SynchronizationManager}
