\documentclass[runningheads]{llncs}
\input{psfig.sty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinelanguage{XML} {
  keywords={xml,version,DOCTYPE,SYSTEM,EPOSConfig,family,member,name,type,
  default,pos,pre}}
\lstdefinestyle{prg} {basicstyle=\small\sffamily, lineskip=-0.2ex}
\lstdefinestyle{prgbox} {basicstyle=\small\sffamily lineskip=-0.2ex}
\lstdefinestyle{inlineprg} {basicstyle=\small\sffamily}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{headings}


\mainmatter                        
\title{Hardware Mediators: A Portability Artifact\\for Component-based Systems}
\titlerunning{Hardware Mediators}  

\author{Fauze Val\'erio Polpeta\inst{1} \and 
        Ant\^onio Augusto Fr\"ohlich\inst{1}}

\authorrunning{Fauze Val\'erio Polpeta et al.}

\institute{Federal University of Santa Catarina, PO Box 476\\
           88049-900, Florianópolis - SC, Brazil\\
\email{\{fauze,guto\}@lisha.ufsc.br},\\ 
\texttt{http://www.lisha.ufsc.br}}

\maketitle                         

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}

  In this article we elaborate on portability in component-based
  operating systems, focusing in the \emph{hardware mediator} construct
  proposed by Fröhlich in the \emph{Application-Oriented System Design}
  method.  Differently from hardware abstraction layers and virtual
  machines, hardware mediators have the ability to establish an
  interface contract between the hardware and the operating system
  components and yet incur in very little overhead.
  
  The use of hardware mediators in the \textsc{Epos} system corroborates
  the portability claims associated to the techniques explained in this
  article, for it enabled \textsc{Epos} to be easily ported across very
  distinct architectures, such as the \texttt{H8} and the
  \texttt{IA-32}, without any modification in its software components.

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

  Portability has always been a matter for operating system
  developers, because the very own nature of an operating system has
  to do with abstracting hardware components in a way that is suitable
  for application programmers to develop ``architecture-independent
  software''. It is expected that an application developed on top of a
  chosen operating system will run unmodified in all architectures
  supported by that operating system. Therefore, operating systems
  constitute one of the main pillars of applicative software
  portability.

  Traditional approaches to make the operating system itself portable
  are mainly concentrated in two flanks: \emph{Virtual Machines}~(VM)
  and \emph{Hardware Abstraction Layers}~(HAL). While considering the
  virtual machine approach to operating system portability, one cannot
  forget that the virtual machine itself is part of the operating
  system---according to Habermann, the operating system extends from
  the hardware to the application~\cite{Habermann:1976}. The virtual
  machine would thus constitute the architecture-dependent portion of
  the operating system, while granting portability for the components
  above. The main deficiencies of this approach is the overhead of
  translating VM operations into native code. Several ``JAVA operating
  systems'' rely on this approach to achieve portability.

  A second major alternative for operating system portability is based
  in hardware abstraction layers, which constitute an
  architecture-dependent substratum for the development of system
  software. A HAL encapsulate hardware-specific details under a
  software-oriented interface. Although usually considered not to
  incur in as much overhead as virtual machines, hardware abstraction
  layers must rely on refined implementation techniques to achieve
  good performance.

  One additional shortcoming of both approaches arises from design.
  Without a proper domain engineering strategy, it's very likely that
  VMs and HALs will incorporate architectural details of the initial
  target architecture(s), making it difficult to adapt them to other
  architectures.  That's probably the reason why ordinary all-purpose
  operating systems designed around a complex memory management
  system, such as \textsc{Unix} and \textsc{Windows}, look like a
  Frankstein when ported to 8-bit architectures.

  Domain engineering methodologies that drive the design process
  toward collections of reusable software components are largely used
  in the realm of applicative software. Recently, strategies to
  develop component-based operating systems begun to
  appear~\cite{Baum:1999,Constantinides:2000,Froehlich:2001} and are
  producing exciting new operating systems such as
  \textsc{Epos}~\cite{Froehlich:sbac:1999} and
  \textsc{Pure}~\cite{Schoen:1998}.  Being fruit of a domain
  engineering process (instead of a system engineering process), the
  software components of such systems can be arranged to build a large
  variety of run-time support systems. More specifically, the
  \emph{Application-Oriented System Design}~(AOSD) method proposed by
  Fröhlich~\cite{Froehlich:2001} combines principles of
  \emph{Object-Oriented Design}~(OOD)~\cite{Booch:1994} with
  \emph{Aspect-Oriented Programming}~(AOP)~\cite{Kiczales:1997} and
  \emph{Static Metaprogramming}~(SMP)~\cite{Czarnecki:2000} in a
  method that guides the development of highly adaptable software
  components for the operating systems domain.

  This new class of application-oriented operating systems has the
  same need for portability as their more conventional relatives,
  however, the combination of \textsc{AOP} and \textsc{SMP} brings
  about new opportunities to implement VMs and HALs: \emph{hardware
  mediators}. A hardware mediator is a software artifact that
  encapsulates a hardware component in a construct whose interface has
  been defined in the context of operating systems. This concept
  resembles HAL elements, but the use of \textsc{AOP} and \textsc{SMP}
  enables hardware mediators to be far more flexible and yet present
  better performance than traditional HALs.

  This paper discusses the use of AOSD's hardware mediators as a
  powerful operating system portability tool. After presenting a
  parallel of the techniques commonly used in the realm of operating
  systems to achieve portability, the hardware mediator concept is
  explained in details, followed by a case study of its deployment in
  the \textsc{Epos} project.  The paper is closed with a discussion of
  related works and author's perspectives.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Portability in Ordinary Operating Systems}

  Operating systems, as discussed in the introduction of this paper,
  are one of the main artifacts to promote applicative software
  portability, as they hide architectural dependencies behind
  standardized interfaces such as \textsc{Posix}. A properly designed
  operating system enables applications to endure the quick evolution
  of computer hardware without major impact.  Consequently, being able
  to quickly port an operating system to a new hardware platform
  became an strategic issue for the software industry.

  Yet in the 70's, the \textsc{VM/370}\footnote{The technical
  literature often refers to \textsc{IBM}'s \textsc{VM/370} as
  \textsc{CP/CMS}.}  operating system from
  \textsc{IBM}~\cite{Case:1978} was strongly concerned with
  portability. In order to enable batch applications developed for
  older systems to execute in the new environment, \textsc{IBM} opted
  for introducing multitasking in the \textsc{VM/370} by means of a
  virtual machine scheme that delivered each application a duplicate
  of the real hardware. Nevertheless, since most of the virtual machine
  instructions were indeed real machine instructions executed, this
  approach prevented the system from being ported to other
  architectures.

  The concept of virtual machine, however, goes far beyond the scheme
  introduced by \textsc{VM/370}. As a matter of fact, any software
  layer aimed at extending the functionality, or raising the
  abstraction level, of a computer system can be taken as a
  \emph{virtual machine}~\cite{Wirth:1992}. That thinking could lead
  us to conclude that the simple choice of an universal programming
  language---such as \textsc{C}, for which numerous cross-compilers
  are available---to implement the operating system could respond for
  all portability matters. This is definitely not true: first, because
  high-level programming languages do not feature all the operations
  needed by the operating system to interact with the hardware,
  forcing system programmers to write native code
  (e.g. \emph{assembly}) that cannot be automatically translated to
  new architectures; second, because device drivers are usually very
  platform-specific and cannot be automatically converted too.

  Even if programming languages alone cannot be accounted for
  operating system portability, they are a crucial means. By taking on
  a portable programming language and gathering all
  architecture-dependent code in a self-contained \emph{hardware
  abstraction layer}, operating system engineers have an option for
  developing portable systems. The original
  \textsc{Unix}~\cite{Thompson:1974} from \textsc{AT\&T Bell Labs} was
  one of the first operating systems to use this approach. As
  described by Miller~\cite{Miller:1978}, porting \textsc{Unix} from
  the \textsc{PDP} to the \textsc{Interdata} was a straightforward
  activity mostly concentrated on the \textsc{HAL}
  implementation. This strategy for portability is nowadays adopted by
  many operating system, including \textsc{Unix} descendants and also
  \textsc{Windows}.

  Recent advances in both approaches are well represented by
  \textsc{Java VM} on the side of virtual machines and by
  \textsc{Exokernel} on the side of hardware abstraction layers. On
  the one hand, systems like the \textsc{JavaOS}~\cite{Madany:1996},
  developed by Sun Microsystems, have promoted the \textsc{Java VM} as
  an attractive system portability tool but, not differently from
  other \textsc{VM}-based systems, the \textsc{VM} must be
  reimplemented for every new platform. On the other hand,
  \textsc{Exokernel}~\cite{Engler:1995} eliminated the notion of
  abstractions from the operating system kernel. However, the
  diversity of devices in each hardware platform imposes severe
  restriction on the definition of interfaces for the
  \textsc{Exokernel}, and therefore compromising its
  portability~\cite{Kaashoek:1997}.

  Nevertheless, both approaches, HALs and VMs, are becoming too
  restricted to match contemporary software engineering techniques. As
  a matter of fact, the design of traditional portability artifacts
  like HALs and VMs is usually driven by the necessity of making the
  resources available in a given hardware platform to a given
  operating system. However, binding the design process to a
  preexisting hardware platform or operating system makes room for
  unnecessary dependencies that most likely will restrain both, reuse
  and portability. In order to understand how such dependencies grow
  up in the system, let us consider the well-know memory management
  scheme~\cite{Bach:1987} used by \textsc{Unix}. The \texttt{brk}
  system-call in \textsc{Unix} can be used by ordinary processes to
  modify the size of its data segment. More notoriously, it is used by
  \texttt{libc}'s \texttt{malloc} an \texttt{free} functions to manage
  a process' heap. The implementation of this system-call presupposes
  a paging memory management strategy supported by an
  \textsc{MMU}. Indeed, implementing \texttt{brk} without an
  \textsc{MMU} is unpractical, for it would imply in dynamic process
  relocation. Consequently, \textsc{Unix}'s \textsc{HAL} includes a
  paging engine abstraction. This design seems reasonable for a
  multitasking operating system, but it severely compromises its
  portability to a platform that does not feature a
  \textsc{MMU}\footnote{A more careful design, that eliminates this
  dependency, will be presented in section~\ref{sec:epos}.}.

  Eliminating architectural dependencies of this kind, that extend
  through the system from \textsc{HAL} to \textsc{API}, is fundamental
  for systems compromised with portability and reusability. In
  particular, the embedded system realm, which today accounts for 98\%
  of the processors in the market~\cite{Tennenhouse:2000}, cannot go
  with restrictions like this. Moreover, embedded systems often
  operate on restricted resources and monolithic \textsc{VM}s and
  \textsc{HAL}s are likely to overwhelm the system. In this scenario,
  a component-based \textsc{HAL} whose components can be selected and
  adapted according to application's demands is certainly a better
  choice. The next section introduces a novel strategy to achieve
  portability in component-based run-time support systems.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Hardware Mediators: a Portability Artifact for Component-based Operating Systems}

  \emph{Hardware mediators} have been proposed by Fröhlich in the
  context of \emph{Application-Oriented System
  Design}~\cite{Froehlich:2001} as software constructs that mediate
  the interaction between operating system components, called
  \emph{system abstractions}, and hardware components.  The main idea
  behind hardware mediators is not building universal hardware
  abstraction layers and virtual machines, but sustaining the
  \emph{``interface contract''} between system and machine.

  Differently from ordinary \textsc{HAL}s, hardware mediators do not
  build a monolithic layer encapsulating the resources available in
  the hardware platform. Each hardware component is mediated via its
  own mediator, thus granting the portability of abstractions that use
  it without creating unnecessary dependencies. Indeed, hardware
  mediators are intended to be mostly metaprogrammed and therefore
  dissolve themselves in the abstractions as soon as the interface
  contract is met. 

  Like abstractions in \emph{Application-Oriented System Design},
  hardware mediators are organized in families whose members represent
  the significant entities in the domain
  (figure~\ref{fig:family}). For instance, a family of \texttt{CPU}
  mediators would feature members such as \texttt{ARM}, \texttt{AVR8},
  and \texttt{PPC}. Non-functional aspects and cross-cutting
  properties are factored out as \emph{scenario aspects} that can be
  applied to family members as required. For instance, families like
  \texttt{UART} and \texttt{Ethernet} must often operate in
  exclusive-access mode. This could be achieved by applying a
  share-control aspect to the families.

\begin{figure}
  \centerline{\psfig{figure=fig/family.eps}}
  \caption{A family of hardware mediators}
  \label{fig:family}
\end{figure}

  Another important element of hardware mediators are
  \emph{configurable features}, which designate features of mediators
  that can be switched on and off according to the requirements
  dictated by abstractions.  A configurable feature is not restricted
  to a flag indicating whether a preexisting hardware feature must be
  activated or not. Usually, it also incorporates a \emph{Generic
  Programmed}~\cite{Musser:1989} implementation of the algorithms and
  data structures that are necessary to implement that feature when
  the hardware itself does not provide it. An example of configurable
  feature is the generation of CRC codes in an \texttt{Ethernet}
  mediator.

  The use of \emph{Static Metaprogramming} and \emph{Aspect-Oriented
  Programming} techniques to implement hardware mediators confer them
  a significant advantage over the classic approaches of VMs and
  HALs. From the definition of the scenario in which the mediator will
  be deployed, it is possible to adapt it to perform accordingly
  without compromising its interface nor aggregating useless code.

  As regards the implementation of hardware mediators, the
  \textsc{C++} programming language provides powerful static
  metaprogramming constructs such as parametrized classes and
  functions (\texttt{templates}) and constant expression
  resolution. Hardware mediators could thus be implemented as
  parameterized classes whose methods are declared \texttt{inline} and
  defined with embedded assembly instructions. In this way, hardware
  mediators can even avoid the overhead of function calls, thus
  maximizing performance\footnote{The optimizations performed by some
  \textsc{C++} compilers will often lead to code the is more efficient
  than the ``hand-written'' equivalent.}. Figure~\ref{prg:tsc}
  illustrates the case with the implementation of the \texttt{IA-32}
  \texttt{CPU} mediator's method \texttt{tsc}, which returns the
  current value of the \textsc{CPU}'s time-stamp counter. Invoking
  that method as in \\
\vspace{\parskip}
\noindent\makebox[\textwidth][c]{
  \begin{lstlisting}[language=C++,style=inlineprg]{}
      ^^J register unsigned long long tsc = IA32::tsc();
  \end{lstlisting}}
\vspace{0.25\parskip}
  would produce a single machine instruction: \texttt{rdtsc}.

\begin{figure}
    \vspace{\parskip}
    \framebox[\textwidth][c]{
      \lstinputlisting[language=C++,style=prg,
                       basicstyle=\fontfamily{pcr}\fontseries{m}\selectfont\footnotesize
                      ]{prg/tsc.prg}}
    \vspace{0.25\parskip}
    \caption{A fragment of the \texttt{IA-32} \textsc{CPU} hardware mediator.}
    \label{prg:tsc}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Hardware Mediators in EPOS: a Case Study}
\label{sec:epos}

  The Embedded Parallel Operating System~(\textsc{Epos}) aims at
  delivering adequate run-time support for dedicated computing
  applications.  In order to match its goal, \textsc{Epos} relies on
  the \emph{Application-Oriented System Design} method to guide the
  development of families of software components, each of which
  implements a scenario-independent abstraction that can later be
  adapted to a given execution scenario with the aid of scenario
  adapters.  Software components are collected in a repository and are
  exported to the application programmers via inflated interfaces,
  which hide the peculiarities of each member in a family as though
  the whole family were a component. This strategy, besides
  drastically reducing the number of exported abstractions, enables
  programmers to easily express their application's requirements
  regarding the operating system.

  In order to preserve the portability of its software components,
  \textsc{Epos} relies on hardware mediators. In principle, none of
  \textsc{Epos} abstractions interact directly with the hardware,
  utilizing the corresponding hardware mediators instead. A
  substantial example can be found in \textsc{Epos}'s memory
  management components. All portable operating systems are challenged
  by the fact that some computing platforms feature sophisticated
  memory management units (\textsc{MMU}) while others do not provide
  any means to map and protect address spaces. For most operating
  system, this is an unbreakable barrier that forces them to either be
  portable across platforms that feature an specific kind of
  \textsc{MMU} (.e.g paging) or portable across platforms without
  memory management hardware. A careful design of abstractions and
  mediators enabled \textsc{Epos}'s memory management components to be
  ported across virtually any platform, including rudimentary
  microcontrollers such as the \textsc{H8} and the \textsc{AVR8} along
  with powerful microprocessors such as the \textsc{IA-32} and the
  \textsc{PowerPC}.

  The main design decision to enable \textsc{Epos}'s memory management
  system to be highly portable was the encapsulation of details
  pertaining address space protection and translation, as well as
  memory allocation, inside the \texttt{MMU} family of hardware
  mediators. \textsc{Epos} features an \texttt{Address\_Space}
  abstraction, which is a kind of container for chunks of physical
  memory called \emph{segments}. It does not implement any protection,
  translation or allocation duties, handling them over the
  \texttt{MMU} mediator. A particular member of the
  \texttt{Address\_Space} family, called \texttt{Flat\_AS}, defines a
  memory model in which logical and physical addresses do match, thus
  eliminating the need for a real \textsc{MMU}.  This model ensures
  the preservation of the interface contract between other components
  and the memory subsystem in platforms that do not feature an
  \textsc{MMU}. This design is depicted in figure~\ref{fig:memory},
  which additionally illustrates the message flow for a segment
  creation (1 and 2) and attachment (3 and 4).

\begin{figure}
  \centerline{\psfig{figure=fig/memory.eps}}
  \caption{Memory manager components in \textsc{Epos}.}
  \label{fig:memory}
\end{figure}

  The \texttt{MMU} mediator for a platform that does not feature the
  corresponding hardware components is a rather simple artifact, since
  its deployment implies in the \texttt{Flat\_AS}
  abstraction\footnote{Deployment rules are used in \textsc{Epos} to
  specify dependencies among components and particular requirements of
  individual components without generating any extra code.}. Methods
  concerning the attachment of memory segments into the single, flat
  address space become empty, with segments being ``attached'' at
  their physical addresses. Methods concerning memory allocation
  operate on words in a way that is similar to \texttt{libc}'s
  traditional \texttt{malloc} function.  That variability across the
  members of a family of mediators do not affect the interface
  contract of the family. Conceptually the memory model defined by the
  \texttt{Flat\_AS} can be viewed as a degeneration of the paged
  memory model in which the page size equals the size of a memory word
  and the page tables implicitly map physical addresses as logical
  ones.

  An additional phenomenon typical of low-level programming regards
  the mediation of a same hardware device in different architectures.
  For example, suppose that a given device is part of two hardware
  platforms, one that uses programmed I/O and another that uses memory
  mapped I/O.  Being the same \textsc{UART} it is very likely that the
  procedures used to interact with the device in both platforms would
  be the same, thus turning the corresponding device driver into a
  portable component.  Nevertheless, the different I/O access modes
  will probably drive traditional operating system into setting up two
  distinct, non-portable device drivers.  A metaprogrammed hardware
  mediator can solve this kind of problem by introducing an
  \texttt{IO\_Register} abstraction that is resolved to one of the
  possible access modes at compile-time. An outline of such
  abstraction is presented in figure~\ref{prg:io_reg}.

\begin{figure}
    \vspace{\parskip}
    \framebox[\textwidth][c]{
      \lstinputlisting[language=C++,style=prg,
                       basicstyle=\fontfamily{pcr}\fontseries{m}\selectfont\footnotesize
                      ]{prg/io_reg.prg}}
    \vspace{0.25\parskip}
    \caption{The metaprogrammed \texttt{IO\_Register} construct.}
    \label{prg:io_reg}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Sample system instances}

  In order to illustrate portability achieved trought hardware
  mediators, a same configuration of the \textsc{Epos} system was
  instantiated for three very distinct architectures: \textsc{IA-32},
  \textsc{H8} and \textsc{PPC32}. This configuration included support
  for a single task with multiple threads in a cooperative
  environment. Dynamic memory allocation was also made available to
  application threads. Table~\ref{tab:images} shows the size (in
  bytes) of the segments relative to each generated image.

\begin{table}   
  \begin{center}
    \begin{tabular}{|l|r|r|r|r|}
      \hline
      \multicolumn{1}{|c|}{\textbf{Arch} } & 
      \multicolumn{1}{|c|}{\textbf{.text}} & 
      \multicolumn{1}{|c|}{\textbf{.data}} &
      \multicolumn{1}{|c|}{\textbf{.bss} } & 
      \multicolumn{1}{|c|}{\textbf{total}} \\
      \hline
      \textsc{IA-32} & 926 & 4 & 64 & 994 \\
      \hline
      \textsc{H8} & 644 & 2 & 22 & 668 \\
      \hline
      \textsc{PPC32} & 1,692 & 4 & 56 & 1,752 \\
      \hline
    \end{tabular}
  \end{center}
  \caption{The size (in bytes) of \textsc{Epos} images for three 
           architectures.\label{tab:images}}
\end{table}

  The figures shown in table~\ref{tab:images} illustrates system
  adequacy as a run-time support system for embedded applications. All
  three instances were generate from absolutely the same software
  components (abstractions), but using particular hardware mediators.
  The different sizes of the segments are originated basically from
  the different instruction formats and word sizes of the
  architectures.

  Perhaps a more significant analysis would have been a ration between
  portable (abstractions, aspects and framework glue) and non-portable
  (hardware mediators) system pieces, thus yielding the degree of
  portability imputed to the system by the techniques introduced.
  However, the deployment of \emph{Static Metaprogramming} in hardware
  mediators causes them to dissolve in the system code, so that object
  code analysis becomes meaningless. Counting the number of source
  code lines would also lead us towards incorrect figures, since a
  good fraction of a hardware mediator source code is dedicated to the
  interaction with other metaprograms and abstractions, and generates
  no object code. At least at this moment, the degree of portability
  must be inferred from easiness to port component-based systems
  across such different architectures as the \texttt{IA-32},
  \texttt{H8} and \texttt{PPC32}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusions and Future Work}

  In this article we conjectured about portability in component-based
  operating systems, focusing in the \emph{hardware mediator}
  construct proposed by Fröhlich in the \emph{Application-Oriented
  System Design}~\cite{Froehlich:2001}. Differently from hardware
  abstraction layers and virtual machines, hardware mediators have the
  ability to establish an interface contract between the hardware and
  the operating system components and yet generate virtually no
  overhead.

  The use of hardware mediators in the \texttt{Epos} system
  corroborates the portability claims associated to the techniques
  explained in this article, for it enabled \textsc{Epos} to be easily
  ported across very distinct architectures without any modification
  in its software components. Indeed, the results obtained were so
  positive that we decided to setup a project to evaluate the
  possibilities of using hardware mediators as a software-hardware
  co-design tool, extending the concept of hardware/operating system
  interface to a level that would enable hardware generation. Besides
  featuring hardware mediators for traditional hardware components, we
  could also define mediators that would embed hardware descriptions,
  for instance written in \textsc{VHDL} or \textsc{Verilog}. Such
  hardware mediators, when instantiated, would give rise not only to a
  system-hardware interface, but to the hardware itself.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{}

\bibitem{Bach:1987}
Bach, M. J.:
The Design of the UNIX Operating System.
Prentice-Hall, 1987.

\bibitem{Baum:1999}
Baum, L.:
Towards Generating Customized Run-time Platforms from Generic Components.
In Proceedings of the 11th Conference on Advanced Systems Engineering, 
Heidelberg, Germany, June 1999.

\bibitem{Booch:1994}
Booch G.:
Object-Oriented Analysis and Design with Applications.
Addison-Wesley, 2 edition, 1994.

\bibitem{Constantinides:2000}
Constantinides, C. A., Bader, A.,  Elrad, T. H., Netinant, P., and Fayad, M. E.:
Designing an Aspect-Oriented Framework in an Object-Oriented Environment.
ACM Computing Surveys, 32(1), March 2000.

\bibitem{Czarnecki:2000}
Czarnecki, K., Eisenecker, U.:
Generative Programming: Methods, Tools, and Applications.
Addison-Wesley, 2000.

\bibitem{Case:1978}
Case, R. P., and Padegs, A.:
Architecture of the IBM system/370.
In Communications of the ACM, Volume 21, Issue 1, January 1978.

\bibitem{Engler:1995}
Engler, D. R., Kaashoek, M. F., and O'Toole, J.:
Exokernel: An Operating System Architecture for Application-level Resource Management.
In Proceedings of the Fifteenth ACM Symposium on Operating Systems Principles, 
pages 251--266, Copper Mountain Resort, U.S.A., December 1995.

\bibitem{Froehlich:2001}
Fröhlich, A. A.:
Application-Oriented Operating Systems.
Number 17 in GMD Research Series. GMD - Forschungszentrum Informationstechnik, 
Sankt Augustin, August 2001.

\bibitem{Froehlich:sbac:1999}
Fröhlich, A. A., and Schröder-Preikschat, W.:
High Performance Application-oriented Operating Systems -- the EPOS Aproach.
In Proceedings of the 11th Symposium on Computer Architecture and High Performance Computing, 
pages 3--9, Brazil, 1999.

\bibitem{Habermann:1976}
Habermann, A. N., Flon, L., and Cooprider, L. W.:
Modularization and Hierarchy in a Family of Operating Systems.
Communications of the ACM, 19(5):266--272, 1976.

\bibitem{Kaashoek:1997}
Kaashoek, M., Engler, D., Ganger, G., Brice H., Hunt, R., Mazières, D., 
Pinckney, T., Grimm, R., Jannotti, G., and Mackenzie, K.:
Application Performance and Flexibility on Exokernel Systems.
In Proceedings of the 16th ACM Symposium on Operating Systems Principles, 
Saint Malo, France, October 1997.

\bibitem{Kiczales:1997}
Kiczales, G., Lamping, J., Mendhekar, A., Maeda, C., Lopes, C.V., Loingtier, J., and Irwin, J.:
{Aspect-Oriented Programming}.
In Proceedings of the European Conference on Object-oriented Programming'97, 
volume 1241 of {\em Lecture Notes in Computer Science},
pages 220--242, Jyväskylä, Finland, June 1997. Springer.

\bibitem{Madany:1996}
Madany, P. W.:
JavaOS: A Standalone Java Environment.
Sun Microsystems White Paper, May 1996.
URL: ftp://ftp.javasoft.com/docs/papers/JavaOS.cover.ps

\bibitem{Miller:1978}
Miller, R.:
UNIX - A Portable Operating System?
OSR, Vol. 12, No. 3, July 1978, pages 32-37.

\bibitem{Musser:1989}
Musser, D. R., and Stepanov, A. A.:
{Generic Programming}.
In Proceedings of the First International Joint Conference of ISSAC and AAECC, 
number 358 in Lecture Notes in Computer Science, 
pages 13--25, Rome, Italy, July 1989. Springer.

\bibitem{Schoen:1998}
Schön, F., Schröder-Preikschat, W., Spinczyk, O., and Spinczyk, U.:
Design Rationale of the PURE Object-Oriented Embedded Operating
System. In Proceedings of the International IFIP WG 10.3/WG 10.5,
Paderborn, Germany, October 1998.

\bibitem{Tennenhouse:2000}
Tennenhouse, D.:
Proactive Computing.
Communications of the ACM, 43(5):43--50, May 2000.

\bibitem{Thompson:1974}
Thompson K., and Ritchie, D. M.:
The UNIX Timesharing System.
Communications of the ACM, 17(7):365--375, 1974.

\bibitem{Wirth:1992}
Wirth, N., and Gutknecht, J.:
Project Oberon - The Design of an Operating System and Compiler.
Addison-Wesley, Reading, U.S.A., 1992.

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
