% ------------------------------------------------------------------------------
% NOTA TODO: Revisar / Reescrever esta subseção: Temperature Sensing
\subsection{Temperature Sensing}
The third case study is an application for temperature sensing.
This is a distributed application, composed by a \emph{Sensor} node which
measures the temperature and sends the obtained measures to a \emph{Sink} node
which receive the temperature values and process them.
The communication between the nodes is performed by radio on the context of a
\emph{Wireless Sensor Network} (WSN).

The Figure \ref{progjava:sensor_app} shows the application executed by the
Sensor node, and the Figure \ref{progjava:sink_app} shows the application
executed by the Sink node.
Both applications are written in \java.
We have generated native code adapters for the temperature sensor
mediator (\emph{Temperature\_Sensor}), and for the network interface card
(\emph{NIC}) mediator which abstracts the radio used for communicating between
the nodes.

\progjava{sensor_app}{Sensor application.}
\progjava{sink_app}{Sink application.}

The target FFIs were KESO FFI and NanoVM FFI.
The application remains the same for both virtual machines.
The application which runs on KESO JVM was deployed in the AVR8 (8 bit)
architecture, and the application which runs on NanoVM was deployed in the ARM7
architecture (32 bit).
The platform used was the \emph{EPOS Mote} (version AVR8 and ARM7).
\emph{EPOS Mote} is an open source and open hardware mote for WSN which runs
the EPOS system \cite{EposMoteSite}.

In order to evaluate the performance of the generated native code adapters,
we have measured the time overhead for accessing the hardware mediators used by
the temperature sensing application.
Table \ref{tab:tempsensing_app_time_overhead_keso_epos_avr8} shows the
results for the AVR8 architecture using the KESO FFI.
Table \ref{tab:tempsensing_app_time_overhead_nanovm_epos_arm7} shows the
results for the ARM7 architecture using the NanoVM FFI.
For the temperature sensor device was measured the time of the \emph{sample}
method which samples the temperature from the environment.
For the NIC has measured the time for send an arbitrary message.
%
\begin{table*}[t]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Method} & \textbf{Total ($\mu s$)} &
\textbf{Device ($\mu s$)} &
\textbf{Overhead (\%)}\\
\hline
\emph{Temp::sample} & 334.22 & 330 & 1.26 \\
\hline
\emph{NIC::send} & 8586.22 & 8580 & 0.072 \\
\hline
\end{tabular}
\caption{Time overhead generated by the native code adapters.
Architecture AVR8, KESO FFI.}
\label{tab:tempsensing_app_time_overhead_keso_epos_avr8}
\end{center}
\end{table*}
%
\begin{table*}[t]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Method} & \textbf{Total ($\mu s$)} &
\textbf{Device ($\mu s$)} &
\textbf{Overhead (\%)}\\
\hline
\emph{Temp::sample} & 946.04 & 942 & 0.43 \\
\hline
\emph{NIC::send} & 958.39 & 950 & 0.87 \\
\hline
\end{tabular}
\caption{Time overhead generated by the native code adapters.
Architecture ARM7, NanoVM FFI.}
\label{tab:tempsensing_app_time_overhead_nanovm_epos_arm7}
\end{center}
\end{table*}
%
%
The ``Total'' time and the ``Device'' time from the two tables are not
comparable, since they are obtained from distinct platforms.
However, the overhead value is, and it is less than 1.3\% for all devices.
The time overhead generated by NanoVM should be bigger than in KESO JVM because
NanoVM has an overhead for interpreting the \java~bytecode.
KESO JVM does not have this kind of overhead since all bytecode is translated
to C and then to native code.
However, this is not seen comparing the tables because the bytecode
interpretation overhead was not measured for NanoVM.
The measure overhead from NanoVM comes specifically from the native method,
which uses ``push'' and ``pop'' operations to interact with NanoVM stack for
obtaining the method's arguments and for returning the method's results.

% ------------------------------------------------------------------------------
