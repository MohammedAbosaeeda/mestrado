\documentclass[conference]{IEEEtran}

\usepackage[latin1]{inputenc} % for Latin languages
\usepackage[T1]{fontenc} % for ISO and UTF characters
\usepackage[english]{babel} % for multilingual support
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{verbatim}
\usepackage{pdfpages}
\usepackage{amsmath}

\newcommand{\fig}[4][htbp]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{#3}}
  \end{figure}
}

\begin{document}

\title{Performance Evaluation of Receiver Based MAC Using Configurable Framework in WSNs}

\author{
Rodrigo Vieira Steiner$^{*}$, Mohammad Reza Akhavan$^{\dagger}$, Antônio A. Fröhlich$^{*}$, A. Hamid Aghvami$^{\dagger}$ \\
$^{*}$Software/Hardware Integration Lab, Federal University of Santa Catarina, Florianópolis, SC, Brazil \\
\{rodrigo, guto\}@lisha.ufsc.br \\
$^{\dagger}$Institute of Telecommunications, King's College London, London, UK \\
\{reza.akhavan, hamid.aghvami\}@kcl.ac.uk
}

\maketitle

\begin{abstract}
%    Receiver-based MAC (RB-MAC) is a preamble-sampling MAC protocol for WSNs in which a sender node dynamically elects a receiver among its neighbors, based on current channel conditions and node status.
%    In this paper, we evaluate the performance of RB-MAC when compared with preamble-sampling sender-based MAC protocols by using analytical methods, simulation, and real sensor nodes.
%    To implement RB-MAC we have used Configurable MAC (C-MAC), which is a framework to produce MAC protocols for WSNs.
%    C-MAC not only allowed us to implement RB-MAC, but to easily compare it with a sender-based MAC in terms of transmission delay, memory and energy consumption.
%    The experimental results presented in the paper corroborate with the analytical and simulation evaluation in that RB-MAC outperforms sender-based MAC protocols in WSNs with lossy links.

    Receiver-based MAC (RB-MAC) is a preamble-sampling MAC protocol for WSNs in which a receiver node is dynamically elected, among potential neighbors of the sender node, based on current channel conditions.
    In this paper, we evaluate the performance of RB-MAC and compare it with a sender-based preamble-sampling MAC protocol by using analytical methods, and implementation in real sensor nodes.
    We have used Configurable MAC (C-MAC), which is a framework to develop different MAC protocols in WSNs.
    This framework is realized as a component architecture that can produce application-specific communication protocols.
    The experimental results presented in the paper corroborate with the analytical and numerical results showing how RB-MAC outperforms sender-based MAC protocols in terms of transmission delay, and energy consumption.
\end{abstract}

\begin{IEEEkeywords}
    wireless sensor networks; MAC; configurability; energy efficiency; delay.
\end{IEEEkeywords}

\section{Introduction}
\label{sec:intro}
Solutions for WSN challenges are highly application-dependent and scenario-based.
In this work, we consider a scenario with poor channel conditions---with high data error rate---in which low-power and low-cost sensor nodes, with limited transmission range, generate low data traffic.
These nodes are distributed over a vast area and report gathered information towards one or more sinks.

According to the IETF's ROLL working group~\cite{Winter:2012}, a lossy link is not just a link with a high Bit Error Rate (BER).
In lossy WSNs, extremely high and frequent packet losses may occur due to different reasons like interference~\cite{Vasseur:2010}, path loss, shadowing, and multipath fading which cause the reception power of a signal to vary significantly over time and space.
Wireless links may become unavailable due to network dynamicity.
For example: sensors nodes may run out of energy; be removed from the network due to hardware failure; or new nodes may be injected into the network changing the connectivity graph.
Sensor nodes may also move to new positions out of range of their previous neighbors, and new communication links can be created. 

It is a challenge to provide both low latency and reliable data delivery in such networks, due to limited energy resources of nodes and dynamicity of network. 
Significant energy savings can be achieved by keeping sensor nodes in sleep mode for longer durations, as idle listening is the main source of energy dissipation in WSNs.
However, this reduces the availability of the nodes for communication.
Therefore, a mechanism is required to wake up the nodes whenever a packet needs to be forwarded.
Preamble sampling MAC protocols~\cite{El-Hoiydi:2002} have been designed to tackle idle listening and support sleep/wakeup modes without synchronization overheads.

To provide a satisfactory level of data delivery in the network, retransmissions have been used in many MAC protocols.
However, retransmissions are not energy-efficient and cause delay in transmissions.
In~\cite{Akhavan:2011}, Akhavan et al. proposed receiver-based MAC (RB-MAC), in which a receiver node is dynamically elected among potential neighbour nodes, based on current channel conditions and other predefined objective function (e.g. distance to the sink, residual energy, or any combinations of these parameters).
It is resilient to lossy links due to multiple receivers, yet more energy efficient as it reduces the number of retransmissions.

In this paper, we investigate the performance of the RB-MAC protocol in terms of transmission delay, and energy-efficiency by using analytical, simulation and real implementation.
To implement RB-MAC we have used the Configurable MAC (C-MAC)~\cite{steiner:2010} framework, which allowed us to evaluate and compare the protocol performance executing in real sensor nodes.

%Energy, delay, and reliable data delivery have been considered as the most challenging issues for most applications of Wireless Sensor Networks (WSNs).
%In the majority of applications, sensor nodes generate low data traffic and the communication channel is idle most of the time.
%Significant energy savings can be achieved by keeping sensor nodes in sleep mode for longer durations as idle listening is the main source of energy dissipation in WSNs.
%However, this reduces the availability of the nodes for communication.
%Therefore, a mechanism is required to wake up the nodes whenever a packet needs to be forwarded.
%Preamble sampling MAC protocols~\cite{El-Hoiydi:2002} have been designed to tackle idle listening and support sleep/wakeup mode without synchronization overheads.

%Reliable data delivery is equally important in low power and lossy WSNs.
%As stated by the IETF's ROLL working group~\cite{Winter:2012}, a lossy link is not just a link with higher BER.
%In lossy WSNs, extremely high and frequent packet losses may occur due to different reasons such as interference~\cite{Vasseur:2010}.
%Wireless links may become unstable due to network dynamicity.
%For example, sensors nodes may run out of battery or be removed from the network due to hardware failure or new nodes may be injected into the network for better connectivity.
%Sensor nodes may move to new positions that are out of range of their previous neighbors and new communication links can be created with new neighbors. 
%To maintain a satisfactory level of reliability in the network, retransmissions have been used in most MAC protocols.
%However, retransmissions are not energy-efficient and increase transmission delay.

%In~\cite{Akhavan:2011}, Akhavan et al. proposed receiver-based MAC (RB-MAC) in which, a sender node dynamically elects the receiver(s) among a number of potential neighbor nodes.
%It is resilient to lossy links due to multiple receivers, yet more energy efficient as it reduces the number of retransmissions.
%%This scheme is an attempt to achieve a good trade-off between reliability and energy-efficiency. 

%In this paper, we investigate the performance of the RB-MAC protocol in terms of transmission delay, and energy-efficiency by using analytical, simulation and real implementation.
%To implement RB-MAC we have used the Configurable MAC (C-MAC)~\cite{steiner:2010} framework, which allowed us to evaluate and compare the protocol performance executing in real sensor nodes.

The rest of the paper is organized as follow. 
Section~\ref{sec:related_work} describes related work, and the RB-MAC approach.
Section~\ref{sec:analytical} presents the analytical performance evaluation of RB-MAC together with simulation results.
The Configurable MAC framework is explained in Section~\ref{sec:cmac}.
Experimental results using real sensor nodes are presented in Section~\ref{sec:results}.
Finally, Section~\ref{sec:conclusions} concludes the paper.

\section{Preamble Sampling MAC Protocol (PS-MAC)}
\label{sec:related_work}

In Preamble Sampling approach~\cite{El-Hoiydi:2002}, generally known as low asynchronous power listening (LPL), each node selects its sleep/wakeup schedules independently of other nodes.
Sensor nodes spend most of their time in sleep mode and wake up for a short duration called clear-channel-assessment (CCA) every checking interval (CI) to check whether there is an ongoing transmission on the channel.
To avoid deafness, each data packet is preceded by a long preamble, with the same length as CI, to make sure that all receivers detect the preamble and then get the data frame.
By tuning CI and CCA, average duty-cycles of below 1\% can be achieved without any need for scheduling or synchronization.
Some MAC protocols that utilized this idea are: B-MAC~\cite{Polastre:2004}, wiseMAC~\cite{El-Hoiydi:2003}, X-MAC~\cite{Buettner:2006}, MFP~\cite{Bachir:2006}, CSMA-MPS~\cite{Mahlknecht:2004}, STEM~\cite{Schurgers:2002}, 1-hopMAC~\cite{Walteyne:2006}, and RB-MAC~\cite{Akhavan:2011}.
In B-MAC receiver nodes wake up every CI period to check for channel activity.
If a preamble is detected, the radio is kept ON until the reception of the data.
In MFP, the authors have proposed to replace the continuous preamble by a series of small frames, called micro-frames, to solve the problem of receiving irrelevant frames.
Each micro-frame contains the destination address and a sequence number which serves as a countdown to the actual data transmission, allowing a receiver to switch off its radio during micro-frame transmissions and switch it on again just before the data frame transmission.
1-hopMAC takes this idea further by allowing a node to dynamically discover its neighborhood during each transmission.
A sender node listens between sending the preamble and the data, leaving time for its neighbors to announce themselves.

Based on the forwarding mechanisms utilized, we categorize MAC protocols into two groups:

\subsection{Sender-based MAC}
The majority of MAC protocols in WSNs are sender-based.
In sender-based MAC (SB-MAC) protocols, a sensor node has a table containing the addresses of its neighbors.
The sender node selects the best receiver among the neighbors' from this table and transmits the packet after including the destination address in the packet header.
It selects the appropriate receiver based on some predefined criteria (e.g. distance to the sink, energy level of the receivers, link quality or any combination of these).
Creating and maintaining an address table is not energy efficient in lossy networks.
In addition, many retransmissions (up to seven times in IEEE 802.15.4~\cite{ieee:2003}) may occur due to dynamicity of the network, which consume considerable amount of energy and cause delay.
In this paper, we will use B-MAC as a representative example of a sender-based MAC. 

\subsection{Receiver-based MAC}

In receiver-based MAC, a sender node transmit its data without defining a particular node as a receiver.
In RB-MAC~\cite{Akhavan:2011}, a representative example of this group, when a transmitter node has a packet to send, it sends the preamble followed by the payload.
Similar to MFP, the preamble consists of micro-frames that contain useful information such as: countdown to data transmission, sender distance to sink, and payload sequence number.
All neighboring nodes within communication range of the sender sense the channel every CI interval and obtain a micro-frame.
Upon obtaining the information extracted from micro-frames, all eligible receivers (nodes closer to sink) go back to sleep and wake up to receive the data.
If a receiver gets the data with error, it just drops the packet.
This eliminates the need for retransmissions.
Nodes that correctly received the data start a back-off timer (e.g. timer set based on remaining energy, etc.).
When the timer elapse a node performs CCA. 
The node with the shortest back-off timer will sense no channel activity, and will then proceed to transmit the preamble.
Other nodes will detect the winners preamble containing the same sequence number of the same data.
Therefore; they will go back to sleep mode and drop the data.
Figure 1 illustrates the timeline of RB-MAC.

\fig{.41}{rbmac}{Timeline of RB-MAC.}

\section{Analytical Performance Evaluation}
\label{sec:analytical}

In this section, we summarise the performance of RB-MAC in terms of total energy consumption, and delay as introduced in~\cite{Akhavan:2011}. 
Table~\ref{tab:notations} presents used notations.

\begin{table}[htpb]
    \centering
    \caption{Notations and symbols.}
    \label{tab:notations}
    \begin{tabular}{l l}
        \hline
        p & probability of successfully receiving data\\
        \hline
        n & number of candidates in communication range of a node\\
%        CI & checking interval\\
%        CW & contention window\\
%        L$_{pr}$ & preamble length\\
        \hline
        D$_{DATA}$ & transmission time of one data packet\\
        D$_{cca}$ & the carrier sense duration\\
%        T$_{CTS}$ & the clear to send duration\\
        D$_{CW}$ & the contention window duration\\
        \hline
        E$_{REQ}$ & energy drained in transmitting preamble\\
        P$_{rx}$ & power drained in receive mode\\
        P$_{tx}$ & power drained in transmit mode\\
        P$_{sleep}$ & power drained in sleep mode\\
        P$_{listen}$ & power drained in listening mode\\
        \hline
    \end{tabular}
\end{table}

%\subsection{Higher Reliability}
\subsection{Lower Energy Consumption}
We use \emph{p} as the probability that a receiver successfully receives the data from source without error.
When using a sender-based MAC, the probability of retransmission is equal to 1/\emph{p}.
Conversely, RB-MAC forwards the data to all of its neighbors, which drops the retransmission probability to~\cite{Akhavan:2011}:

%We use \emph{p} as the probability that a receiver successfully receives the data from source without error.
%The outage probability \emph{q} is the probability that the transmission fails, this causing retransmission.
%When using a sender-based MAC, the outage probability is \emph{(1 - p)}.
%Conversely, RB-MAC forwards the data to all of the its neighbors, which causes the outage probability to decrease.
%To calculate outage probability in RB-MAC we can use Bernoulli distribution, which takes value 1 with success probability \emph{p} and value 0 with failure probability \emph{q = (1 - p)}.
%If we assume \emph{X} as a random variable, then:

%\begin{equation}
%    P_x(x) = C_n^{x}p^{x}q^{n-x}
%\end{equation}

%where \emph{n} is the number of receivers.
%The outage probability in RB-MAC will derive to \emph{q$^{n}$}.
%For instance, if \emph{n} = 4 and \emph{p}~=~0.80, when replacing a sender-based MAC by RB-MAC, the outage probability falls from 20\% to 0.16\%. 
%Probability of a successful transmission for \emph{n} nodes in RB-MAC is: 

%\begin{equation}
%    P_x(x \ge 1) = 1 - (1 - p)^{n}
%\end{equation}

%Consequently, a sender-based MAC has a higher probability of retransmission, equal to 1/\emph{p}, than RB-MAC, which is:

\begin{equation}
    P_{Ret} = \frac{1}{1 - (1 - p)^{n}}
\end{equation}

%\subsection{Lower Energy Consumption}
The total energy consumed in a successful transmission would be~\cite{Akhavan:2011}: 

\begin{equation}
    E_{tot} = \frac{E_{basic}}{1 - (1 - p)^{n}}
\end{equation}

where \emph{n} is the number of receivers and E$_{basic}$ is the energy cost for a single transmission.
Energy drained in transmission, reception, and total energy can be calculated as follows~\cite{Akhavan:2011}:

\begin{equation}
    \begin{split}
        E_{Tx} = &\: D_{cca}P_{listen} + E_{REQ} + D_{DATA}P_{Tx} \\
        & + (D_{CW} - D_{cca})P_{sleep} + D_{cca}P_{Rx}
    \end{split}
\end{equation}

\begin{equation}
    \begin{split}
        E_{Rx} = &\: (D_{REQ} + D_{CW} - 2D_{cca})P_{sleep} \\
        & + (D_{DATA} + D_{cca})P_{Rx} + D_{cca}P_{listen}
    \end{split}
\end{equation}

\begin{equation}
    E_{Total} = E_{Tx} + nE_{Rx}
\end{equation}

Figure~\ref{simulation_energy} presents the simulation results for energy consumption by a sender and its receivers for one transmitted packet, including energy drained in retransmissions.
It is possible to notice that SB-MAC consumes more energy as channel conditions become poor.
RB-MAC trigger fewer retransmissions, due to its cooperative nature, and its energy consumption is not significantly impacted by lower link probabilities.

\fig{.5}{simulation_energy}{RB-MAC is more energy-efficient with lossy links in comparison to sender-based MAC~\cite{Akhavan:2011}.}


\subsection{Lower Delay}

Similar to energy performance, total delay can be obtained as follows~\cite{Akhavan:2011}:

\begin{equation}
    D_{tot} = \frac{D_{basic}}{1 - (1 - p)^{n}}
\end{equation}

where D$_{basic}$ is the delay for one transmission. 
Figure~\ref{simulation_delay} presents the simulation delay results of RB-MAC and SB-MAC.

\fig{.5}{simulation_delay}{Delay performance in RB-MAC~\cite{Akhavan:2011}.}

\section{C-MAC}
\label{sec:cmac}

C-MAC is a framework of medium access control strategies that can be combined to produce application-specific protocols~\cite{steiner:2010}.
It enables application programmers to configure several communication parameters (e.g.  synchronization, contention, error detection, acknowledgment, packing, etc) to adjust and create a protocol instance that fulfil the specific needs of their applications.

C-MAC is realized as a component architecture, illustrated in Figures~\ref{cmac_act_sync}, \ref{cmac_act_send}, and~\ref{cmac_act_receive}.
%Figures~\ref{cmac_act_sync}, \ref{cmac_act_send}, and~\ref{cmac_act_receive} depict C-MAC's architecture.
Each activity in theses diagrams is executed by a microcomponent which can have different implementations.
These microcomponents alongside with the flow control can be combined to produce application-specific protocols.
By using static metaprogramming techniques, microcomponents representing activities that do not make sense for a certain protocol can be completely removed.
When an activity is removed, its inputs are forwarded to the activity targeted by its outputs, still maintaining the original flow semantics.

\fig{.25}{cmac_act_sync}{C-MAC Synchronization Activity Diagram~\cite{steiner:2010}.}
\fig{.25}{cmac_act_send}{C-MAC Transmission Activity Diagram~\cite{steiner:2010}.}
\fig{.25}{cmac_act_receive}{C-MAC Reception Activity Diagram~\cite{steiner:2010}.}

The use of static metaprogramming techniques (e.g.  templates, inline functions, and inline assembly) ensures that configurability does not come at expense of performance or code size~\cite{steiner:2010}.
%C-MAC ensures that configurability does not come at expense of performance or code size by using static metaprogramming techniques (e.g.  templates, inline functions, and inline assembly) 
In this way, C-MAC's instances are fully customized at compile-time and yield extremely lean run-time MACs.

\subsection{Configuring C-MAC}

C-MAC configuration is performed using the same concept of \emph{traits} present in the C++ standard library~\cite{Stroustrup:2000}.
Traits are parameterized classes whose static constant members describe the properties of a certain type~\cite{frohlich:2001}.
Using the configuration file, shown in Figure~\ref{fig:traits}, developers can choose which properties the protocol must possess.
When a property is selected, its functionality is included in the protocol.
This way it is possible to define the protocol behavior at compile time.

\begin{SaveVerbatim}{Traits}
// ...
template <> struct Traits<CMAC<Radio_Wrapper> >: public Traits<void>
{
// ...
    enum Synchronization {
        NO_SYNC  = 0,
        PREAMBLE = 1,
        BEACON   = 2,
    };  

    static const int SYNC = PREAMBLE;

    enum Preamble_Content {
        DUMMY                 = 0,
        TIME_TO_DATA_AND_RANK = 1,
        DESTINATION_ID        = 2,
    };  
// ...
    static const int PREAMBLE_CONTENT = TIME_TO_DATA_AND_RANK;
    static const int PREAMBLE_LENGTH  = 144;
    static const int SLEEPING_PERIOD  = 144;
// ...
    static const bool forward_data_to_sink = true;                                                                                                                        
    static const int RANK  = 2;
// ...
};
// ...
\end{SaveVerbatim}

\begin{figure}[h]
    \tiny
    \center
    \fbox{
    \begin{minipage}{\columnwidth - 1.5 cm}
        \BUseVerbatim{Traits}
    \end{minipage}
    }
    \caption{Traits configuration file.}
    \label{fig:traits}
\end{figure}

Figure~\ref{bmac_rbmac} presents the C-MAC activity diagram for B-MAC and RB-MAC configurations. 
As can be seen, only states that are actually used are present.
Therefore, there is no additional overhead to the generated code.
Both B-MAC and RB-MAC use the same states.
However, they use different microcomponents to handle preamble synchronization and to determine if a transmission was successful.

%\fig{.25}{bmac_rbmac}{C-MAC final Activity Diagram for B-MAC and RB-MAC. Both protocols use the same states, but in some cases different microcomponents. Highlighted states indicate which microcomponents have different implementation.}
\fig{.25}{bmac_rbmac}{C-MAC Activity Diagram for B-MAC and RB-MAC. Highlighted states indicate which microcomponents have different implementation.}

\section{Experimental results}
\label{sec:results}

In order to evaluate RB-MAC in real sensor nodes we chose to use the EPOSMote II platform, which belongs to an open hardware project~\cite{eposProject}.
%The EPOSMote is an open hardware project~\cite{eposProject}.
%The project main objective is delivering a hardware platform to allow research on energy harvesting, biointegration, and MEMS-based sensors.
%This platform focus on modularization, and thus is composed by interchangeable modules for each function.
Its hardware is designed as a layer architecture composed by a main module (responsible for processing, storage, and communication), a sensoring module, and a power module.
%The main module is responsible for processing, storage, and communication.
The model used in this research features a 32-bit ARM7 processor, 128kB of flash, 96kB of RAM, and an IEEE 802.15.4-compliant radio transceiver.
%We have developed a startup sensoring module, which contains some sensors (e.g. temperature and accelerometer), leds, switches, and a micro USB (that can also be used as power supply).
Figure \ref{emote2-mc13224v-pictures-real_white_background} shows the development kit which is slightly larger than a R\$1 coin.
Table~\ref{tab:mote_comparison} shows a comparison between the EPOSMote II specification with other sensor nodes highly used in WSNs.

\fig{.07}{emote2-mc13224v-pictures-real_white_background}{EPOSMote II SDK side-by-side with a R\$1 coin. On the left the sensoring module. On the right the main module.}

%Figure \ref{emote2-block_diagram} shows an overview of the EPOSMote II architecture.

%\fig{.45}{emote2-block_diagram}{Architectural overview of EPOSMote II.}

\begin{table*}[htpb] 
  \centering   
  \setlength{\arrayrulewidth}{2\arrayrulewidth} 
  \setlength{\belowcaptionskip}{10pt}  
  \caption{Comparison of Mote Specifications~\cite{telosb:datasheet, mica2:datasheet, micaz:datasheet, mc13224v:datasheet}.}
  \label{tab:mote_comparison}
  \begin{tabular}{|l|c|c|c|c|} 
    \hline
    Mote & TelosB & Mica2 & MicaZ & EPOSMote II\\
    \hline \hline
    MCU & MSP430 & ATmega128L & ATmega128L & ARM7TDMI-S \\
    \hline
    Processor Speed & 8 MHz & 8 MHz & 8 MHz & 26 MHz \\
    \hline
    Program Flash Memory & 48 K & 128 K & 128 K & 128 K \\
    \hline
    RAM & 10 K & 4 K & 4 K & 96 K \\ 
    \hline
    Processor Current Draw - active mode & 1.8 mA & 8 mA & 8 mA & 3.3 mA \\
    \hline
    Processor Current Draw - sleep mode & 5.1 $\mu$A & < 15 $\mu$A & < 15 $\mu$A & 0.85 $\mu$A \\
    \hline \hline
    Radio  & CC2420 & CC1000 & CC2420 & Integrated transceiver \\
    \hline
    Radio frequency & 2400 to 2483.5 MHz & 315/433/915 MHz & 2400 to 2483.5 MHz & 2405 to 2480 MHz \\
    \hline
    Rx Current Draw & 21.8 mA & 10 mA & 21.8 mA & 22 mA \\
    \hline
    Tx Current Draw & 19.5 mA & 27 mA & 19.5 mA & 29 mA \\
    \hline
  \end{tabular}
\end{table*}

\subsection{Results}

We have configured C-MAC to mimic both B-MAC and RB-MAC and the probability \emph{p} of a node successfully receive a packet was ranged between 1, 0.8, 0.5, and 0.3. 
To simulate the channel conditions in this implementation we have used the pseudo random algorithm provided by the operating system.
Each time a node receives a packet it generates a random number, inside an interval, and according with the result and the probability \emph{p} under test the packet may be discarded.

%We have configured C-MAC to mimic both B-MAC and RB-MAC and the probability \emph{p} of a packet being successfully received by a node was ranged between 1, 0.8, 0.5, and 0.3.
%To simulate the channel conditions in our implementation we have used the pseudo random algorithm provided by the operating system.
%Each time a node receives a packet it generates a random number, inside an interval, and according with the result and the probability \emph{p} under test the packet may be discarded.

Figure~\ref{scenario_bmac_rbmac} illustrates the evaluation scenario.
At first, one node is set as sender and another one as receiver.
Both B-MAC and RB-MAC are evaluated for each probability \emph{p}.
When all probabilities are tested another receiver is added and this process repeats itself until the network possess a total of four receivers at the same time.

\fig{.4}{scenario_bmac_rbmac}{B-MAC and RB-MAC latency varying channel conditions.}

Both protocols were evaluated in terms of memory footprint, latency and energy consumption.
For all experiments, we have used: the GNU GCC compiler for ARM, version 4.4.4; the ARM processor clock was set to 24 MHz; CCA duration of 1.43~ms; preamble duration of 143.8~ms; data packets size of 94 bytes; and 4.5 dBm of transmission power.

We have used the \texttt{arm-size} tool, from GNU Binutils version 2.20, to obtain the memory footprint of both protocols.
Results are shown in Table~\ref{tab:CodeSize}.
As expected, RB-MAC presents a larger footprint since it uses more complex mechanisms.
While B-MAC uses a dummy preamble content, RB-MAC uses helpful information allowing nodes to go back to sleep or even quit contention.
Also, B-MAC uses simple acknowledgement packets as transmission confirmation, while RB-MAC uses a contention window mechanism to check if a transmitted packet is being properly forwarded.

\begin{table}[htb] 
  \centering 
  \setlength{\arrayrulewidth}{2\arrayrulewidth} 
  \setlength{\belowcaptionskip}{10pt}  
  \caption{Memory footprint (bytes).}
  \label{tab:CodeSize}
  \begin{tabular}{|c|c|c|c|} 
    \hline
    \textbf{Section} & \textbf{B-MAC} & \textbf{RB-MAC} \\ 
    \hline \hline
    .text & 10780 & 11236 \\
    \hline
    .data & 38 & 38 \\
    \hline
    .bss  & 5679 & 5679 \\
    \hline
    TOTAL & 16497 & 16953 \\
    \hline
  \end{tabular}
\end{table}

In order to determine the necessary time and amount of energy required to transmit a packet for each protocol, we have used an oscilloscope as illustrated in Figure~\ref{oscilloscope}.
A General Purpose Input/Output (GPIO) pin corresponding to a LED output pin in EPOSMote II is connected to the oscilloscope and set to high before a transmission starts and reset to low right after the confirmation of reception.

\fig{.23}{oscilloscope}{Schematic of the EPOSMote II connected to oscilloscope.}

Figure~\ref{latency_bmac_rbmac} presents the necessary time to successfully transmit a packet, including retransmissions, varying the channel conditions for both protocols.
It is possible to notice that B-MAC's performance deteriorates as the reception probability decreases and that it is not influenced by the amount of receiver nodes.
This happens because, in B-MAC, the sender node sends the data to a specific receiver.
Thus, the lower the probability of reception, the more retransmissions will be needed, thereby increasing the necessary time to successfully transmit a packet.
As for the RB-MAC protocol, the sender does not have a specific receiver, and all neighboring nodes are potential receivers.
The more neighbors, the greater the chances that a message will be successfully received, and therefore the number of retransmissions is reduced.
When the probability of reception is equal to one, there is no need for retransmission, and both protocols have the same behavior.

\fig{.71}{latency_bmac_rbmac}{B-MAC and RB-MAC latency varying channel conditions.}

The energy consumption to transmit a packet, including retransmissions, is illustrated in Figure~\ref{energy_bmac_rbmac}.
Since a transmission in B-MAC has a specific receiver, each other receiver in the network becomes synonymous of idle listening, in other words, wasted energy.
Furthermore, the lower the probability of reception, the greater is the number of retransmissions, and the higher is the energy consumption.
As for RB-MAC, more neighbors mean fewer retransmissions.
Nevertheless, this does not always means less energy consumption.
There is a relation between the probability of reception and the energy spent on unnecessary listening in which, after a certain point, adding a receptor does not reduce energy consumption.
This happens because only one of the receivers has to get the data, so the energy spent by other receivers is wasted.
Therefore, when the energy wasted by other receivers is higher than the energy saved by reducing retransmissions, then the total energy consumption increases.
This relation can be observed in Figure~\ref{energy_bmac_rbmac}.
At the configuration RB-MAC with \emph{p} = 0.5, the energy consumption reduces from one to two receivers, from two to three, but starts to increase when there are four receivers.

\fig{.71}{energy_bmac_rbmac}{B-MAC and RB-MAC energy consumption varying channel conditions.}

\section{Conclusion}
\label{sec:conclusions}
This paper presented the performance evaluation of RB-MAC under three different methods: analytical, simulation, and real implementation.
%RB-MAC was compared with two sender-based preamble-sampling MAC protocols: B-MAC, a classic protocol in WSNs, executing in real sensor nodes; and 1-hopMAC, a more recent and state-of-the-art protocol, under simulation.
Using the C-MAC framework, RB-MAC was compared with B-MAC executing in real sensor nodes.
The results confirm that RB-MAC is significantly more resilient to lossy links when compared to sender-based MAC protocols.
As the number of network nodes increase, RB-MAC requires fewer retransmissions, consequently, reducing transmission delay and energy consumption.
In our current work, we are studying the use of adaptive preamble lengths, adaptive CIs, and the behavior of the protocol in multi-hop transmissions.
   
\bibliographystyle{IEEEtran}
\bibliography{references.bib}

\end{document}
