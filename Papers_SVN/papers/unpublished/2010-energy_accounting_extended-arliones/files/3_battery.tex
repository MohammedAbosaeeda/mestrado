\section{Battery Level Monitoring by Event Accounting}
\label{sec:account}

%general introduction. pessimistic bias. show desired behaviour.
As stated in Section~\ref{sec:intro}, traditional voltage-based battery
monitoring may lead to an pessimistic bias of an energy-aware task scheduler. In
order to enhance the precision of the battery monitor, we propose a scheme to
account for energy consumption implemented in software. This scheme is based on
the premise that energy is consumed by hardware, not software, but it is the
software that controls and monitors hardware activity. Considering that the
operating system layer abstracts hardware access to application, it is
straightforward to assume that the operating system is the entity with most
knowledge about hardware activity, thus being able to monitor system-wide energy
consumption.

\subsection{Energy consumption profiles}
\label{sec:profiles}

We analyzed usual hardware behavior and modeled three different ways to account
for energy consumption: time-based measurement, event-based measurement, and
combined measurement.
%time-based
The time-based approach is used for accounting energy consumption of devices
which drain constant current over time when in a specific operating mode. In
this scenario, timestamps are stored when an operating mode transition is
performed and energy consumption is computed by multiplying the time the device
stayed in the previous operating mode by the current drain during that period
(Equation~\ref{eq:en_dev_time}).
% In order to avoid the loss of precision when a device stays for too long in a
% specific operating mode, a system task periodically requests the individual
% energy accounters to update the global accounter and to reset the timestamps
% (Equation~\ref{eq:en_dev_time}).

\begin{eqnarray}
E_{tm}(dev) = (t_{end} - t_{begin}) \times I_{dev,mode} \label{eq:en_dev_time}
\end{eqnarray}

%event-based
For some devices, however, energy consumption is better measured on an
event-basis. It is the case of, for instance, sensor sampling. Given a set of
operational parameters (e.g., ADC frequency, sensor characteristics) it is
possible to determine an energy cost per sample, either analytically or by means
of measurement, thus enabling energy accounting to be linked to event
monitoring. In this model, system energy consumption is updated for every event.
The notation used is in Equation~\ref{eq:en_dev_ev}.

\begin{eqnarray}
E_{ev}(dev) = \sum_{event\_counters} E * counter \label{eq:en_dev_ev}
\end{eqnarray}

%both
Additionally, for some devices, both approaches may be used. For instance, a
radio that stays in a low-power listen mode waiting for data to arrive have a
base energy consumption which may be computed using the time-based approach.
When data actually arrives, we may know the amount of energy that will be
consumed to process the reception of each byte. Energy consumption for data
reception can then be computed with the event-based approach. The notation used
for this is in Equation~\ref{eq:en_tm_ev}.

\begin{eqnarray}
E_{tot}(dev) = E_{tm}(dev) + E_{ev}(dev) \label{eq:en_tm_ev}
\end{eqnarray}


\subsection{Battery state-of-charge monitoring}

% further describe system runtime operation.
% present battery monitoring algorithm - battery charge updated periodicaly by
% means of event-counters which are updated at run-time.
At runtime, battery charge is updated with the accounted data of each device.
These accounting information, however, need to be collected in order to update
battery charge. The frequency in which these data are collected directly affects
the accuracy of the proposed battery charge monitor. Recalling the curves in
Figure~\ref{fig:sampled_real_discharge}, we may say that high update frequencies
would draw a curve close to the ``real charge'', while low update frequencies
would approximate the ``sensed charge'' curve. In this section we describe how
to achieve a satisfactory curve close to the ``real charge'' curve of
Figure~\ref{fig:sampled_real_discharge} by adequately adjusting the battery
update frequency.

We start by analyzing the update frequency for the time-based profile. It is not
the intent of the present work to investigate issues related to the frequency of
operating mode migrations or their time and energy overheads, for such problems
have already been extensively addressed~\cite{Hoeller:DIPES:2006,Seo:2011}.
Thus, this profile can adhere to such migration models by the inclusion of an
extra routine like $migration\_update\_energy$ on Figure~\ref{prg:batt_updates}
to compute elapsed time and consumed energy during these migrations as described
by Equation~\ref{eq:en_dev_time}. The execution time for this routine, shown in
Table~\ref{tab:time_overhead} is constant and can be easily obtained and
integrated to any transition model, being either real-time or not. Additionally,
to prevent the system from loosing control of battery discharge when devices
stays in a certain operating mode for long periods, an active component
periodically collects energy consumption information from all devices and
updates battery charge.

\prg{pascal}{batt_updates}{Algorithms for energy accounting.}

\tab{time_overhead}{Processing overhead of the energy accounter on an
ARM7-TDMI processor.}

For the event-based profile, however, the battery charge update approach needs
to be different to avoid unnecessary processing overheads. For instance, suppose
that a hypothetic system monitors an event that is the reception of a byte from
a network interface. Network protocols will seldom use only one byte to perform
communications, thus, as can be seen in Table~\ref{tab:time_overhead}, system
performance may benefit from periodic updates of an accumulated counter. In
order to do that, an active object was modeled as an extra task on the system
which is responsible for collecting accounted information of the event-based
profile.

It is important to note that the accounting mechanism employed in this scheme,
although more accurate, is still pessimistic once it is based on the worst-case
energy consumption (WCEC) of events and components' operating modes. Thus, it is
expected that the accounted energy consumption reaches the value read from the
battery voltage model short before it shows a drop in voltage. It is safe to
assume that the information from the voltage model is a secure bound to battery
charge, although conservative. Then, we may correct the battery charge to the
maximum value between the accounted charge and the one estimated by the voltage
model (Equation~\ref{eq:batt_update}).

\begin{eqnarray}
E_{batt} = max\left(E_{volt} , E_{batt} - \sum_{i = 0}^{\#devs} E_{tot}(i)\right)
\label{eq:batt_update}
\end{eqnarray}

Finally, the active component with the task of periodically updating the battery
charge is responsible for collecting accounted information from both event-based
and time-based profiles. The algorithm is the one at the procedure
$energy\_update\_total$ of Figure~\ref{prg:batt_updates}. It is important to
note that timestamps and event counters are reset every time energy accounting
is updated (by $migration\_update\_energy$ and $event\_update\_energy$), thus
making sure that no energy consumed is accounted for twice. This algorithmic
approach assumes initialization of $Battery$ with the nominal capacity of the
battery in use.


\subsection{On the Freshness of Battery Information}
\label{sec:frequency}

To understand the accounter behavior further we performed an exploration of
system design space to be able to determine the frequency in which accounted
data should be gathered provided that the system has a pre-defined requirement
of operation lifetime. We used a multi-objective optimization method based on
the \textit{Non-dominated Sorting Genetic Algorithm II}~(\nsga)~\cite{Deb:2002}
which is able to find good solution candidates for the frequency of the
collector task, i.e., those closer to the Pareto front. The optimization is
executed with two objectives: to minimize residual energy and to maximize the
execution rate of best-effort tasks. We use a simple scheduling mechanism in
which hard real-time tasks execute regardless of system energy availability and
best-effort tasks run only when the system is still able to guarantee energy
availability for hard real-time tasks. Priorities in the scheduling queue are
assigned through a Rate Monotonic policy provided that all hard real-time tasks
have higher priorities than any best-effort task, regardless of their period. We
also assume that initial battery charge is enough to guarantee hard real-time
tasks' executions during the expected lifetime.

\wtab{hyp-taskset}{Hypothetic application tasks' parameters.}

Now we analyze a hypothetic application. Table~\ref{tab:hyp-taskset} shows the
parameters for this application, comprised by two hard real-time tasks ($H_1$
and $H_2$), one best-effort task ($B_1$) and the energy accounter collector task
($H_C$), ordered according to their priority. We kept the collector task as a
hard real-time task for two reasons. First, it is the only way to guarantee that
the defined period for the collector task will be respected, once best-effort
tasks may be prevented from executing. Second, if eventually the system stops
the execution of best-effort tasks and the collector task is a best-effort task,
the battery information will no longer be updated, thus being this a dead-end
for the energy-aware scheduler.

In order to evaluate the system instances (individuals) generated during the
optimization process we integrated a real-time simulator to the optimizer. This
system simulates a rate monotonic queue with two levels of priorities, being the
first one the task's class and the second one the rate monotonic priority
itself. This made it possible the separation between hard real-time and
best-effort tasks. The simulator also monitors energy consumption of tasks and
controls battery discharge based on informed worst-case energy consumption
(WCEC) of tasks. In order to achieve a more realistic behavior we consider that
all tasks actually use their WCEC for 75\% of the jobs. The remaining 25\% of
the jobs have a random energy consumption uniformly distributed between 50\% and
100\% of the WCEC. This generates a slack on the energy budget that can be used
by the best-effort tasks, as would actually happen on real systems. Although
naive, this simple probabilistic assumption helps to understand and analyze the
approach. More consistent approaches will be considered later in
Section~\ref{sec:wcet_impact} and in the case study of Section~\ref{sec:case}.

\fig{hyp-solutions}{All solutions for the hypothetical
application.}{width=\columnwidth}

\tab{hyp-solutions}{Solutions for the frequency of the collector task for the
hypothetical application.}

We ran \nsga~with a population size of 100 individuals, being 20 of them
selected as parents, generating 20 offsprings, repeating the process during 50
generations (iterations) (\nsgaparam).
%With these parameters the optimizer was able to find four good solutions for
%the collector task frequency, shown at Table~\ref{tab:hyp-solutions}.
Figure~\ref{fig:hyp-solutions} shows all simulated solutions. The best
solutions, i.e., those at the Pareto front, are shown in
Table~\ref{tab:hyp-solutions}. It is possible to observe here the wide spread
of results obtained from the optimization process. Moreover,
Figures~\ref{fig:hyp-bet_freq} and~\ref{fig:hyp-batt_freq} show the non-linear
behavior of the observed parameters (respectively, best-effort tasks' execution
rate and residual battery) in relation to frequency, showing why the solution to
this problem benefits from the application of meta-heuristic methods like \nsga.

%\figthree
\figtwo
{hyp-bet_freq}{Execution rate of best-effort tasks.}
{hyp-batt_freq}{Residual energy after projected lifetime.}
%{hyp-lost_freq}{Total of lost hard deadlines.}
{Optimization objectives plotted against variations on the frequency of the
collector task for the hypothetical application.}


\subsection{On the Impact of Actual Energy Consumption}
\label{sec:wcet_impact}

In these experiments we observed that the optimization results, as expected, are
directly dependent on the actual energy consumption of tasks. In
Section~\ref{sec:frequency}, with the goal of illustrating the concepts, we
considered that tasks only use their WCEC for 75\% of their jobs, while the
remaining 25\% of the jobs have its energy consumption uniformly distributed
between 50\% and 100\% of the WCEC. In a real system, however, it is too
difficult, if not impossible, to derive such assumptions. In order to cope with
that one needs to adapt the collector task's frequency to the actual execution
rate of tasks during runtime.

\tab{hyp-10pc}{Pre-calculated frequencies in different WCEC scenarios for the
hypothetical application.}

Instead making such statistical assumptions during simulations, we fixed the
energy consumption to several different values, ranging from 1.00\% to 100\% of
the WCEC to observe the results. This led to the configurations shown at
Table~\ref{tab:hyp-10pc}. As can be seen, the frequency of the collector task
varies greatly when WCEC goes above circa 75.76\%\footnote{This limit is
determined by $K_{WCEC} = \frac{B_0}{T_t * E_1}$, where $B_0$ is the initial
battery charge, $T_t$ is the target system lifetime (in seconds), and $E_1$ is
the energy consumed by all system tasks (including best-effort) during one
second. $B_0$ and $E_1$ need to be at the same unit (e.g., mAh).}. That means
that target battery lifetime will only be at risk if system is consuming more
than this limit. With this information in hand, we adapted the simulator to be
able to change frequency of the collector task frequency according to the actual
system energy consumption based on the information at Table~\ref{tab:hyp-10pc}.
For this setup, we set a transition point when energy consumption crosses the
75\% limit. If consumption is low, the period of the collector task is set to
7~ms, if consumption is high, the period changes to 177~ms.

Simulation showed that the proposed heuristic resulted in a best-effort task
execution rate of $60.66\%$ with a residual energy of $0.2781$\promille~with the
same probabilistic assumptions made on the actual energy consumption of tasks.
If compared with the solutions found by the experiment of
Section~\ref{sec:frequency}, the heuristic was able to sustain a similar
best-effort execution rate while presenting more residual energy, as expected.

If we change the probabilistic assumptions, however, we see that the heuristic
is still able to get results close to the previous setup. We first relaxed the
task's energy consumption so that only 25.0\% of the jobs consume the whole
WCEC. This resulted in a best-effort execution rate of $80.08\%$ and a residual
energy of $0.2674$\promille. When we restricted the taks's energy consumption
further, to 90.0\%, the results were $34.64\%$ for the best-effort task
execution rate and $0.2770$\promille~for the residual energy. Running the
optimization process using these variations also resulted in similar values:
$80.36\%$ and $0.103$\promille~for 25\%; and $34.74$ and $1.826$\promille~ for
90\%. This shows that the heuristic approach is preferred to the use of a unique
collector task frequency.
