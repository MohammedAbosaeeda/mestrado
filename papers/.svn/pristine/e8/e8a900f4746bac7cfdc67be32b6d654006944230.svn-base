The principal reason(s) for this decision is (are) as follows:

This paper addresses an important problem, however the TPC feels that the novelty and the contribution of the paper is unclear. Although your contribution is valuable we think that other contributions deserve better a place in the technical program. DAC is a very competitive conference and only the top quartile of submissions are accepted.

=================================================================================
=================================================================================
REVIEWS SUMMARY
=================================================================================
=================================================================================

-Synthesis from a unified C/C++/SystemC/SpecC based, generic input model (not just dataflow, there are other ones that you quote and that claim to support general models in these languages) has been already supported, even though you try to argue otherwise in your related work section.?

-Section 3.2.1 to 3.2.4: This paper seems to be building up on previous work (references [5],[18] or [19]), but the previous work and the contributions of this paper are very much mixed up. So I am not able to say what exactly is the contribution of this specific paper, beyond what is presented in section 3.2.3 (which is rather small). A clear previous work section would also help the paper to be more self-contained, as well as separating specific issues corresponding to the proposed methodology, of those which are general concepts well known in the state-of-the Art (for instance, Section 3.2.1).

-Section 2 seems unnecessarily long, literature is reviewed without doing a comparison to the current approach. A better writing style could have been to combine secn 2 and 3.1, and doing a comparison.

-The design flow is very abstract. It is unclear how it can address the important challenges in HW/SW co-design, such as heterogeneity, complexity of the design space, semantics correctness. The experiments only showed the overhead of the proposed approach but not the benefits (the design quality comparison is more on the HLS part rather than on the proposed approach). 

-Not enough details about the HW/SW aspects are really provided, e.g. in terms of (automatically and efficiently) handling pointers and memory management. In fact, it sounds like your approach actually also requires rewriting the code into a common denominator subset. That could still be valid, if you could prove that it leads to better quality of results. 


-Your experiments show that you are worse (in some cases quite significantly) than hand-crafted code (which is somewhat expected), but how does it compare against other synthesis strategies? Which is really what you are competing against (in terms of productivity) ? When comparing hardware synthesis results, instead of fully handwritten code, why don't you compare against manually developed models that have been specifically written for HLS?

-In the experimental results (Table 1 in Section 4), why do the unified C++ codes result in software binary that has less data memory usage, compared with their original C/C++ versions?

-A further description of the PABX system, including the main features of each subsystem (DTMF, IMA, ADPCM...) would be also welcomed. 


-The paper should be revisited for avoiding confusing and wordy descriptions, as happens throughout Section 3.

-Figure 2 is too crowded.

-The authors should avoid citations as for reference [17], which do not conform to the blind-review policy.

-The table # references in Section 4 are all wrong. Please do careful proofreading before submission.


=================================================================================
=================================================================================
FULL REVIEWS
=================================================================================
=================================================================================

1=unacceptable; 2=poor; 3=marginal; 4=good; 5=excellent

139-HE304
Unified Design of Software and Hardware Components

Reviewer ID: 43193
Overall Recommendation:
3 - Marginal
How novel or worthwhile are the ideas in the papers?
3
How adequately is the existing literature referenced?
4
How clearly is the technical contribution described?
4
How well are the claims and conclusions supported?
2
How well are the advantages and limitations described?
3
How well is the paper organized?
4
How clear is the author's use of English?
4
How effectively does the author use tables, figures and pictures?
4

COMMENTS TO THE AUTHOR
Overall, in contrast to what the title says and what the motivation in the majority ofmthe introduction is aimed at, in my view the paper is not really about Design aspects, but would rather better be oriented as a contribution in the are of specification or modeling. Design and synthesis is covered by many other approaches, often in very similar ways. For example, all the interface synthesis approaches (RPC, Hal and similar stub based communication synthesis mechanisms) are done exactly like that in almost all other synthesis flows. Likewise, synthesis from a unified C/C++/SystemC/SpecC based, generic input model (not just dataflow, there are other ones that you quote and that claim to support general models in these languages) has been already supported, even though you try to argue otherwise in your related work section.?
What could be new and really interesting is the observation that, despite all efforts and claims to the contrary, effective backed synthesis still requires (re)writing the input code, i.e. usually only subsets are supported depending on the backed target. I could see how your approach (based on aspects) could help there. But unfortunately, not enough details about those aspects are really provided, e.g. in terms of (automatically and efficiently) handling pointers and memory management. In fact, it sounds like your approach actually also requires rewriting the code into a common denominator subset. That could still be valid, if you could prove that it leads to better quality of results. But your experiments don't really show that. ?They show hat you are worse (in some cases quite significantly) than hand-crafted code (which is somewhat expected), but how does it compare against other synthesis strategies? Which is really what you are competing against (in terms of productivity)?
Apart from these general observations, a few more detailed comments:* when comparing hardware synthesis results, instead of fully handwritten code, why don't you compare against manually developed models that have been specifically written for HLS? That would be fairer and should actually help your case.* there are a few minor English and formatting issues. E.g. in the experiments (Section 4) you always refer to Table 4 even though there is no table 4.


============================================================

Reviewer ID: 27411
Overall Recommendation:
2 - Possible Reject
How novel or worthwhile are the ideas in the papers?
2
How adequately is the existing literature referenced?
2
How clearly is the technical contribution described?
2
How well are the claims and conclusions supported?
2
How well are the advantages and limitations described?
2
How well is the paper organized?
2
How clear is the author's use of English?
2
How effectively does the author use tables, figures and pictures?
3

COMMENTS TO THE AUTHOR
In this paper, a methodology to unify the design of both software and hardware components is proposed, based on Aspect Oriented and Object Oriented programming paradigms.

Differently to High level synthesis existing approaches, its objective is not only to describe HW components, but also to allow these components to be easily implemented in software, unifying both design flows with a reduced performance overhead.

The coupled design of both software and hardware components of a system has been already addressed in several works in the State-of-the-Art. Furthermore, some of these works, including the ADESD approach, already use the Aspect-oriented programming techniques. However, the novelty of contributions provided in this work are not clearly highlighted, compared with State-of-the-Art, since most of the concepts tackled in the paper seem to rely on previously presented works (references [5],[18] or [19]). On the other hand, the organization of the paper is poor, so the authors are strongly recommended to clearly distinguish between novel and previous contributions, splitting it up into different sections. A previous work section would also help the paper to be more self-contained, as well as separating specific issues corresponding to the proposed methodology, of those which are general concepts well known in the state-of-the Art (for instance, Section 3.2.1). Also, the paper should be revisited for avoiding confusing and wordy descriptions, as happens throughout Section 3. Regarding section 4, all the tables are referenced as "Table 4".

The evaluation of the platform is limited to the implementation of a single use case, so that the comparison of the proposed methodology with those existing in the State-of-the-Art it is not possible. Just the overhead of applying this technique, compared with the former implementation (Which is not described) of the PABX, is analyzed. A further description of the PABX system, including the main features of each subsystem (DTMF, IMA, ADPCM...) would be also welcomed.

============================================================

Reviewer ID: 73036
Overall Recommendation:
2 - Possible Reject
How novel or worthwhile are the ideas in the papers?
2
How adequately is the existing literature referenced?
3
How clearly is the technical contribution described?
2
How well are the claims and conclusions supported?
2
How well are the advantages and limitations described?
2
How well is the paper organized?
3
How clear is the author's use of English?
3
How effectively does the author use tables, figures and pictures?
2

COMMENTS TO THE AUTHOR
This paper presented an approach for co-designing HW and SW components, with mechanisms implemented in only standard C++ features. At the back-end, HLS tools are leveraged for implementation.

HW/SW co-design is a very important topic and there has been a significant amount of work in this area (some mentioned in the literature review of the paper). This paper proposed some interesting ideas (on the usage of several C++ features), however overall it is not convincing what the advantages are of this methodology. The design flow is very abstract. It is unclear how it can address the important challenges in HW/SW co-design, such as heterogeneity, complexity of the design space, semantics correctness. The experiments only showed the overhead of the proposed approach but not the benefits (the design quality comparison is more on the HLS part rather than on the proposed approach).

============================================================

Reviewer ID: 61906
Overall Recommendation:
2 - Possible Reject
How novel or worthwhile are the ideas in the papers?
4
How adequately is the existing literature referenced?
4
How clearly is the technical contribution described?
2
How well are the claims and conclusions supported?
3
How well are the advantages and limitations described?
3
How well is the paper organized?
3
How clear is the author's use of English?
4
How effectively does the author use tables, figures and pictures?
3

COMMENTS TO THE AUTHOR
The paper attempts to model hardware and software components in the same style, thus making easy passage to high level synthesis tools for hw components, thereby increasing flexibility and reusability.
* secn 2 seems unnecessarily long, literature is reviewed without doing a comparison to the current approach. A better writing style could have been to combine secn 2 and 3.1, and doing a comparison.
* figure 2 is too crowded.
* secn 3.2, paras 1,2: The paper does not seem to be blind, it is clear that the authors are the same as [5]. It is fine to refer to a previous paper, but the presentation has to be modified so that it appears to be from a different author.
* secn 3.2.1 to 3.2.4: This paper seems to be building up on previous work, but the previous work and the contributions of this paper are very much mixed up. So I am not able to say what exactly is the contribution of this specific paper, beyond what is presented in secn 3.2.3 (which is rather small).
* secn 4: refers several times to table-4, but that is missing. Looks like a cut-paste problem.
Overall: the topic covered is good and very relevant, but maybe due to bad presentation, the exact contribution of this paper (as compared to previous contribution by the same author) is not at all clear. If accepted, it should be as a short paper, with much of the previous work description deleted and focusing mainly on the contributions of this paper alone.


============================================================

Reviewer ID: 30754
Overall Recommendation:
1 - Reject
How novel or worthwhile are the ideas in the papers?
1
How adequately is the existing literature referenced?
3
How clearly is the technical contribution described?
2
How well are the claims and conclusions supported?
2
How well are the advantages and limitations described?
2
How well is the paper organized?
4
How clear is the author's use of English?
4
How effectively does the author use tables, figures and pictures?
4

COMMENTS TO THE AUTHOR
This paper presents some guidelines for component specification using C++ to facilitate hardware/software co-design. The technical part of the paper significantly overlaps with previous works. Detailed comments are listed as follows.

(1) The major technical part (Section 3.2) is compiled from previous works [5,17,18]. Specifically, the overall principle (OOP and AOP) is from ADESD [5], Sections 3.2.1 and 3.2.2 have been presented in [17], and the "scenario adapter" (Section 3.2.2) is not novel either [18].

(2) The authors should avoid citations as for reference [17], which do not conform to the blind-review policy. Moreover, although Reference [17] has not been published yet, it is already available online at
http://joaopizani.hopto.org/graduacao/LISH/icecs2011-hls_hybrid_components-joaopizani/paper-camera-ready.pdf. In particular, Figure 3 in the submission and Figure 1 in Reference [17] are the same, but no proper citation is given in the caption of Figure 3.

(3) In the experimental results (Table 1 in Section 4), why do the unified C++ codes result in software binary that has less data memory usage, compared with their original C/C++ versions?

(4) The table # references in Section 4 are all wrong. Please do careful proofreading before submission.

============================================================

Reviewer ID: 54231
Overall Recommendation:
2 - Possible Reject
How novel or worthwhile are the ideas in the papers?
2
How adequately is the existing literature referenced?
4
How clearly is the technical contribution described?
2
How well are the claims and conclusions supported?
2
How well are the advantages and limitations described?
2
How well is the paper organized?
3
How clear is the author's use of English?
4
How effectively does the author use tables, figures and pictures?
2

COMMENTS TO THE AUTHOR
It is not clear for me what the authors intend to improve or what?kind of problems they intend to solve?by unifying hardware and software components.? The experimental results in chapter 4 only show there are not any big problems using the proposed techniques.? It seems to me that this paper only describes how to handle hardware and software components in unified manner.??


============================================================ 
