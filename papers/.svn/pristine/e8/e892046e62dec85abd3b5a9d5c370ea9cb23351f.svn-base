% + Proposal
%
% This section presents our proposal showing how it fulfills embedded systems
% requirements.
% Performance and efficient resource usage (achieved with) => hardware mediators
% Platform portability => hardware mediators
% Reuse of device drivers between distinct FFI => the tool Extensible Binding Generator (EBG) +
%  explains how EBG works: DERCS for represent hardware mediators and FFI aspects.
% EBG Weaver to compose then.
% 
% ------------------------------------------------------------------------------
\section{Proposal} \label{sec:proposal}
This section describes our method to abstract hardware devices to be used by
programs written in distinct MPLs, adapting a hardware device to the target MPL
through an aspect weaving.
This section also shows the application of the proposed method for the languages
\java~and \lua.

% TODO: na criação de uma seção de implementação/aplicação em Java e Lua, os
% paragrafos abaixo iriam para ela.
We have applied our method, in the case of the \java~language, on two JVMs that
target embedded systems: KESO and NanoVM.
KESO is a JVM targeting embedded control units of
automotive systems \cite{Thomm:2010}.
NanoVM is a JVM targeting embedded systems based on the
AVR8 architecture \cite{Harbaum:2005}.
In the case of \lua, we have applied our method on the standard
\lua~implementation \cite{LuaSiteAbout}.
KESO is based on a generational approach, translating all \java~bytecode to C
and then to native code before the program execution, and also generating all
the JVM runtime needed by the application that is going to be used.
NanoVM performs bytecode interpretation over a
particular format of bytecode, which is optimized before program execution.
The standard \lua~implementation can either compile the source code while it is
running or previously. Then, it executes the compiled bytecode during program
execution.

% // Necessity of automation //
% \subsection{Necessity of automation}
% + Intro -> EBG
% + Vantagens EBG
As shown in Section \ref{sec:relat}, automating the generation process of a
binding code is desirable because it avoids programming errors on manually using
an FFI such as the parameter types and order of the methods and due to the
semantic differences between the two languages evolved in the FFI.
For this reason, the proposed method for abstracting hardware devices was
automated by a tool called \emph{Extensible Binding Generator} (EBG).

% + Fluxo completo
The Figure \ref{fig:ebg_complete_chain} presents the generation flow of a
system according to our proposal for abstracting hardware devices for MPLs in
the embedded system scenario.
The application, written using an MPL, is the main input for EBG.
Given that two distinct implementations of an MPL (e.g. KESO JVM and NanoVM for \java)
can have distinct FFIs, and the FFI cannot always be identified by analyzing the
application code, the FFI selection is another input for EBG.
From the application analysis, it is possible to identify the hardware mediators
that the embedded application is going to use.
EBG outputs the binding code already tailored for the target FFI,
and the MPL counterpart of the hardware mediators.

% TODO: trocar, na figura, VHLL por MPL. Talvez já o tenha feito em fig.git Conferir.
\figtwocolumn{.6}{ebg_complete_chain}{Binding code generation flow.}

The MPL counterpart of the hardware mediators is compiled together with the
application by a standard MPL compiler, generating the equivalent bytecode.
This bytecode can be externalized as is the case of the \emph{class} files of
\java~or can be directly send to the MPL interpreter, as is the default case for \lua.
The binding code generated by the EBG and the application bytecode are
then integrated to the runtime support system (usually a virtual machine) of the
target MPL.
Finally, the runtime support system of the MPL which includes EPOS and the
hardware mediators are compiled by GCC, generating the final system image.


% // Achieving Reuse //
\subsection{Achieving reuse between distinct FFIs}
% + O que sigfinica reuso e pq é importante.
The functional part of a binding code, which controls the hardware device,
is independent of the target FFI.
Therefore, it should be possible to reuse the functional part of a binding for
distinct FFIs.
% + Fatoração func / Não-func
In our approach, the reuse of a binding code among distinct FFIs is obtained by
factoring it out in a functional part (FFI independent) and
non-functional part (FFI dependent), and by composing these parts in order to
generate the final binding code which is going to be used by the target FFI.
The functional part of a binding code, responsible for hardware device control,
corresponds to a hardware mediator and its methods.
The non-functional part of a binding code, which is dependent of the target FFI,
corresponds to the methods and concepts defined by the API of the target FFI.
In our approach, the non-functional part is represented by aspects which
are used to describe FFIs API and rules.
The functional part (hardware mediator) is the component adapted by the FFIs
aspects, by an AOP weaving process, generating the binding code for the target
FFI.

% NOTA: nesse parágrafo eu afirmo algo forte, que não é demostrado depois...
Both hardware mediators and FFI descriptions are represented in our approach by
an intermediary representation based on the DERCS meta-model, described in
Section \ref{sec:relat}.
The main advantage of using the DERCS meta-model to describe hardware elements
and FFIs, rather than perform just syntactic transformations directly on source
code, is that DERCS provide us with data types with well defined semantics,
allowing for detect and fix semantic errors during binding code generation.

The structural and behavioral elements of DERCS are used to describe the
hardware mediators.
The aspect-oriented related elements of DERCS are used to describe the FFI
aspects.
Nevertheless, it is worth mentioning that not all DERCS elements where used for EBG
internal representation because the main focus of EBG is not on MDE.
Therefore, elements such as \emph{RuntimeElement} were left out.
Still, it is possible to integrate EBG in a MDE tool such as the \emph{GenERTiCA}
tool \cite{Wehrmeister:2009}, where the DERCS meta-model was primary used.

Another difference between the EBG and the original use of DERCS in
\emph{GenERTiCA} is related to the composition of aspects with structural and
behavioral elements.
As \emph{GenERTiCA} focus on MDE, the aspect weaving occurs during the phase of
system code generation.
In such case, the DERCS meta-model specifies which structural
and behavioral adaptations should occur in an abstract form.
However, the semantics of such adaptations are described by the rules
responsible for the mapping of model into code.
On the other hand, in EBG, the aspect weaving occurs at model-level.
Therefore, we have extended DERCS to support concrete structural and behavioral
adaptations with semantics defined at the model level.

Figure \ref{fig:structural_adaptation_extended} shows how we have extended the
structural adaptation \emph{StructuralAdaptation} of DERCS.
We have defined two new concrete types of structural adaptation,
\emph{DeclareParent} and \emph{AddAttribute}.
The semantics of \emph{DeclareParent} is to define a new superclass for the class
affected by the aspect.
In such way, the target class of the adaptation (the one affected by the aspect)
has its superclass changed to the class indicated by the attribute \emph{parent}
of \emph{DeclareParent}.
The adaptation \emph{AddAttribute}, when applied, adds a new attribute to the
target class of the adaptation.

\figtwocolumn{.4}{structural_adaptation_extended}{Extensions of DERCS's structural adaptation.}

Figure \ref{fig:behavioral_adaptation_extended} shows how we have extended the
behavioral adaptation \emph{BehavioralAdaptation} of DERCS.
We have defined two new concrete types of behavioral adaptation,
\emph{AddSendMessageAction} and \emph{AddReturnSendMessageAction}.
The adaptation \emph{AddSendMessageAction} adds behavior into a method's body.
More specifically, it adds a call action
(represented by the behavioral element \emph{SendMessageAction})
to a method bellowing to a certain class.
\emph{AddSendMessageAction} specifies the message to be added, the related
method, and the involved classes.
The adaptation \emph{AddReturnSendMessageAction} is identical to
\emph{AddSendMessageAction} except that, besides adding a message of call to a
method, it considers that such message is going to return a value, and this
value will be returned by the method affected by the aspect.
Either adaptations \emph{AddSendMessageAction} and
\emph{AddReturnSendMessageAction} can be applied at the beginning of a method's
behavior (\emph{BEFORE}), at the end (\emph{AFTER}), or they can totally
replace the method's behavior (\emph{AROUND}).

\figtwocolumn{.4}{behavioral_adaptation_extended}{Extensions of DERCS's behavioral adaptation.}


% + Parágrafo EBG internals: menciona módulos Weaver e Generator.
The Weaver module of EBG performs the composition of a hardware mediator and
FFI aspects (both represented using our adapted version of DERCS).
Figure \ref{fig:ebg_architecture} shows the internal organization of EBG.
Aspects of the selected FFI are applied for each mediator selected by EBG,
adapting the mediator to the FFI's API.
The output of the \emph{Weaver} module then enters in the \emph{Generator} module
which transforms the internal EBG representation in source code written in the
programming language required by the target FFI.

% TODO: trocar, na figura, VHLL por MPL. Talvez já o tenha feito em fig.git Conferir.
\figtwocolumn{.5}{ebg_architecture}{EBG architecture.}

% + Módulo Weaver
% Falar do Weaving em nível de DERCs
Algorithm \ref{algo:ebg_weaving} describes the weaving process performed by the
\emph{Weaver} module of EBG.
%
% NOTA: caso queira fazer um pseudo código.
\begin{algorithm}
\caption{Aspect weaving in EBG.}
\label{algo:ebg_weaving}
\begin{algorithmic}
\FORALL{$aspects \in model$}
\STATE $aspect \gets model.aspect$
\FORALL{$pointcuts \in aspect$}
\STATE $adaptation \gets pointcut.aspectAdaptation$
\STATE $joinpoints \gets pointcut.joinpoints$
\STATE $relativePosition \gets pointcut.relativePosition$
\STATE $adaptation.weave(joinpoints, relativePosition)$
\ENDFOR

\ENDFOR
\end{algorithmic}
\end{algorithm}

For each element of the model that should be affected (i.e. for each \emph{joinpoint}),
which is described by the aspect's \emph{pointcuts},
are applied all correspondent aspect adaptations.
As it is modeled, each \emph{pointcut} knows all elements of the model that
are going to be affected as it knows all aspect adaptations that should be
applied.
In such way, each aspect adaptation application over a model element is
performed by the invocation of the \emph{weave} method of the adaptation.
% ...modelo é realizada invocando-se o método \emph{weave} que aparece nas Figuras
% \ref{fig:structural_adaptation_extended} e
% \ref{fig:behavioral_adaptation_extended}, as quais apresentam as adaptações de
% aspectos criadas.

% OBA e CBA
During the elaboration of this work, we have identified two patterns used to
adapt a hardware mediator to the target FFI.
These patters were named \emph{Object-Based Adaptation} (OBA), and
\emph{Class-Based Adaptation} (CBA).
OBA and CBA define how the relation between the binding code and the hardware
mediator is going to be.
For the OBA pattern, the binding code class is going to aggregate the hardware
mediator class; thus a binding object is going to have a reference to a
hardware mediator object.
For the CBA pattern, the composition between binding code and hardware mediator
is performed by inheritance; thus a binding code class is going to extend a
hardware mediator class.

Figures \ref{fig:oba_pattern_application} and \ref{fig:cba_pattern_application}
illustrate in an abstract form (independent of the target FFI) the weaving
process using, respectively, OBA and CBA patterns.
Before executing any weaving, EBG performs a set of preparations using the
hardware mediator description (\emph{HW\_Mediator} class).
First, from \emph{HW\_Mediator} EBG generates the MPL counterpart of the hardware
mediator (represented by the \emph{MPL\_Mediator} class) which is going to have
all methods of the hardware mediator, but such methods will not have
implementation, they will be all marked as \emph{native}.
Also, from the analysis of \emph{HW\_Mediator}, EBG generates a skeleton for the
binding code class (represented by the \emph{NativeMediator} class) which has
the same methods as \emph{HW\_Mediator}, but also without implementation.

% TODO: trocar, na figura, VHLL por MPL. Talvez já o tenha feito em fig.git Conferir.
\figtwocolumn{.4}{oba_pattern_application}{Application of Object-Based Adaptation.}

% TODO: trocar, na figura, VHLL por MPL. Talvez já o tenha feito em fig.git Conferir.
\figtwocolumn{.4}{cba_pattern_application}{Application of Class-Based Adaptation.}

While weaving following the OBA pattern, after the weaving process, the
binding code class \emph{NativeMediator} is going to have a reference to the
hardware mediator \emph{HW\_Mediator}.
Such result is obtained applying the structural adaptation \emph{AddAttribute}
on \emph{NativeMediator}.
The reference to \emph{HW\_Mediator} is then used to implement the
\emph{NativeMediator}'s methods using \emph{AddSendMessageAction} adaptations,
according to the target FFI specifications.

Figure \ref{fig:oba_nanovm} shows the application of the OBA pattern using the
FFI aspects related to the NanoVM's FFI.
% DONE: Falar o que é a NanoVM.
Figure \ref{fig:oba_keso} shows the same for the KESO's FFI.
% DONE: Falar o que é a KESO JVM.
Both figures show the equivalent to the rightmost side of the
Figure \ref{fig:oba_pattern_application}, i.e.,
the result of the weaving process.
Looking at the implementation of the \emph{operation} method, it is possible to notice
(disregarding the differences that are FFI dependent)
that, in both cases,
the \emph{HW\_Mediator} \emph{operation} method is invoked through the
\emph{inner} attribute, which is a reference to the \emph{HW\_Mediator} object.

% Fig: oba_nanovm não precisava ocupar 2 colunas
\figtwocolumn{.4}{oba_nanovm}{Application of Object-Based Adaptation for NanoVM's FFI.}
% Fig: oba_keso não precisava ocupar 2 colunas
\figtwocolumn{.4}{oba_keso}{Application of Object-Based Adaptation for KESO's FFI.}

% TODO NOTA: de repente fazer uma figura de aplicação de CBA para Lua, ou outra
% MPL / FFI.
While weaving following the CBA pattern, after the weaving process, the
binding code class \emph{NativeMediator} is going to extend the
hardware mediator \emph{HW\_Mediator} class.
Such result is obtained applying the structural adaptation \emph{DeclareParent}
on \emph{NativeMediator}.
Then, the \emph{NativeMediator} methods are implemented using
\emph{AddSendMessageAction} adaptations, according to the target FFI.
In the case of CBA, the code snippet \emph{inner.operation} of Figures
\ref{fig:oba_nanovm} and \ref{fig:oba_keso} is replaced by
\emph{HW\_Mediator::operation} that represents the method inherited from
\emph{HW\_Mediator}.

% + Generator Module
% Continuando o fluxo do EBG...
% + Falar da geração para KESO e Lua
The output of EBG's \emph{Weaver} module is a set of binding code classes
already adapted to the target FFI.
However, those classes are still described using the internal representation of
EBG (the modified version of DERCS).
Then, the \emph{Generator} module of EBG is the responsible to transform those
binding code classes into source code that can be integrated to the runtime
environment of the target MPL.
The transformation process performed by the \emph{Generator} module is shown in
Algorithm \ref{algo:ebg_generation} and consists on the translation of methods'
bodies to the language expected by the target FFI, and on the applications of
one or more templates to format the generated code according to the rules of the
target FFI.

\begin{algorithm}
\caption{Binding code generation on EBG.}
\label{algo:ebg_generation}
\begin{algorithmic}
\FORALL{$method \in NativeMediator$}
\STATE $methodBody \gets toTargetLanguage(method.body)$
\STATE $bindingCode \gets templateFFI(methodBody)$
\STATE $write(bindingCode)$
\ENDFOR
\end{algorithmic}
\end{algorithm}

% NOTA: neste ponto acho que ainda não foi explicado como é a FFI do KESO
% e da NanoVM e de Lua.
% acho que dá para fazer estas explicações on the fly.
In the case of KESO, the output of the \emph{Generator} module of EBG is
composed by the \java~files containing, respectively, the \emph{weavelet} class
and the \java~counterpart class of the hardware mediator.
Then, the KESO compiler uses the \emph{weavelet} class to generate the
final system.
The \java~counterpart class of the hardware mediator is used by the application,
and it is compiled by a standard \java~compiler.
The resultant bytecode is then translated to C by the KESO compiler during the
system generation.

As an example of code generate by EBG to KESO's FFI,
Figure \ref{progjava:oba_keso} shows the main parts of the weavelet class.
It can be notice that the code snippet
\begin{verbatim}
return operation(inner, a, b);
\end{verbatim}
was generated from the \emph{operation} method's body of the, shown in
Figure \ref{fig:oba_keso}.
In such case, the EBG internal representation was translated to code written in
C language, specifying exactly the source code that is going to be generated by
the KESO compiler.
% NOTA: Estas questões de C/C++ ficaram, acho, "detalhativas" demais, muito coisa de implementação... 
As KESO translate \java~bytecode to C and in this specific case the generated
code is also in C rather than in C++, we have used a C to C++ wrapper in order
to access the methods of EPOS's hardware mediator which are written in C++.
This wrapper ``translate''
\begin{verbatim}
return operation(inner, a, b);
\end{verbatim}
into
\begin{verbatim}
return inner->operation(a, b);
\end{verbatim}
%
\progjava{oba_keso}{\emph{Weavelet} class of a generic hardware mediator.}
%
It is possible to notice in Figure \ref{progjava:oba_keso} the use of the OBA
pattern as the pointer \emph{inner} is one of the attributes of the generated
binding code class.

In the case of NanoVM and the \lua~VM, which are based on bytecode
interpretation and do not use a generation process as KESO, the output of the 
\emph{Generator} module of EBG is already the C++ code implementing the binding
code that is statically linked (compiled together) the respective VMs.
Also for those cases, the \emph{Generator} module generates the respectively 
\java~and \lua~files that represent the MPL counterpart of the mediator and can
be imported by the MPL application.
As NanoVM and \lua~VM we have used were already ported to C++, there was no need
of using C/C++ wrappers to interact with the mediators classes of EPOS.  


\subsection{Achieving performance and efficient resource usage}
% XXX TODO: Aqui não foi mencionado sobre os dois possívels cenários de
% disolução de mediador / performance: quando a MPL e a HLL possuem representações
% binárias iguais e diferentes.
% Acho que não mencionei antes por falta de espaço (paper SEES 2012).
% Mas se o paper é para journal acho que isso pode ser acrescentado aqui.
Ideally, the response time of a hardware device accessed using a binding code
should be the same than the response time obtained when accessing the same
device using languages such as C and C++.
As in the case of response time, the usage of resources, such as memory,
due to the use of a binding code should be kept at the minimum in order to
do not impact the overall resource usage of the system.

Performance and efficient resource usage is achieved by using the concept of
\emph{hardware mediators}, presented at Section \ref{sec:relat}.
Hardware mediators allow for the development of efficient binding code due two
reasons.
The first reason is related to the design of hardware mediators, since there is
a mediator for each device in the platform, the overhead caused
by monolithic HALs is eliminated.
The second reason is related to the techniques used to implement the hardware
mediators.
Using static metaprogramming techniques is possible to dissolve mediators among
the abstractions that use it, eliminating method call overhead for the
mediator methods.

%\subsection{Achieving platform portability}
%One of the options to provide for the binding code hardware device control is to
%implement the device driver inside the binding code.
%However, such option is totally platform dependent, as the device driver is
%specific for a platform thus, using such approach the binding code must be
%rewritten for each new platform available.

%A possible solution for the portability issue is by using a HAL.
%In such case, the binding code implements its methods by using the methods
%provided by the HAL.
%However, as identified at Section \ref{sec:relat}, in order to be suitable for
%embedded systems a HAL must eliminate unnecessary interdependency between
%devices (which occurs on monolithic HALs because they concentrate all the
%resources available in a platform) and also a HAL must be generated according
%to the application.

%Our approach relies on hardware mediators to provide for binding code
%platform portability.
%As shown at Section \ref{sec:relat}, hardware mediators provide the system with
%hardware abstractions in a modular and application-driven way.
%Besides that, as shown in Figure \ref{fig:native_code_adapter_and_hw_mediator},
%a hardware mediator provides a single interface, which can have several
%implementations.
%All methods of a binding code are built using the mediator interface
%thus, the binding code turns to be independent of hardware platform.

%\figtwocolumn{.4}{native_code_adapter_and_hw_mediator}{Relationship between binding code and hardware mediator}

\clearpage

% ------------------------------------------------------------------------------
