/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */

#include "global.h"
#include "domains.h"
#include "c1_Object.h"
#include "c5_PictureMotionEstimator.h"
#include "i14_NonCopyable.h"
#include "c4_DmecApp.h"
#include "c6_StringBuffer.h"
#include "c7_NativeTestSupport.h"
#include "c8_Math.h"
#include "c9_Throwable.h"
#include "c11_StringIndexOutOfBoundsException.h"
#include "c12_String.h"
#include "c10_RuntimeException.h"
#include "c13_DebugOut.h"
#include "c30_Picture.h"
#include "c31_PictureMotionCounterpart.h"
#include "c3_Task.h"
#include "keso_support.h"

#ifndef KESO_OMIT_SAFECHECKS
#ifndef NO_WRITE
#ifndef KESO_PRODUCTION
__const__ static char msg_null[] = "null pointer exception\n";

void 	keso_throw_nullpointer(const char* method, int bcpos) {
	write(1,msg_null,sizeof(msg_null));
	exit(-1);
}
#endif
#endif
#endif
#include "keso_support.h"

#ifndef NO_WRITE
__const__ static char msg_ioob[] = "index out of bounds exception\n";
void 	keso_throw_index_out_of_bounds(const char* method, int bcpos) {
	write(1,msg_ioob,sizeof(msg_ioob));
	exit(-1);
}
#endif


#define stop() while (1) { __asm__ __volatile__ ("nop"); } 

#ifndef NO_WRITE 
__const__ static char msg_impl[] = "method not implemented exception\n";
__const__ static char msg_excp[] = "unknown exception\n";
__const__ static char msg_err[] = "fatal error\n";

#ifdef DEBUG
__const__ static char assert_failed[] = "\nFATAL: assertion failed in ";
void keso_fatal_error(const char* msg, int line) {
	write(1,assert_failed,sizeof(assert_failed));
	write(1,msg,sizeof(msg));
	write(1,":",1);
	stop();
}
#endif

jint 	keso_throw_method_not_implemented(const char* method, int bcpos) {
	write(1,msg_impl,sizeof(msg_impl));
	stop();
}

void 	keso_throw_exception(object_t* obj, const char* method, int bcpos) {
	write(1,msg_excp,sizeof(msg_excp));
	stop();
}

void* 	keso_throw_error(const char *msg) {
	write(1,msg,strlen(msg));
	stop();
}
#else
void 	keso_throw_error() {
	stop();
}
#endif


object_t** unknown_task;

void keso_gc_walk_stack(object_t** stack, callback_fkt_t handleObj) {

	if (stack==(object_t**) KESO_EOLL) return; /* empty stack */

	stack = keso_unpackStackRef(stack);

	while (1) {
		/* skip nulls */
		if (*stack==NULL) {
			stack++;
			continue;
		}

		/* end of linked list */
		if (*stack==KESO_EOLL) return;

		/* follow up next frame */
		if (keso_isStackRef(*stack)) {
			stack=keso_unpackStackRef(*stack);
			continue;
		}

		/* process object reference */
		ASSERTCLASSID((*stack)->class_id);
		handleObj(*stack);
		stack++;
	}	
}


 __const__ code_t dispatch_table[] = {
};

/* use the CLASS(id) macro to access the class store! */
/* use the CLS_ROFF(id) macro to access the reference offset! */
class_t class_store[] = {
 /* 0 RESERVED */
 /* 1	java/lang/Object */
 {.size=sizeof(c1_Object_t), .roff=0},
 /* 2	[C */
 {.size=sizeof(jchar), .roff=0},
 /* 3	keso/core/Task */
 {.size=sizeof(c3_Task_t), .roff=0},
 /* 4	dmec_app/DmecApp */
 {.size=sizeof(c4_DmecApp_t), .roff=0},
 /* 5	dmec/PictureMotionEstimator */
 {.size=sizeof(c5_PictureMotionEstimator_t), .roff=0},
 /* 6	java/lang/StringBuffer */
 {.size=sizeof(c6_StringBuffer_t), .roff=1},
 /* 7	dmec/NativeTestSupport */
 {.size=sizeof(c7_NativeTestSupport_t), .roff=0},
 /* 8	java/lang/Math */
 {.size=sizeof(c8_Math_t), .roff=0},
 /* 9	java/lang/Throwable */
 {.size=sizeof(c9_Throwable_t), .roff=1},
 /* 10	java/lang/RuntimeException */
 {.size=sizeof(c10_RuntimeException_t), .roff=1},
 /* 11	java/lang/StringIndexOutOfBoundsException */
 {.size=sizeof(c11_StringIndexOutOfBoundsException_t), .roff=1},
 /* 12	java/lang/String */
 {.size=sizeof(c12_String_t), .roff=1},
 /* 13	test/DebugOut */
 {.size=sizeof(c13_DebugOut_t), .roff=0},
 /* 30	dmec/Picture */
 {.size=sizeof(c30_Picture_t), .roff=0},
  /* 31	dmec/PictureMotionCounterpart */
 {.size=sizeof(c31_PictureMotionCounterpart_t), .roff=0},
};
/* global strings */
struct str4_s {
ARRAY_HEADER
jchar data[5];
};
struct str8_s {
ARRAY_HEADER
jchar data[9];
};
struct str27_s {
ARRAY_HEADER
jchar data[28];
};
static struct str4_s str2_arr HEAP_SECTION ={
.class_id=CHAR_ARRAY_ID, .gcinfo=1,.size=4,
.data={110,117,108,108,0}
};
c12_String_t HEAP_SECTION str2={
.c12f1_value=(object_t*)&str2_arr,.class_id=C12_STRING_ID, .gcinfo=1
};
static struct str8_s str1_arr HEAP_SECTION ={
.class_id=CHAR_ARRAY_ID, .gcinfo=1,.size=8,
.data={100,111,110,101,58,32,79,75,0}
};
c12_String_t HEAP_SECTION str1={
.c12f1_value=(object_t*)&str1_arr,.class_id=C12_STRING_ID, .gcinfo=1
};
static struct str27_s str0_arr HEAP_SECTION ={
.class_id=CHAR_ARRAY_ID, .gcinfo=1,.size=27,
.data={68,77,69,67,32,65,80,80,32,102,111,114,32,75,69,83,79,32,105,115,32,97,108,105,118,101,33,0}
};
c12_String_t HEAP_SECTION str0={
.c12f1_value=(object_t*)&str0_arr,.class_id=C12_STRING_ID, .gcinfo=1
};

/* translation callbacks */
void keso_check_array(object_t* arr, jint index, const char* msg, jint bcPos) {
	KESO_CHECK_NULLPOINTER(arr, msg, bcPos);
	if (unlikely(((array_t*)arr)->size<=(array_size_t)index)) keso_throw_index_out_of_bounds(msg, bcPos);
}
char keso_epos_d_dom1_heap[1024] ALIGN4 HEAP_SECTION ;
keso_stack_t* keso_stack_index[KESO_MAX_TASK+1];

/* Task management */
c4_DmecApp_t HEAP_SECTION keso_epos_d_dom1_t_task1_obj={
.class_id=C4_DMECAPP_ID, .gcinfo=1,
._domain_id=0x0,
._e_domain_id=0x0,
._task_id=keso_epos_d_dom1_t_task1,
};
c3_Task_t* keso_task_index[KESO_MAX_TASK];
KESO_TASKCLASSTYPE *keso_curr_task;


/* Returns a pointer to the currently running Task
 * INVALID_TASK is assumed to be greater by one than
 * the highest TaskID. This is ProOSEK specific and
 * will likely not work on other OSEK implementations.
 * keso_task_index is initialised with NULL, which
 * represents the INVALID_TASK Java-Task object.
 */
KESO_TASKCLASSTYPE *keso_curr_task_fkt() {
	TaskType taskID;
	GetTaskID(&taskID);
	return keso_task_index[taskID];
}


