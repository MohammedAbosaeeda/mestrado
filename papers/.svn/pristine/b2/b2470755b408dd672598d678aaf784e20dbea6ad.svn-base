\documentclass[times,10pt,twocolumn]{article} % ETFA 2011
\usepackage{latex10_Bilbao} % ETFA 2011
\usepackage{times} % ETFA 2011

% \usepackage[latin1]{inputenc}	% for Latin languages
% \usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support

\usepackage[utf8]{inputenc} % for use utf8
\usepackage{graphicx}

% -----------------------------------------------------------------------------

% Command to use code as figure -----------------------------------------------
\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinestyle{prg} {basicstyle=\small\sffamily, lineskip=-0.2ex, showspaces=false}

\newcommand{\prgcpp}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=C++,style=prg]{fig/#2.cc}
   \caption{#3\label{prg:#2}}
 \end{figure}
}

\newcommand{\prgjava}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=Java,style=prg]{fig/#2.java}
   \caption{#3\label{prgjava:#2}}
 \end{figure}
}

\newcommand{\prgkcl}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=C++,style=prg]{fig/#2.kcl}
   \caption{#3\label{prgkcl:#2}}
 \end{figure}
}

\newcommand{\oclspec}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=C++,style=prg]{fig/#2.ocl}
   \caption{#3\label{oclspec:#2}}
 \end{figure}
}


%------------------------------------------------------------------------------

% Commands to insert figures --------------------------------------------------
\newcommand{\figu}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

\newcommand{\fig}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}
% fig usage:
% \fig{<scale>}{<file>}{<caption>}
% e.g.: \fig{.4}{uml/uml_comportamental_dia}{Diagramas comportamentais da UML}
% The figure label will be "fig:" plus <file>.
% The figure file must lie in the "fig" directory.

\newcommand{\figtwocolumn}[4][ht]{
  \begin{figure*}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure*}
}

\newcommand{\figb}[4][hb]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

%------------------------------------------------------------------------------

\begin{document}

\title{Providing embedded Java with hardware devices}


\author{Mateus Krepsky Ludwich and Antônio Augusto Fröhlich\\
Laboratory for Software and Hardware Integration -- LISHA\\ Federal University of Santa Catarina -- UFSC\\ 
P.O.Box 476, 880400900 - Florianópolis - SC - Brazil\\
\{mateus,guto\}@lisha.ufsc.br
}


\maketitle
\thispagestyle{empty} % ETFA 2011

\begin{abstract}
Very high-level languages facilitate the development of embedded systems since
they provide features such as automatic memory management, memory protection, 
and reflection. At the same time implementation of these languages targeting 
embedded systems must attend the classical requirements of these systems. Among
these requirements is the frequent access to hardware devices such as sensors 
and actuators for interacting with the environment where the embedded system is
inserted on. Furthermore these implementations must attend restrictions of 
memory consumption, time, and energy imposed by embedded systems. 
 
In this paper we introduce a way to interface hardware components with embedded
Java applications. This interfacing is achieved using the foreign function 
interface of KESO Java Virtual Machine that does the binding between Java 
methods and C functions at compile-time. Using EPOS to support KESO execution, 
we provide a portable and economical way to run Java applications. 
We have evaluated our proposal in terms of performance, portability, and 
memory footprint. We also have developed Java bindings for a component for 
motion estimation in H.264 video coding, demostrating the usability of our 
approach in a ``real-world'' scenario.
%
%
%Using our Java binding approach, we 
%
%also have developed a component for motion estimation in
%H.264 video coding using our Java binding approach, demostrating it is usefull
%in a ``real-world'' scenario.
%
% We have 
% obtained a total footprint of less then 33KB, including the application and the
% runtime support system. Besides that, we have demonstrated that KESO FFI is an
% adequate mechanism for implementing interaction with hardware devices, 
% achieving a low time overhead when compared to other solutions.
\end{abstract}

% \category{D.3.3}{Programming Languages}{Language Constructs and Features}[Classes and objects]
% \category{D.3.4}{Programming Languages}{Processors}[Run-time environments]
% \category{D.4.4}{Operating Systems}{Communications Management}[Input/output]
% \category{D.4.7}{Operating Systems}{Organization and Design}[Real-time systems and embedded systems]
%
% \terms
% Design, Languages, Reliability
% 
% \keywords
% Java, Embedded Systems, Foreign Function Interface

%------------------------------------------------------------------------------
% Section <Introduction>
\section{Introduction}
Java implementations that have embedded systems as targets must provide 
developers with a way to control hardware devices. This is highly desirable 
since embedded system applications run close to the hardware in the sense that
they use hardware devices such as sensors and actuators to interact with the 
environment, transmitters and receivers for communication, and timers for real
time operations. At the same time, Java applications for embedded systems must
have a footprint according to the memory constraints imposed by many embedded 
systems.

Foreign Function Interface (FFI) like the \emph{Java Native Interface} is the 
mechanism used by Java platforms to access hardware devices and memory. 
In fact, several Java packages such as java.io, java.net and java.awt are 
implemented using FFI facilities \cite{Liang:1999}. However, as we will explain
in section \ref{sec:related_work}, the main FFIs provided by Java have 
limitations to deal with embedded systems, because they are too onerous or 
because of design limitations.

This work demonstrates how we interface hardware components to Java 
applications. The Embedded Parallel Operating System (EPOS) abstracts hardware
devices as components which a well-defined interface. Using the Foreign
Function Interface of KESO Java Virtual Machine (JVM) we create the binding
between these components and their Java counterparts abstractions. 

EPOS \emph{hardware mediators} sustain an interface contract between system
abstractions (e.g. threads) and the machine allowing for these abstractions
machine-independence. \cite{Polpeta:2004}. Since there is a mediator for each
hardware device being abstracted, providing Java with these mediators allows a
fine-grained control of hardware devices.

KESO JVM focuses on embedded systems and uses an ahead-of-time compilation
strategy to translate programs from Java bytecode to C. The KESO FFI also uses
a static approach generating the specified C code to native methods.

Our work focuses on application-driven, statically-configured, and deeply 
embedded systems. Which means, embedded systems designed to execute a single
application, where all the resources the application will need are known at
design time. With this in mind, we can optimize the system generation, for
example generating only the hardware components needed by the application.
In this scenario features such as reflection and dynamic class loading can be
also removed from the JVM.

The contributions of this paper include an method to support the 
development of class libraries witch elements are abstractions to access 
hardware devices, and experimental results exploring the use if this
method to develop Java bindings for a Motion Estimation component for 
H.264 video encoding.

The next sections of this paper are organized in this way: 
section \ref{sec:related_work} presents related works encompassing 
hardware/software interfacing for Java, and approaches for wrappers generation.
Section \ref{sec:keso} presents the KESO Java Virtual Machine and its main 
concepts, including KESO FFI. 
We present our approach to interface hardware components with Java applications
in section \ref{sec:proposal}.
We evaluate our approach in section \ref{sec:eval} in terms of performance,
memory footprint, and applicability.
Section \ref{sec:case_study} presents a Motion Estimation component for H.264
encoding as an example of ``real-world'' application. 
Our final considerations are presented in section \ref{sec:discussion}.


% -----------------------------------------------------------------------------
% Section <Java requirements for embedded systems>
\section{Related work}
\label{sec:related_work}
Our work encompass the issue of supporting direct hardware access from Java and
to provide this support in a well structured way while keeping in mind all the
requirements of the embedded systems scenario.

The Java programming language does not provides the concept of \emph{pointer}
like C and C++ does. The address of \emph{reference variables},
used to access Java objects, is just known by the Java Virtual Machine that 
handles all memory accesses. As major hardware devices are mapped in memory 
addresses, direct access to them is an issue to Java language. Foreign 
Function Interface (FFI) is the approach used by Java to overcome this
limitation since it allows Java to use constructions, such as C/C++ pointers, 
to direct access hardware devices. 
FFIs have also been used by Java platforms to reuse code written in other 
programming languages such as C and C++ and to embed JVMs into native 
applications allowing them to access Java functionality (\cite{Liang:1999}, \cite{1288968}).

\emph{Java Native Interface} (JNI) is the main Java FFI, which is used in 
\emph{Java Standard Edition} platform (JSE) \cite{Liang:1999}. In JNI, the 
binding of native code is performed during runtime. Which means, the JVM
searches and load into itself the implementation of methods marked as 
\emph{native}. Usually the implementation of native methods is stored in a 
dynamic library. This search and loading mechanism increase the need for 
runtime memory and increase the JVM size. Because of that, they are avoided in
embedded systems.

The \emph{Java Micro Edition} (JME) platform uses a lightweight FFI, called 
\emph{K Native Interface} KNI \cite{_k_2002}. KNI does not dynamically load 
native methods into JVM, avoiding the memory overhead of JNI. In KNI the 
binding between Java and native code is performed statically, during compile 
time. However the design of KNI imposes some limitations. KNI forbids creating
new Java objects (other than strings) from the native code. 
Besides that, in KNI the only native methods that can be invoked are the ones 
pre-built into the JVM. There is no Java-level API to invoke others native 
methods. By consequence, it is difficult to create new hardware drivers using
KNI.

KESO FFI, presented in section \ref{sec:keso}, focuses on embedded systems. 
Like KNI, KESO FFI does not perform dynamically loading of native methods. 
But unlike KNI, KESO FFI provides for the programmer a Java-level API to create
new native code bindings. Also there is no problem of native code calling Java
code since KESO and KESO FFI generate C code.

The task of writing binding code can be facilitate in two ways: by having an 
high level API to create bindings, and by using tools to automatically 
generating them (partially or completely). 
SWIG and Python's foreign function library \emph{ctypeslib} are examples of tools 
whose take as input C/C++ header files and generate wrappers based on this 
input. The former supports several languages as output such as Python, D, 
and Java. The later focuses on Python programs\cite{swig-site},\cite{ctypeslib-site}.
Ravit et al. present a tool which aims to utilize high level features of the 
host language to be used in the binding code. Their tool generates Python 
bindings taken as input C code and interface descriptions containing, 
for example, information about functions and their parameters \cite{Ravitch:2009:AGL:1542476.1542516}.
Other solutions, such as \emph{Jeannie} language, mix C and Java code into a 
single program and automatically generates JNI wrappers from it \cite{1297030}.
KESO FFI, used in this work, provides an Aspect-Oriented based API to help on
the wrappers creation. It is possible to specify which points of the Java
program will be affected by the binding creation as which code should
be generated for each point been affected.

The binding code can be checked for correctness and bug detection. Tools such 
as J-BEAM and Ilea perform bug checking based on the source code, using static
analysis techniques\cite{jbeam:2008}, \cite{Ilea:2007}.
Lee et al. deal with bug detection dynamically, when the FFI code is been 
used \cite{Lee:2010:JSD:1809028.1806601}.
Their tool Jinn synthesizes dynamic bug detectors for FFIs from Finite State 
Machines whose encode FFI constrains that should be tested. The FFI targeted 
for the Java language is the JNI which contains hundreds os API calls. 
Although not aborted by this paper, similar bug detectors can be adapted to 
check bindings generated using the KESO FFI.


% -----------------------------------------------------------------------------
% Section <KESO>
\section{KESO java virtual machine}
\label{sec:keso}
KESO is a multi-Java Virtual Machine (JVM) that focuses on embedded devices and 
networks of micro controllers \cite{Wawersich:2007}. KESO relies on the 
OSEK/VDX operating system \cite{osek-vdx_portal}. OSEK/VDX organization 
specifies standards for automotive systems, including the operating system 
standard used by KESO. Because KESO is based on OSEK, it exports the concepts 
of this operating system to Java applications, including statically allocated 
tasks, scheduling policies, interrupt and event mechanism, and communication
\cite{osek_spec223}. Figure \ref{fig:keso_architecture}, taken from 
\cite{Stilkerich:2006}, shows KESO architecture and its main concepts.

\fig{.4}{keso_architecture}{KESO architecture \cite{Stilkerich:2006}}

% Tasks
Tasks are the schedulable unit on OSEK systems. They have fixed priority and 
are allocated statically during the system generation. KESO uses the concept of
OSEK Tasks as a substitute for Java Threads. It is well suited since KESO
focuses on static embedded systems, which allocate resources that will be used
by the system application during design time.

% Domains
Although not explored in this work, KESO can be used as a distributed system
composed by \emph{domains}. A domain appears to the application developer as
a self-contained JVM which has its own heap and static class fields. KESO is
called \emph{multi-JVM} just because of that. A task in KESO just belongs to
one domain and, like all other types of objects, cannot cross domain 
boundaries.
The concept of domain was first introduced by JX \cite{713870} and is a way in
which to perform memory protection in software that can be used when the target
platform is absent of the memory protection unit (MPU) and memory management 
unit (MMU).

% Portals
Inter-domain communication is performed using \emph{portals}. A domain can
provide a \emph{portal service} that consists of a Java interface that offers
\emph{services} to other domains. A task from another domain can import the 
offered service using a global name service.

% Code Generation
KESO JVM overcomes the byte code interpretation overhead compiling byte code into C code in an ahead-of-time fashion 
(i.e. before the program execution).Figure \ref{fig:keso_sys_gen}, taken from \cite{Wawersich:2007}, shows this process. Java application source files and KESO class library are compiled to byte code using a standard Java compiler. Then, the \emph{KESO Builder} translates the class files into C source files and also generates the C source files corresponding to JVM features that will be used by the application (e.g. garbage collector). During the process, KESO Builder analyzes the bytecode and eliminates classes, methods, and fields not accessed by the application and eliminates, when possible, virtual method calls.

\fig{.4}{keso_sys_gen}{System Generation Process \cite{Wawersich:2007}}

% KESO FFI
KESO provides a Foreign Function Interface (FFI) for interfacing with C and C++ code. KESO FFI uses a static approach like Sun's KNI (see section \ref{sec:related_work}), binding Java and native code at compile time. The Foreign Function Interface of KESO is called \emph{KESO Native Interface (KNI)}, but in this paper we refer to it as KESO FFI, to avoid confusions with Sun's KNI.

% AOP concepts
The design of KESO FFI has adopted some concepts of Aspect-Oriented Programming (AOP) \cite{Kiczales97aspect-orientedprogramming}. Using the KESO FFI API it is possible to ``write'' \emph{point cuts} specifying the \emph{join points} of a Java program (such as Java methods and classes) that will be affected by the given \emph{advices}. The advices in this case, are the codes that represent the native method implementation. The \emph{aspects} that group together \emph{point cuts} and \emph{advices} are represented in KESO FFI API by a \emph{Weavelet} abstract class. Extending the \emph{Weavelet} class and implementing some of its methods it is possible to specify which Java classes and methods should be affected and which native code should be generated. The class figure \ref{fig:weavelet_extension_generic} illustrates this process.

\fig{.2}{weavelet_extension_generic}{Using KESO FFI}

% Optimization questions
The KESO FFI is integrated with the KESO compiler so, during the compilation of Java bytecode to C, instances of weavelets classes are created and used for generating the native code. Although the code specified by a weavelet is not subject of the static analysis performed by the KESO compiler, KESO FFI still presents some interesting advantages. For example, if the KESO compiler identifies that the application code does not use some native method it does not generate the native code for that method, reducing the memory needs.

% Memory-Mapped Objects
Another concept of KESO FFI is the \emph{Memory-Mapped Objects} \cite{Thomm:2010:KOM:1850771.1850788}. A memory-mapped object is a Java object that when created can point to a specific region of the system memory. These kinds of objects are useful to implement direct access to hardware registers.

% System OSEK generation
The OSEK specification states that the operating system's components used by 
the application, such as tasks, alarms, and counters, are automatically generated
from a configuration file. This configuration file is written using \emph{OSEK 
Implementation Language} (OIL). KESO uses a similar configuration file written
using \emph{KESO Configuration Language} (KCL). As shown in figure 
\ref{fig:keso_sys_gen}, KESO Builder takes a KCL file and generates an OIL file
from it. Then the OIL file can be used to generate the OSEK components needed 
by the application.

% -----------------------------------------------------------------------------
% Section <proposal>
\section{Interfacing hardware devices with very high level languages}
\label{sec:proposal}
One of the main issues of languages that aim to be used for embedded systems 
development is to access hardware devices. This is highly desirable, since 
embedded systems often use hardware devices to interact with the environment 
where they are inserted on.
Our proposal to interface very high level languages with hardware devices is 
based on exporting these devices to the API of the language. The hardware 
devices to be exported have a well defined interface, using the 
\emph{hardware mediator} concept of EPOS. We have used the Foreign Function 
Interface of KESO JVM in order to export EPOS mediators to Java. This section
explains how we have abstracted hardware components to be used by embedded Java
applications. The approach utilization is exemplified by abstracting to Java
an Universal Asynchronous Receiver Transmitter (UART) hardware device.

\subsection{Hardware devices access}
EPOS uses the concept of \emph{hardware mediators} in order to abstract 
specificities from different hardware devices. 
\emph{Hardware mediators} sustain an interface contract between system 
abstractions (e.g. threads) and the machine allowing for these abstractions 
machine-independence. \cite{Polpeta:2004}. 
The generation of the mediator implementation for a specific machine is 
performed at compile time. Using static meta-programming techniques and 
function's inlining is possible to dissolve mediators among the abstractions 
that use it, which avoids time overhead in the use of mediators.

We have used KESO FFI to create a binding for each EPOS mediator that should be
accessed by Java, providing Java with hardware components. The approach used is
shown in figure \ref{fig:accessing_hw}. The Java class, which represents the
Java counterpart for the hardware mediator been abstracted, specifies methods
signatures but no method implementation (since they represent native methods).
Then, a weavelet class of KESO FFI is used to specify the implementation for 
each native method. More specifically, the weavelet class specifies which 
methods of the Java class we would like to intercept (pointcuts) and the 
respective code that should be generated (advices). 
During the translation of Java bytecode into C, the KESO compiler ``wove'' the
methods of the Java class with the advices specified by the weavelet, 
generating the \emph{binding code} which performs the interface between the 
Java class and the EPOS hardware mediador.

\fig{.2}{accessing_hw}{Accessing hardware devices}
The implementation of each native method, specified in the weavelet, 
is basically a call to each method of the EPOS mediator been interfaced.
On the implementation of the method \emph{affectMethod} 
(\emph{Weavelet} interface) is possible to specify a pattern to be matched 
which represents, for example, a method signature. Its is also possible to
specify which code should be generated when the KESO compiler finds the match 
specified by the pattern. 
Listing \ref{prgjava:weav_uart_put} shows the binding specification for 
a virtual method called \emph{m1} which has one parameter of the type character
and have no return (\emph{void} type). 
The \emph{eposHWMediator} is a field of the binding class
which points to the actual hardware mediator of EPOS. Adding fields to binding classes
is possible by implementing the \emph{addFields} method of \emph{Weavelet} interface.

EPOS objects allocated by a binding object, such as \emph{eposHWMediator}, which is
allocated when one calls \emph{new} on the Java side are 
deallocated on the \emph{finalizer} method of such Java class. As is possible to
use deterministic algorithms for the KESO garbage collector there is a guarantee
that finalizers are called.

\prgjava{weav_uart_put}{Specifying the binding code}

\subsection{UART example}
We wrote a small application using the UART hardware mediator to
illustrate our proposal of abstracting hardware devices to embedded Java.
The application, shown by the listing \ref{prgjava:application}, uses the UART
to write characters on a serial device.
\prgjava{application}{UART example}

The Java \emph{UART} class is the Java counterpart abstraction for the UART
hardware mediator of EPOS and has only native methods without any implementation. 
The \emph{UART\_Weavelet} is used to specify the implementation for each 
\emph{UART} method. The approach used is the same shown by the listing \ref{prgjava:weav_uart_put}.
Figure \ref{fig:overall_uart_application} shows the main classes used in our 
UART example distinguishing code written in Java (classes under the dark gray area)
from classes written in C/C++ (classes under the light gray area). As one can 
see, the Java classes correspond to almost all the code written, including the 
application class \emph{UART\_Test}, the \emph{UART} class on the Java side, 
and the \emph{UART\_Weavelet}. 

\figtwocolumn{.3}{overall_uart_application}{Overall UART example}


% -----------------------------------------------------------------------------
% Section <Evaluation>
\section{Evaluation}
\label{sec:eval}
We evaluate our proposal of interfacing hardware devices with Java, 
described in section \ref{sec:proposal}, in terms of performance, 
portability, and memory footprint.
In ours experiments, we have used the UART example mentioned in section 
\ref{sec:proposal}, and a component for Motion Estimation in H.264 
video encoding. This section describes the results for the UART mediator.
Section \ref{sec:case_study} describes in details the Motion Estimation component as
the obtained results for it.

\subsection{Performance}
A binding to interface very high level languages and hardware devices 
(i.e. FFI) should interferer as less as possible on the original response time
of such devices otherwise, its utilization can become impractical.
In order to evaluate the proposal of section \ref{sec:proposal}, we have
measured the response time of the device been analyzed while using it 
directly (e.g. by a C++ application), and using it through ours Java bindings. 
We call \emph{DeviceTime} the 
original response time which is composed by the time of the EPOS mediator plus
the time of the physical device. The \emph{TotalTime} adds to the
\emph{DeviceTime} the response time of the native method, 
including the call to the method and the method's return. 
With this concepts in mind, the time overhead generated by a FFI can be 
described by equation \ref{eq:time_overhead}.
\begin{equation}
\label{eq:time_overhead}
FFI\_Overhead (\%) = \left ( 1 - \frac{TotalTime} {DeviceTime} \right ) \times 100
\end{equation}

We have measured the total and the device time of the UART's put method. 
The method was called 10 thousand times in an application's execution, and the
application was executed 30 times. We have used EPOS's \emph{time stamp clock} 
to compute the time. The obtained overhead, according to equation \ref{eq:time_overhead} 
corresponds to less than 0.04\% of the total execution time.

In order to estimate the relevance of the overhead value, we reproduce the UART
experiment using Java Standard Edition which uses the Java Native Interface as
FFI. 
We have used the \emph{RXTX} \cite{site:RXTX} library which implements the 
\emph{Java Communications API} \cite{site:JavaCommAPI}, used for communicating 
with serial devices. 
The function \emph{gettimeoftheday} was used to compute the device time, and 
the Java \emph{System.nanoTime} method was used to compute the total time. 
Table \ref{tab:time_overhead} shows the obtained values as the values obtained
while using our proposal.

The JNI based application presents an overhead of 1.5\% which is about 38 times
grater than the overhead obtained using your approach. 
Considering an application that must send a byte every 420$\mu s$ and 
considering that a UART takes 417$\mu s$ to sent a byte (bound rate of 19200),
an overhead of 1.5\% (6.25$\mu s$) would compromise the data transmission,
leading to deadline misses in an real-time application.

\begin{table}[t]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{} & \textbf{Total($\mu s$)} & \textbf{UART($\mu s$)} & \textbf{FFI Overhead(\%)}\\
\hline
Proposal & 517.74 & 517.54 & 0.04 \\
\hline
JSE & 8364683.74 & 8238695.07 & 1.5 \\
\hline
\end{tabular}
\caption{FFI time overhead}
\label{tab:time_overhead}
\end{center}
\end{table}

\subsection{Portability}
Our Java bindings support to kinds of portability: platform portability, and
software/hardware portability.

Since a Java binding developed using our approach rely on the concept of 
EPOS hardware mediators and the latter provides an machine-independent 
interface, the former can potentially exists in all architectures and machines
for which EPOS has a port.

By software/hardware portability we meant that the same Java binding can be 
used either for a software or hardware implementation of the component been
wrapped. This is possible due to the concept of \emph{hybrid components}
realized by EPOS, where the component preserves the same interfaces either in
its software or hardware implementation~\cite{Marcondes:IESS:2009}.

\subsection{Memory footprint}
The binding code to wrap a hardware mediator should impact as less as possible
on the code and data memory needed by the application to execute.
In order to estimate the memory overhead generated by our approach, we have 
measured the footprint of the binary image containing the whole system and the 
footprint specifically related for creating a Java binding.

Table \ref{tab:space_overhead} shows the obtained values for the UART example,
which as developed for IA32 and Power PC32 architectures. 
The whole system size including the application, KESO JVM, and EPOS runtime has
less than 33KB in both architectures, a suitable value for many embedded 
hardware platforms.

\begin{table}[t]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{} & \textbf{IA32(byte)} & \textbf{PPC32(byte)} \\
\hline
text & 28645 & 30504 \\
\hline
data & 1180 & 1198 \\
\hline
bass & 1264 & 840 \\
\hline
total & 31089 & 32542 \\
\hline
\end{tabular}
\caption{Total footprint}
\label{tab:space_overhead}
\end{center}
\end{table}

% -----------------------------------------------------------------------------
% Section <Real-word application>
\section{Real-world application}
\label{sec:case_study}
In order to evaluate our proposal in an ``real-world application'' we have 
develop a Java component which computes Motion Estimation (ME) for H.264 video
encoding. Motion Estimation is used to explore the similarity between
neighboring frames in a video sequence, thus enabling them to be differentially
encoded, improving the compress ratio of the generated bitstream 
\cite{citeulike:1269699}. ME is an significant stage for H.264 encoding, since
it consumes around 90\% of the total time of the encoding process
\cite{XiangLi:2004}.

In order to improve the performance of ME, our component uses a data
partitioning strategy, here the motion estimation for each partition of the
picture is performed in parallel by a \emph{Worker} module which executed in a
specific functional unit, such as a core of a multicore processor. There is 
also a \emph{Coordinator} module, responsible to define the picture partition
for each \emph{Worker} and to provide them with pictures to be processed. 
The \emph{Coordinator} is also responsible to gather results generated by
\emph{Workers} (motion cost and motion vectors) and to delivery these results
back to the encoder. Figure \ref{fig:threads} illustrates the interaction
between \emph{Coordinator} and \emph{Workers} modules.

\figtwocolumn{.3}{threads}{Interaction between Coordinator and Workers}

Our component is called \emph{Distributed Motion Estimation Component} (DMEC), since 
the computation of ME is performed in parallel by \emph{Workers} modules.
However, this complexity is hidden from the Java application (e.g. H.264 encoder),
which only sees a component for ME computation performed by a \emph{match}
method. The DMEC is implemented as a C++ component and it is 
exported to Java using the strategy presented at section \ref{sec:proposal},
where is developed a Java binding for each object been abstrated. 

Currently DMEC is implemented by software components, where \emph{Coordinator}
and \emph{Workers} are threads running on distinct cores of a muticore processor.
In spite of that, DMEC can be implemented by hardware components preserving the
same interfaces available in the software version. We can achieve this by using
the concept of EPOS hybrid components \cite{Marcondes:IESS:2009}. In that case
our Java wrappers also remain the same. In a hardware implementation scenario
\emph{Coordinator} and \emph{Workers} are IPs of a 
Multiprocessor System-on-Chip (MPSoC) and the communication between them is
performed by the on-chip interconnection, such the ones described by 
\cite{Javaid:2010:OSL:1878961.1878978},\cite{Popovici:2009:FAC:1509633.1509681}.

We have written a 100\% Java application to use our DMEC component. 
From the ME point of view, the developed application plays the role of the H.264
encoder: it provides DMEC with the frames to be processed and it uses the 
results delivered by the component checking if they are correct.
Listing \ref{prgjava:app} shows the main method of the application. The DMEC
is used as an usual Java object.

\prgjava{app}{DMEC Java application}

% Dizer os resultados
% // + Evaluation
% 
% Avaliações específicas do encoder ME na seção de estudo de caso mesmo.
% - More general: How many frames per second our component process? 
% (comparation with JM encoder)
% 
% - More specific: Time overhead of wrappers 
% (comparation with JNI, and others) pode ficar na secão anterior, não?
%
% TODO: Dizer os resultados. 
% \begin{itemize}
% \item Tempo de processamento dos frames. (Maybe comparation with JM encoder)
% \item Time overhead of wrappers (comparation with JNI, and others)
% \item Application size and footprint
% \end{itemize}

% -----------------------------------------------------------------------------
% Section <Discussion>
\section{Discussion}
\label{sec:discussion}
Applications for embedded systems usually have the necessity to interact
with several kinds of hardware devices such as sensors, actuators, transmitters,
receivers, and timers. 

Foreign Function Interface is the way adopted by Java to overcome language
limitations and allows for direct memory and hardware devices access. However,
as we showed in section \ref{sec:related_work}, the main Java FFI solutions 
does not provide developers with a resource-efficient way to interfacing with
hardware devices or impose design limitations to this interface.

In this paper, we have shown a way to interface hardware components with
Java applications for embedded systems. This was achieved using the foreign
function interface of KESO JVM and EPOS.

EPOS provides for a portable way to interfacing hardware devices with user
applications. This is accomplished by using the concept of hardware mediators
which sustain an interface contract between system abstractions and the machine.

KESO JVM compiles the bytecode of a Java application to C code and generates 
the parts of JVM needed by the application. The KESO FFI also uses this static
approach generating C code specified by \emph{Weavelet} classes. Then, the C codes
generated by the KESO compiler and by KESO FFI are compiled together to native code
using a standard C compiler. 

We have evaluated our approach in terms of performance, portability, and 
memory usage. For an application using the UART hardware mediator
the generated time overhead is less than 0.04 \% of the total execution time
and our solution is 37 times faster than Sun's JNI. The memory footprint 
for such application was of 33KB, including all runtime support, which is 
suitable for many embedded systems. Using EPOS we can achive portability to
several hardware platforms, and using the conpect of hybrid components we
can use the same Java bindings either for components implemented in hardware
or software.

In order to evaluate our approach in a ``real-world application'' we have 
written Java bindings for a component which performs Motion Estimation for 
H.264 video encoding.

% -----------------------------------------------------------------------------
% References
\bibliographystyle{latex10_Bilbao}
\bibliography{hw,os,pl,mm}


\end{document}

%------------------------------------------------------------------------------

