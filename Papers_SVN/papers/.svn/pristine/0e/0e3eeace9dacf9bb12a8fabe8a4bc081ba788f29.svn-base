% ------------------------------------------------------------------------------
\section{Case study} \label{eval}
% = Case Study An operating system scheduler: EPOS's scheduler.
% 
% = Remember the design of EPOS's scheduler: queue managing independent from
% scheduling policy.
% 
% = Remember that the same scheduler implementation can be synthesized
% either in hardware or software.
%
% = Show the scheduler's contract.
% 
% = Shows what we did to adapt the scheduler for verification.
% 
% = Show the results.
% 
% ----

% = Case Study An operating system scheduler: EPOS's scheduler.
We have used the scheduler of EPOS
\cite{Froehlich:2001} as a case study for our proposal, showing that it follows
its formal contract.
% 
% = Remember the design of EPOS's scheduler: queue managing independent from
% scheduling policy.
As shows Figure \ref{fig:epos_scheduler}, in the design of the EPOS's scheduler,
queue management is independent from scheduling policy
\cite{Marcondes:2009:EPS}.
Furthermore, the scheduler itself is independent from the object it schedules.
In the case of Figure \ref{fig:epos_scheduler}, the schedulable object is an
operating system thread.
Schedulable objects and the scheduler are united by the \emph{scheduling criteria},
which defines a scheduling policy algorithm.
The scheduling criteria defines an \emph{int()} operator, which maps a
schedule object into an integer allowing for
schedulable objects (e.g. threads) to be ordered in the scheduler queue using
ordinary integer operands of comparison (e.g. $\leq$, $\neq$).

\fig{.4}{epos_scheduler}{EPOS's scheduler}


% = Remember that the same scheduler implementation can be synthesized
% either in hardware or software.
In this paper, we focus on the verification of the scheduler alone, not depending
on what is scheduled.
We have verified the C++ implementation of the EPOS's Scheduler.
Such implementation can be compiled using GCC in order to generate the software
version of the scheduler or can be synthesized using HLS tools in order to
generate the hardware version of the scheduler \cite{Flor:2011}.

% = Show the scheduler's contract.
We have verified functional correctness properties and safety properties of the
EPOS's scheduler.
The functional correctness properties are specified by the scheduler's contract,
which is composed by the class invariant
\begin{verbatim}
assert(Base::size() >= 0);
\end{verbatim}
meaning that the \emph{ready} queue could never have a negative number of schedulable
objects, and by the preconditions and postconditions of each public method of
the \emph{Scheduler} class, shown at the Table \ref{tab:scheduler1s_contract}.
The assertions are presented in C++ syntax as they are implemented.
Some variable assignments are
omitted for the sake of the presentation.
Variables using the suffix ``at\_pre'' contain the value obtaining while the
method's preconditions were checked (and before the execution of the method's
body).
The protected method \emph{contains} checks whether the \emph{ready} queue
contains the schedulable object passed as parameter.
The safety properties of the scheduler contract are related to array bounds and
pointer safety and are automatically generated by CBMC.

\begin{table*}[t]
\begin{center}
% \setlength{\tabcolsep}{1pt}
% \tiny
\caption{Scheduler's contract}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Method}                      & \textbf{Preconditions}                  & \textbf{Postconditions}                              \\
\hline
\textit{unsigned int schedulables()} & None                                    & None                                                 \\
\hline
\textit{T* volatile chosen()}        & None                                    & \textbf{assert}(contains(var\_chosen));              \\
\hline
\textit{void insert(T* obj)}         & \textbf{assert}(! contains(obj))        & \textbf{assert}(contains(obj));                      \\
                                     &                                         & \textbf{assert}(Base::size() == size\_at\_pre + 1);  \\
\hline
\textit{T* remove(T* obj)}           & None                                    & \textbf{assert}(! contains(obj));                    \\
                                     &                                         & \textbf{if}(contains\_obj\_at\_pre)                  \\
                                     &                                         & \textbf{assert}(Base::size() == size\_at\_pre - 1);  \\
                                     &                                         & \textbf{else}                                        \\
                                     &                                         & \textbf{assert}(result == null);                     \\
\hline
\textit{void suspend(T* obj)}        & None                                    & \textbf{assert}(! contains(obj));                    \\
                                     &                                         & \textbf{if}(contains\_obj\_at\_pre)                  \\
                                     &                                         & \textbf{assert}(Base::size() == size\_at\_pre - 1);  \\
\hline
\textit{void resume(T * obj)}        & \textit{same as insert}                 & \textit{same as insert}                              \\
\hline
\textit{T* choose()}                 & None                                    & \textbf{assert}(contains(var\_chosen));              \\
                                     &                                         & \textbf{assert}(Base::size() == size\_at\_pre);      \\
\hline
\textit{T* choose\_another()}        & None                                    & \textbf{assert}(contains(var\_another));             \\
                                     &                                         & \textbf{assert}(Base::size() == size\_at\_pre);      \\
\hline
\textit{T* choose(T* obj)}           & None                                    & \textbf{assert}(Base::size() == size\_at\_pre);      \\
                                     &                                         & \textbf{if}(contains\_obj\_at\_pre)                  \\
                                     &                                         & \textbf{assert}(contains(obj));                      \\
                                     &                                         & \textbf{else}                                        \\
                                     &                                         & \textbf{assert}(result == null);                     \\
\hline
\end{tabular}
\label{tab:scheduler1s_contract}
\end{center}
\end{table*}


% = Shows what we did to adapt the scheduler for verification.
% Verified scenario...
We have instrumented the scheduler for verification using the
\emph{Verified Scenario} as described in Section \ref{proposal}.
% 
% = Show the results.
% Number of VCC generated, verification successful, ...
Then we have used CBMC to check the scheduler implementation already instrumented
with its contract.
From the scheduler contract, CBMC has generated VCCs related to functional
correctness properties, and by analyzing the source code CBMC has generated
VCCs related to array bounds and pointer safety.
All VCCs hold, proving the scheduler correctness and safety properties.
% 
% 
% = Show the results. V1 - commented
% Number of VCC generated, verification successful, ...
% Then we have used CBMC to check the scheduler implementation already instrumented
% with its contract.
% % Valores fictícios. TODO Atualizar por valores reais.
% CBMC has generated \emph{M} VCCs related to functional correctness properties,
% \emph{N} VCCs related to array bounds and \emph{O} VCCs related to pointer
% safety.
% % Mostrar como é um VCC?
% All VCCs hold, proving the scheduler correctness and safety properties.

The verified code was subsequently compiled using GCC yielding a
software instance and using the HLS tool CatapultC \cite{Calypto:Catapult} to
yielding a hardware instance of the scheduler.
% = Due to some CBMC limitations we have to make the code more explicit
% * Loop bounds
% * Explicit definition of comparison operators at the Scheduling Criteria
% * Instantiating the Scheduler class (which is a parametric class) for a
% concrete ``Alpha'' type that has a criterion object that implements the
% scheduling criteria operations.

% ------------------------------------------------------------------------------
