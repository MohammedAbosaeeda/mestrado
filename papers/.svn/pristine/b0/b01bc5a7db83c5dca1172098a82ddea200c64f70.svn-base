% ------------------------------------------------------------------------------
\section{DMEC} \label{dmec}
% + DMEC
% Describes the Distributed Motion Estimation Component (DMEC).
% Describes its parallelization Strategy (picture partition) as well the
% Coordinator-Worker model


% 1º parte independente de distribuído
% * Diagrama de classes: Interface PictureMotionEstimator                         (fig 3.1 relat tec): pme.dia
% Dizer que DMEC foi projetado seguindo os conceitos de ME.
% Engenharia de domínio da codificação de vídeo.
The Distributed Motion Estimation Component (DMEC) was developed following a
domain engineering process. This process resulted in the isolation of aspects such as synchronization
and communication from the ME algorithm itself.
The central element of DMEC is described by the interface 
\emph{PictureMotionEstimator} shown by Figure \ref{fig:pme}.
Such interface describes entities that are responsible to perform ME of a whole
picture (or a partition of a picture).
An object of the type \emph{PictureMotionEstimator} knows all block modes of
the video standard in use (e.g. H.264), and works according to a specific
error metric, such as SAD.
Such error metric is used to determine the similarity between neighboring
pictures.
The ME itself is computed by the \emph{match} method that takes the
current and the reference pictures
(respectively pictures \emph{A} and \emph{B} from Figure \ref{fig:motion_estimation})
and returns their ``counterpart'' which is composed by the motion vectors
and the motion cost.

\fig{.4}{pme}{\emph{PictureMotionEstimator} interface}


% * Diagrama de classes: Retorno do match                                         (fig 3.2 relat tec): pmc.dia
% Dizer que retorna "tudo" é um componente bem auto contido.
DMEC was designed to be self-contained, thus, the \emph{match} method computes ME
for all picture's macroblocks and for all block modes without any dependency
from another encoder element.
Therefore, the return of the method \emph{match},
which is accessed using the \emph{PictureMotionCounterpart} interface,
is a multidimensional vector containing all motion
vectors and costs for each macroblock and block mode used in the ME.

\subsection{Parallelization Strategy}
The parallelization strategy employed by DMEC is based on data partitioning,
in which the unit to be partitioned is the picture.
Figure \ref{fig:picture_partition} shows all picture partition modes available.
% It is worthy to mention that as all picture partitions dimensions must be 
% multiple to the macroblock dimension (16x16 pixels), it can occur having 
% partitions with distinct dimensions.
All picture partitions dimensions must be multiple to the macroblock dimension 
(16x16 pixels) to avoid having a macroblock broken between two neighboring
partitions.
If desired, it is possible to include new partition modes by specifying how the
partition should be performed.

% Fig showing all partitions types.
\fig{.2}{picture_partition}{Supported picture partitions modes}
% SINGLE_PARTITION = 1, 
% |0|
% 
% ONExTWO_PARTITION = 2,     
% |0|
% |1|
% 
% THREExONE_PARTITION = 3,
% |0|1|2|
% 
% TWOxTWO_PARTITION = 4,
% |0|1|
% |2|3|
% 
% THREE_TWOxTWO_PARTITION = 5,
% |0|1|2|
% |3 | 4|
% 
% THREExTWO_PARTITION = 6
% |0|1|2|
% |3|4|5|
% 

In order to improve the performance of ME, each picture partition is then
assigned to a \emph{Worker} module which executes in a specific functional unit,
such as a core of a multicore processor or a dedicated hardware element.
There is also a \emph{Coordinator} module, responsible to define the 
picture partition for each \emph{Worker} and to provide them with 
pictures to be processed.
The \emph{Coordinator} is also responsible to gather results generated by
\emph{Workers} (motion cost and motion vectors) and to deliver these results
back to the encoder.

% + Algoritmo
Each \emph{Worker} module computes ME by using a Block Matching Algorithm (BMA),
which itself also implements the \emph{PictureMotionEstimator} interface.
Thus, as shown by Figure \ref{fig:workers_and_bma}, all BMAs follow a single interface,
therefore, it is possible to replace a BMA for another, according to the encoder
needs.

\fig{.4}{workers_and_bma}{Worker and Block Matching Algorithm}

\subsection{Data Transference and Synchronization}
% // DMEC: Data Transference and Synchronization //
% * Diagrama de classes: TransferenceManager e SynchronizationManager             (TODO): dmec_trans_and_synch.dia
% Talvez seja um diagrama de sequencia até.
% 
% Mostrando como a transferencia de dados e sincronização são feitas.
% 
% É, diagrama de seq é bom.
% 
% Coordinator prepara pictures.
% Usa SynchronizationManager para Avisar que elas estão prontas (posso chamar de Barrier)
% Workers usam Transference Manager para obter as Pictures.
% Calculam ME e usar Transference Manager para divulgar os resultados
% Avisam Coordinator usando SynchronizationManager que o trabalho está pronto.
% 
% É meio um repeteco da figura thread model, mas é interessante para mostrar as
% interfaces de TransferenceManager e SynchronizationManager que serão implementadas
% pelo CELL, PC e Hardware...
We have used a shared memory model for exchanging data between the \emph{Coordinator} and
\emph{Worker} modules, although, in practice, such
memory can be implemented as a memory block in a single address space 
(as is the case for our implementation for the IA32 architecture and
dedicated hardware), or
can be constituted by multiple memory blocks, each one using its own address
space
(as is the case for our implementation for the Cell BE architecture).

Figure \ref{fig:dmec_trans_and_synch} details the interaction between
\emph{Coordinator} and \emph{Worker} modules.
At the beginning of the ME operation DMEC assumes that all pictures are in the
main memory.
Using the \emph{TransferenceManager} interface, \emph{Worker} modules can
obtain the samples of their picture partitions.
In the case of a memory block in a single address space, the operations of
\emph{TransferenceManager} are just pointer manipulations.
On the other hand, while using memory blocks in distinct address spaces, the
operations of \emph{TransferenceManager} are mapped to real 
memory transferences, such as Direct Memory Access (DMA) requests.
Also, by using the \emph{TransferenceManager}, \emph{Worker} modules 
can publish the computed motion vectors and motion costs.
% 
\emph{Worker} modules should wait for a signal from the \emph{Coordinator}
module indicating that there are pictures to the processed.
Similarly, the \emph{Coordinator} module should wait for the ME results 
generated by the \emph{Worker} modules.
Such synchronization operations are implemented by the 
\emph{SynchronizationManager} interface, which specifies barrier-like
mechanisms, which can be implemented using operating system operations or using
directly dedicated hardware elements.
In the case of a sequential operation with a single partition containing the
whole picture, the operations of \emph{SynchronizationManager} are canceled. 

\figtwocolumn{.7}{dmec_trans_and_synch}{Transference and synchronization between Coordinator and Workers}

% ------------------------------------------------------------------------------
% 
% Some notes
% DMEC Interfaces:
% 
% \emph{PictureMotionEstimator}
% 
% \emph{TransferenceManager}
% 
% \emph{SynchronizationManager}
% 
% 
% \emph{Coordinator} implements \emph{PictureMotionEstimator}
% 
% \emph{Worker} kind of implements \emph{PictureMotionEstimator}.
% The interface is other but it also performs match.
% The \emph{Worker} interface has a entry point ``run'', a match method,
% and some methods to gather the pictures and put the pictures back.
% 
% A \emph{Worker} uses the interfaces
% \emph{TransferenceManager} and \emph{SynchronizationManager}
