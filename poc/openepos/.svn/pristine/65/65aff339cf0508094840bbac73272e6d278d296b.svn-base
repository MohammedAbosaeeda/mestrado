package keso.compiler.backend;

import keso.classfile.*;
import keso.classfile.constantpool.*;
import keso.classfile.datatypes.*;

import keso.compiler.*;
import keso.compiler.config.*;
import keso.compiler.imcode.*;

import keso.util.Debug;
import keso.util.Bitmap;

import java.io.*;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;

public class CoderAVR extends Coder {

	public CoderAVR(BuilderOptions opts, MethodTableFactory table, ClassStore store) throws CompileException {
		rules = new Vector();
		global = new StringBuffer();
        global_header = new StringBuffer();
        global_includes = new Hashtable();
        global_header_includes = new Hashtable();
        mdispatch = table;
        repository = store;
        this.opts=opts;
        ifmatrix = new InterfaceTypeMatrix(opts, this, store);
    }
    
    
    public void writeMainFile() throws CompileException {
			SystemDefinition sdef = opts.getSysDef();

	    try {
		    String mainfile = opts.getOutputPath()+"/keso_main.c";
		    PrintStream out = new PrintStream(new FileOutputStream(mainfile));
		    Vector tasks = opts.getSysTasks();

		    out.println("/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */\n");

		    /* include the headers for each task's class in global.h */
		    out.println("#include \"domains.h\"");
		    out.println("#include \"global.h\"");


		    for (int i = 0; i < tasks.size(); ++i) {
			    TaskDefinition task = (TaskDefinition) tasks.elementAt(i);
			    if (task instanceof NativeTask) { 
				    continue;
			    } else {
				    IMClass mainClass = repository.getClass(task.getMainClassName());
                    
                    String include = "#include \"" + mainClass.getAlias() + ".h\"\n";
			        global_header_add(include);

				    IMMethod mainMethod = mainClass.getMethod(task.getMainMethodName());
				    writeIncludes(out, mainMethod.getMethodIncludes());
			    }
		    }

		    writeHeaderClassConstructors(out);

				if(sdef.getStack() != null || opts.hasOption("gcc-no-stdlibs")) {
					int size = 32;
					ComplexAttribute stack = sdef.getStack();
					try {
						size = stack.getAttribute("Size").valueInt();
					} catch(NullPointerException e) { }

					out.println("char __stackend["+size+"] __attribute__ ((section (\".data\"))) = { 0x42 };");

					Attribut scheck = stack.getAttribute("StackChecks");
					if(scheck != null && scheck.valueString().compareToIgnoreCase("true")==0) {
						global_header_add("extern char __stackend[];\n");
						global_header_add("void __stack_excpt_handler() __attribute__ ((naked));\n");

						IMClass schClass = repository.getClass(stack.getAttribute("HandlerClass").valueString());
						IMMethod schMethod = schClass.getMethod(stack.getAttribute("HandlerMethod").valueString());

						out.println("void __stack_excpt_handler()");
						StringBuffer mBody = schMethod.getMethodBodyPretty();
						out.println(mBody.toString());
					}
				}

		    // Runtime information such as Task objects, Resource objects, etc.
		    writeRuntimeData(out, tasks);

		    // Hook routines
		    writeHookRoutines(out, tasks);

		    // ISRs
		    writeISRs(out);

		    // alarm callback functions
		    writeAlarmCallbacks(out, opts.getSysAlarms());

		    // Main function begin
		    out.print("int main(void) {\n");

		    writeCallClassConstructors(out);

		    boolean taskFound = false;

		    for (int i = 0; i < tasks.size(); ++i) {

			    TaskDefinition task = (TaskDefinition) tasks.elementAt(i);

			    if (task instanceof NativeTask) {   // don't generate code
				    continue;

			    } else if (!taskFound) {    // emit code for the first task found

				    taskFound = true;

				    IMClass mainClass = repository.getClass(task.getMainClassName());
				    IMMethod mainMethod = mainClass.getMethod(task.getMainMethodName());


				    // constructor for task
				    IMMethod constructor = mainClass.getMethod("<init>()V");
				    if (constructor!=null) {
					if (false) {
					    out.print("\t");
					    out.print(constructor.getAlias());
					    out.println("((object_t *) keso_curr_task);");
					} else {
						StringBuffer cBody = constructor.getMethodBodyPretty();
						out.println();
						if (cBody.lastIndexOf("obj0") >= 0) {
							out.println("object_t *obj0 = (object_t *) keso_curr_task;");
						}
						out.println(cBody.toString());
					}
				    }

				    StringBuffer mBody = mainMethod.getMethodBodyPretty();
				    out.println();
				    // check if task object is used
				    if (mBody.lastIndexOf("obj0") >= 0) {
					    out.println("object_t *obj0 = (object_t *) keso_curr_task;");
				    }

				    out.println(mBody.toString());

			    } else {    // more than one task

				    opts.warn("Warning: no code generated for " + task.getMainClassName() + "." + task.getMainMethodName());

			    }

		    }

		    out.print("}\n");

		    /*
		       add_rule(new MakeRule(opts, "keso_main.o",
		       "keso_main.c", modul.getAlias()+".h"));
		       */

		    out.close();

	    } catch (IOException ex) {
		    throw new CompileException(ex.toString());
	    }

	    writeInfoFile();
    }
    
    
    protected void writeHookRoutines(PrintStream out, Vector tasks) throws CompileException {
        OSDefinition osdef = opts.getSysDef().getOSDef();

        // no OS no hooks :-(
        if (osdef==null) return ;

        // allHooks will contain {hooks, hookdescs, hookparams}
        Object[] allHooks = osdef.getAllHooks();
        ComplexBoolAttribute[] hooks = (ComplexBoolAttribute[]) allHooks[0];
        String[] hookDescs = (String[]) allHooks[1];
        String[][][] hookParams = (String[][][]) allHooks[2];

        // Startup Hook specially handled
        out.println("void StartupHook() {");
        //out.println("\tunsigned int i;\n");


        // Initialize heaps
        IMDomain[] doms = opts.getDomains();
        //out.println("\t/* Initialize heaps */");
        //for(int i=0;i<doms.length;i++) {
        //    IMHeap dheap = doms[i].getHeap();
        //    dheap.initHeap(out);
        //}
        if (doms.length>1) {	
            out.println("\t/* Initialize heap */");
            IMHeap dheap = doms[1].getHeap();
            dheap.initHeap(out);
        }


        //out.println();

        /* We should do all the initialization work before calling
         * user code (if possible). Constructors are user code..
         */
        //initManagedResource(opts.getSysTasks(), "Task", out);
        //initManagedResource(opts.getSysResource(), "Resource", out);
        //initManagedResource(opts.getSysAlarms(), "Alarm", out);

        /* Call class constructors */
	   //writeCallClassConstructors(out);

        // Call constructors of the resource objects
        // We call the task's constructors last since we
        // don't know what they'll be doing
        //callManagedResourceConstructors(opts.getSysResource(), "Resource", out);
        //callManagedResourceConstructors(opts.getSysAlarms(), "Alarm", out);
        //callManagedResourceConstructors(opts.getSysTasks(), "Task", out);

        // call user-defined hook here
        if (hooks[0]!=null && hooks[0].setting) {
            out.print("\n\t/* user defined startup hook */\n");
            addHookCode(out,hooks[0], hookParams[0]);
        }
        out.println("}\n");

        // PreTaskHook will be used to init keso_curr_task and keso_curr_domain
        out.println("void PreTaskHook() {");
        //out.println("\t/* Init keso_curr_task and keso_current_domain_id */");
        //out.println("\tKESO_SET_CURRENT_TASK(keso_curr_task_fkt());");
        //out.println("\tkeso_current_domain_id = KESO_CURRENT_TASK->_e_domain_id;");

        // call user defined hook
        for(int i=1; i<hooks.length; i++) {
            if(hookDescs[i].compareTo("PreTaskHook")!=0) continue;
            if(hooks[i]==null || !hooks[i].setting) break;
            out.print("\n\t/* user defined pretask hook */\n");
            addHookCode(out,hooks[i], hookParams[i]);
        }
        out.println("}\n");

        /* PostTaskHook:
         *  for some reason I don't know ProOSEK wants to have a PostTaskHook
         *  when a PreTaskHook is used. So for god's sake, in case the user does
         *  not use one we will add an empty one here. We will, however, not enable
         *  the OIL attribute
         * ErrorHook:
         *  It may happen that currently _no_ task is running when the ErrorHook is
         *  called. We must ensure that in this case the errorhook runs in domain
         *  zero and keso_curr_task is set to INVALID_TASK
         */
        //for(int i=1; i<hooks.length; i++) {
        //    if(hookDescs[i].compareTo("PostTaskHook")==0) {
        //        if(hooks[i]==null || !hooks[i].setting)
        //            out.println("void PostTaskHook() { /* empty PostTaskHook to satisfy ProOSEK */ }\n");
        //    } else if(hookDescs[i].compareTo("ErrorHook")==0) {
        //        if(hooks[i]!=null && hooks[i].setting) {
        //            out.println("void ErrorHook("+hookParams[i][0][0]+" "+hookParams[i][0][1]+") {");
        //            out.println("\tif(keso_curr_task_fkt() == keso_task_index[INVALID_TASK]) {");
        //            out.println("\t\tkeso_current_domain_id = DOMAIN_ZERO;");
        //            out.println("\t\tkeso_curr_task = keso_task_index[INVALID_TASK];");
        //            out.println("\t}");
        //            out.println("\t/* user defined ErrorHook */");
        //            addHookCode(out, hooks[i], hookParams[i]);
        //            out.println("\t/* No need to restore task/domain environment, since it was only modified");
        //            out.println("\t * in case there was no task running. In this case the PreTaskHook will restore");
        //            out.println("\t * the environment when the next task is launched.");
        //            out.println("\t */");
        //            out.println("}\n");
        //        }
        //    }
        //}

        // the other hooks are purely user defined (for now ;-) )

        // [0] is the StartupHook, skip it
        for (int i=1; i<hooks.length; i++) {
            if(hooks[i]==null || !hooks[i].setting) continue;

            // skip specially handled hooks here
            // be sure to enable the always enabled Hook
            // in the OIL file by modifying OSDefinition.toOIL()
            if(hookDescs[i].compareTo("PreTaskHook")==0) continue;
            if(hookDescs[i].compareTo("ErrorHook")==0) continue;

            // handle non modified hook
            out.print("void " + hookDescs[i] + "(");
            if (hookParams[i]!=null) {
                for (int j=0; j<hookParams[i].length; j++) {
                    if(j>0) out.print(", ");
                    out.print(hookParams[i][j][0]); // param type
                    out.print(" ");
                    out.print(hookParams[i][j][1]); // param's name
                }
            }
            out.println(") {");

            /* just a slight mod for the ShutdownHook ;-)
             * make sure it runs in DomainZero
             * ShutdownHook must not call getTaskID, keso_curr_task
             * does therefore not have to be set
             */
            if(hookDescs[i].compareTo("ShutdownHook")==0)
                out.println("\tkeso_current_domain_id = DOMAIN_ZERO;");

            addHookCode(out, hooks[i], hookParams[i]);
            out.println("}\n");
        }
    }


    protected void writeGlobalFiles() throws CompileException {
        try {

            // Makefile
            String makefile = opts.getOutputPath()+"/Makefile";
            PrintStream out = new PrintStream(new FileOutputStream(makefile));

            writeMakefile(rules, out);

            out.close();

            // Write global.h
            String filename = opts.getOutputPath()+"/global.h";
            PrintStream glb_out = new PrintStream(new FileOutputStream(filename));
            glb_out.println("/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */\n");
            glb_out.println("#ifndef _GLOBAL_H_");
            glb_out.println("#define _GLOBAL_H_ 1\n");
            glb_out.println("#include <keso_types.h>\n");
            glb_out.println("#include <keso_support.h>\n");
            writeIncludes(glb_out, global_header_includes);

            /* HACK ahead: own module in the future! */
            Vector tasks = opts.getSysTasks();
            for(int i=0; i<tasks.size(); i++) {
                TaskDefinition res = (TaskDefinition) tasks.elementAt(i);
                glb_out.print("#define ");
                glb_out.print(res.getIdentifier());
                glb_out.print(" ");
                glb_out.println(i);
            }
            /* HACK ahead: own module in the future! */


            glb_out.println(global_header);
            glb_out.println("\n#endif");
            glb_out.close();

            // Write global.c
            filename = opts.getOutputPath()+"/global.c";
            glb_out = new PrintStream(new FileOutputStream(filename));
            glb_out.println("/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */\n");
            glb_out.println("#include \"global.h\"");
            glb_out.println("#include \"domains.h\"");

            writeIncludes(glb_out, global_includes);
            glb_out.println(global);

            glb_out.close();

        } catch (IOException ex) {
            throw new CompileException(ex.toString());
        }
    }


    protected void writeISRs(PrintStream out) throws CompileException {
	    Vector isrs = opts.getSysISRs();

	    out.println("#include <avr/signal.h>");
	    out.println("#include <avr/io.h>");

	    global_header_add("#ifndef ISR\n");
	    global_header_add("#define ISR SIGNAL\n");
	    global_header_add("#endif\n");

	    for(int i=0; i<isrs.size(); i++) {
		    ISRDefinition isr = (ISRDefinition) isrs.elementAt(i);

		    try {
			    IMClass handlerClass = repository.getClass(isr.getHandlerClass());
			    IMMethod handlerMethod = handlerClass.getMethod(isr.getHandlerMethod());

			    out.println();

			    Enumeration incs = handlerMethod.getMethodIncludes().keys();
			    while (incs.hasMoreElements()) {
				    out.print("#include \"");
				    out.print(incs.nextElement().toString());
				    out.println(".h\"");
			    }

			    out.println();

			    out.print("ISR(");
			    out.print(isr.getName());
			    out.print(") ");
			    out.println(handlerMethod.getMethodBody().toString());

		    } catch (NullPointerException e) {
			    e.printStackTrace();
			    throw new CompileException(isr + " does not have all required attributes defined!");
		    }
	    }
    }


	protected void writeMakefile(Vector rules, PrintStream out) throws IOException {

		out.println("# THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT\n\n");
		out.println(".PHONY: test clean tags recreate upload flash0 flash1 all size elf hex extcoff build begin end\n");
		out.print("CC = ");
		out.println(opts.getCC());
		out.print("STRIP = ");
		out.println(opts.getStrip());
		out.print("SIZE = ");
		out.println(opts.getObjSize());
		out.print("OBJCOPY = ");
		out.println(opts.getObjCopy());
		out.println("OBJDUMP = avr-objdump");
		out.println("AR = " + opts.getAR());

		out.println("TARGET = keso");

		if (opts.getProcessorType() == null) {
			opts.warn("No processor type specified.");
		}

		out.println("MCU = " + opts.getProcessorType()); 
		out.println("FORMAT = ihex");   

		out.println("SRC = global.c \\");

		for (int i=0;i<rules.size();i++) {
			out.println(((MakeRule)rules.elementAt(i)).getSource() + " \\");
		}

		out.println();

		out.println("CFLAGS = -I " + opts.getCorePath() + " " + opts.getCFlags());

		out.println("ASFLAGS = -Wa,adhlns=$(<:.S=.lst),-gdwarf-2");

		{
			StringBuffer ldf = new StringBuffer("LDFLAGS = -Wl,-Map=$(TARGET).map,--cref ");
			
			try {
				if(opts.getSysDef().getStack().value.compareToIgnoreCase("true")==0) {
					ldf.append("-Xlinker --defsym -Xlinker __stackend=0x800100 ");
					ldf.append("-Xlinker --defsym -Xlinker __stack=__stackend+");
					int size;
					try {
						size = opts.getSysDef().getStack().getAttribute("Size").valueInt();
					} catch (NullPointerException e) { size = 32; }
					ldf.append(size);
					ldf.append(" ");
					/*
					if(opts.getSysDef().getStack().getAttribute("StackChecks").valueString().compareToIgnoreCase("true")==0) {
						for(int i=1; i<size; i++) {
							ldf.append("-Xlinker --defsym -Xlinker __stackP");
							ldf.append(i);
							ldf.append("=__stackend+");
							ldf.append(i);
							ldf.append(" ");
						}
					}*/
				}
			} catch (NullPointerException e) { }
      
			out.println(ldf.toString()); // -Wl,--section-start=.foo=0x1E00  // relocate a section in flash memory
		}
		out.println("OBJ = $(SRC:.c=.o) ");

		out.println("GENDEPFLAGS = -Wp,-M,-MP,-MT,$(*F).o,-MF,.dep/$(@F).d");

		out.println("\nALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS) $(GENDEPFLAGS)");

		out.println("\nALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)");

		out.println("\nall: begin build size end");

		out.println("\nbegin:");
		out.println("\t@echo Building Keso...");

		out.println("\nbuild: elf hex $(TARGET).od");

		out.println("\nelf: $(TARGET).elf");
		out.println("\nhex: $(TARGET).hex");

		out.println("\nstrip: $(TARGET).elf");
		out.println("\t$(STRIP) $(TARGET).elf");

		out.println("\nsize:");
		out.println("\t$(SIZE) -A $(TARGET).elf");

		out.println("\nend:");
		out.println("\t@echo Build finished: $(KESORC) : $(JINOFLAGS)");

		out.println("\ntest: keso.od");
		out.println("\tavrora -banner=false -platform=mica2 -simulation=single keso.od\n");

		out.println("\nkesoinfo: kesoinfo.c");
		out.println("\tgcc -I /home/wawi/KESO/src/kore/ -O2 -ansi -Wall -o kesoinfo kesoinfo.c\n");

		out.println("\ntags:");
		out.println("\t$(CTAGBIN) *.h *.c");

		out.println("\nCOFFCONVERT = $(OBJCOPY) --debugging --change-section-address .data-0x800000 --change-section-address .bss-0x800000 --change-section-address .noinit-0x800000 --change-section-address .eeprom-0x810000");

		out.println("\nextcoff: $(TARGET).elf");
		out.println("\t$(COFFCONVERT) -O coff-ext-avr $< $(TARGET).cof");

		out.println("\ncoff: $(TARGET).elf");
		out.println("\t$(COFFCONVERT) -O coff-avr $< $(TARGET).cof");

		out.println("\n%.hex: %.elf");
		out.println("\t$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@");

		out.println("\n$(TARGET).od: $(TARGET).elf");
		out.println("\t@echo Generating $(TARGET).od");
		out.println("\t@$(OBJCOPY) -R .stab -R .stabstr $(TARGET).elf $(TARGET).tmp");
		out.println("\t@$(OBJDUMP) -zhD $(TARGET).tmp > $(TARGET).od");

		out.println("\n.SECONDARY : $(TARGET).elf");
		out.println(".PRECIOUS : $(OBJ)");
		out.println("%.elf: $(OBJ) keso_main.o");
		out.println("\t@echo Linking $@");
		out.println("\t@$(AR) rc libkeso.a $(OBJ)");
		out.print("\t@$(CC) $(ALL_CFLAGS) keso_main.o libkeso.a ");
	        out.print(opts.getCorePath());
		out.print(opts.getCoreLib());
	        out.println(" --output $@ $(LDFLAGS)");

		out.println("\n%.o : %.c");
		out.println("\t@echo Compiling $<");
		out.println("\t@$(CC) -c $(ALL_CFLAGS) $< -o $@");

		out.println("\n%.s : %.c");
		out.println("\t@echo Generating assembler $<");
		out.println("\t@$(CC) -S $(ALL_CFLAGS) $< -o $@");

		out.println("\nrecreate: ");
		out.println("\tcd ../.. ; make\n");

		out.println("\nupload: all");
		out.print("\tssh faui49v \"cd ");
		out.print(opts.getOutputPath());
		out.println("; $(AVRDUDE) -p m8515 -c stk500v2 -U f:w:$(TARGET).hex\"");
			
		out.println("\nflash0:");
		out.print("\tcd ");
		out.print(opts.getOutputPath());
		out.println("; $(AVRDUDE) -P /dev/ttyS0 -p m8535 -c stk500v2 -U f:w:$(TARGET).hex");

		out.println("\nflash1:");
		out.print("\tcd ");
		out.print(opts.getOutputPath());
		out.println("; $(AVRDUDE) -P /dev/ttyS1 -p m8535 -c stk500v2 -U f:w:$(TARGET).hex");

		out.println("\nclean:");
		out.println("\trm -f $(TARGET).hex $(TARGET).elf $(TARGET).map");
		out.println("\trm -f $(OBJ) $(TARGET).o");
		out.println("\trm -f $(SRC:.c=.s)");
		out.println("\trm -f $(SRC:.c=.d)");
		out.println("\trm -f .dep/*");

		/*
		for (int i=0;i<rules.size();i++) {
			MakeRule rule = (MakeRule)rules.elementAt(i);
			rule.writeDotRule(out);
			out.print("\n");
		}
		*/

		out.println("\n-include $(shell mkdir .dep 2>/dev/null) $(wildcard .dep/*)");
	}
}
