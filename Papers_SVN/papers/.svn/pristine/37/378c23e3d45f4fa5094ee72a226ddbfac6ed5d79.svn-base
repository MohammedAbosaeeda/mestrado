\section{Battery Level Monitoring by Event Accounting}
\label{sec:account}

%general introduction. pessimistic bias. show desired behavior.
Traditional voltage-based battery monitoring may lead to a pessimistic bias of
an energy-aware task scheduler. In order to enhance the precision of the battery
monitor, we propose a software-based scheme to account for energy consumption.
This scheme is based on the premise that energy is consumed by hardware, not
software, but it is the software that controls and monitors hardware activity.
Considering that the operating system layer abstracts hardware access to
application, it is straightforward to assume that the operating system is the
entity with most knowledge about hardware activity, thus being able to monitor
system-wide energy consumption.

\subsection{Energy consumption profiles}
\label{sec:profiles}

We analyzed usual hardware behavior and modeled three different profiles to
account for energy consumption: time-based measurement, event-based measurement,
and combined measurement.
%time-based
The time-based profile is used to account for energy consumption of devices
draining constant current over time when in a specific operating mode, as
(\ref{eq:en_dev_time}) shows.
%event-based
The event-based profile is used in devices for which operation can be mapped to
specific events (e.g., sensor sampling). As shown in (\ref{eq:en_dev_ev}),
events are accounted for and energy is updated periodically based on this
accounting.
%both
In some devices, however, both approaches may be used. For instance, a radio
that stays in a low-power listen mode has a base energy consumption (computed by
the time-based profile) and extra energy consumption when data actually arrives
(computed by the event-based profile). As shown in (\ref{eq:en_tm_ev}).

\begin{eqnarray}
E_{tm}(dev) = (t_{end} - t_{begin}) \times I_{dev,mode} \label{eq:en_dev_time}\\
E_{ev}(dev) = \sum_{event\_counters} E_i * counter \label{eq:en_dev_ev}\\
E_{tot}(dev) = E_{tm}(dev) + E_{ev}(dev) \label{eq:en_tm_ev}
\end{eqnarray}
, where $E_{tm}(dev)$ is the energy consumption in the time-based profile for a
specific device, $t_{end}$ and $t_{begin}$ denote timestamps, and $I$ is the
current of $dev$ at a given $mode$. $E_{ev}$ denotes the sum of energy
($E_i$) consumed by the observed events ($counters$). $E_{tot}$ is the energy
consumption in the combined profile.



\subsection{Battery state-of-charge monitoring}

% further describe system runtime operation.
% present battery monitoring algorithm - battery charge updated periodically by
% means of event-counters which are updated at run-time.
At runtime, battery charge is updated with the accounted data of each device.
These accounting information, however, need to be collected in order to update
battery charge. The frequency in which these data are collected directly affects
the accuracy of the proposed battery state-of-charge monitor. Recalling the
curves in Fig.~\ref{fig:sampled_real_discharge}, we may say that high update
frequencies would draw a curve close to the ``real charge'', while low update
frequencies would approximate the ``sensed charge'' curve. In this section we
describe how to achieve a satisfactory curve close to the ``real charge'' curve
of Fig.~\ref{fig:sampled_real_discharge} by adequately adjusting the battery
update frequency.

We start by analyzing the update frequency for the time-based profile. It is not
the intent of the present work to investigate issues related to the frequency of
operating mode migrations or their time and energy overheads, for such problems
have already been extensively addressed~\cite{Hoeller:DIPES:2006,Seo:2011}.
Thus, this profile can adhere to such migration models by the inclusion of an
extra routine like $energy\_migration\_update$ on Fig.~\ref{prg:batt_updates}
to compute elapsed time and consumed energy during these migrations as described
by (\ref{eq:en_dev_time}). The execution time for this routine, shown in
Tab.~\ref{tab:time_overhead} is constant and can be easily obtained and
integrated to any transition model, being either real-time or not. Additionally,
to prevent the system from loosing control of battery discharge when devices
stay in a certain operating mode for long periods, an active component
periodically collects energy consumption information from all devices and
updates battery charge.

\prg{pascal}{batt_updates}{Algorithms for energy accounting.}

\tab{time_overhead}{Processing overhead of the energy accounter on an
ARM7-TDMI processor.}

For the event-based profile, however, the battery charge update approach needs
to be different to avoid unnecessary processing overheads. For instance, suppose
that a hypothetic system monitors an event that is the reception of a byte from
a network interface. Network protocols will seldom use only one byte to perform
communications, thus, as can be seen in Tab.~\ref{tab:time_overhead}, system
performance may benefit from periodic updates of an accumulated counter. In
order to do that, an active object was modeled as an extra task on the system
which is responsible for collecting accounted information of the event-based
profile.

It is important to note that the accounting mechanism employed in this scheme,
although more accurate, is still pessimistic once it is based on the worst-case
energy consumption (WCEC) of events and components' operating modes. Thus, it is
expected that the accounted energy consumption reaches the value read from the
battery voltage model before it shows a drop in voltage. It is safe, however, to
assume that the information from the voltage model is a secure bound to battery
charge, although conservative. Then, we may correct the battery charge to the
maximum value between the accounted charge and the one estimated by the voltage
model (as shown in (\ref{eq:batt_update})).

\begin{eqnarray}
E_{batt} = max\left(E_{volt} , E_{batt} - \sum_{i = 0}^{\#devs} E_{tot}(i)\right)
\label{eq:batt_update}
\end{eqnarray}

Finally, the active component with the task of periodically updating the battery
charge is responsible for collecting accounted information from both event-based
and time-based profiles. The algorithm is the one at the procedure
$energy\_update\_total$ of Fig.~\ref{prg:batt_updates}. It is important to
note that timestamps and event counters are reset every time energy accounting
is updated (by $energy\_migration\_update$ and $energy\_event\_update$), thus
making sure that no energy consumed is accounted for twice. This algorithmic
approach assumes initialization of $Battery$ with the nominal capacity of the
battery in use.


\subsection{On the Freshness of Battery Information}
\label{sec:frequency}

To understand the accounter behavior further we performed an exploration of
system design space to be able to determine the frequency at which accounted
data should be gathered provided that the system has a pre-defined requirement
of operation lifetime. We used a multi-objective optimization method based on
the \textit{Non-dominated Sorting Genetic Algorithm II}~(\nsga)~\cite{Deb:2002}
which is able to find good solution candidates for the frequency of the
collector task, i.e., those closer to the Pareto front. The optimization is
executed with two objectives: to minimize residual energy and to maximize the
execution rate of best-effort tasks. We use a simple scheduling mechanism in
which hard real-time tasks execute regardless of system energy availability and
best-effort tasks run only when the system is still able to guarantee energy
availability for hard real-time tasks. Priorities in the scheduling queue are
assigned through a Rate Monotonic policy provided that all hard real-time tasks
have higher priorities than any best-effort task, regardless of their period. We
also assume that initial battery charge is enough to guarantee hard real-time
tasks' executions during the expected lifetime.

\tab{hyp-taskset}{Hypothetic application tasks'
parameters\protect\footnotemark[1].}

\footnotetext[1]{T: task; P: period in $ms$; WCET: worst-case execution time in
$ms$; WCEC: worst-case energy consumption in $\eta Ah$; 1-hour: energy consumption for
the targeted lifetime (1 hour) in $mAh$.}

\footnotetext[2]{This is a worst-case scenario as values of ``P'' and, as
consequence, ``1-hour'', are to be defined by the optimization.}



Now we analyze a hypothetic application. Tab.~\ref{tab:hyp-taskset} shows the
parameters for this application, comprised by two hard real-time tasks ($H_1$
and $H_2$), one best-effort task ($B_1$) and the energy accounter collector task
($H_C$), ordered according to their priority. We kept the collector task as a
hard real-time task for two reasons. First, it is the only way to guarantee that
the defined period for the collector task will be respected, once best-effort
tasks may be prevented from executing. Second, if eventually the system stops
the execution of best-effort tasks and the collector task is a best-effort task,
the battery information will no longer be updated, thus being this a dead-end
for the energy-aware scheduler.

In order to evaluate the system instances (individuals) generated during the
optimization process we integrated a real-time simulator to the optimizer. This
system simulates a rate monotonic queue with two levels of priorities, being the
first one the task's class and the second one the rate monotonic priority
itself. This made it possible the separation between hard real-time and
best-effort tasks. The simulator also monitors energy consumption of tasks and
controls battery discharge based on informed worst-case energy consumption
(WCEC) of tasks. In order to achieve a more realistic behavior we consider that
all tasks actually use their WCEC for 75\% of the jobs. The remaining 25\% of
the jobs have a random energy consumption uniformly distributed between 50\% and
100\% of the WCEC. This generates a slack on the energy budget that can be used
by the best-effort tasks, as would actually happen on real systems. Although
naive, this simple probabilistic assumption helps to understand and analyze the
approach. A more consistent approach will be considered later in the case study
of Section~\ref{sec:case}.

\fig{hyp-solutions}{All solutions for the hypothetical
application.}{width=.9\columnwidth}

\tab{hyp-solutions}{Solutions for the frequency of the collector task for the
hypothetical application.}

We ran \nsga~with a population size of 100 individuals, being 20 of them
selected as parents, generating 20 offsprings, repeating the process during 50
generations (iterations) (\nsgaparam).
%With these parameters the optimizer was able to find four good solutions for
%the collector task frequency, shown at Tab.~\ref{tab:hyp-solutions}.
The best solutions found by the optimizer, i.e., those at the Pareto front, are
shown in Tab.~\ref{tab:hyp-solutions}. By analyzing
Fig.~\ref{fig:hyp-solutions}, which shows all found solutions, it is possible to
observe here the wide spread of results obtained from the optimization process.
It is also important to note the non-linear behavior of the observed parameters
in relation to frequency, showing why the solution to this problem benefits from
the application of meta-heuristic methods like \nsga.

%\figthree
% \figtwo
% {hyp-bet_freq}{Execution rate of best-effort tasks.}
% {hyp-batt_freq}{Residual energy after projected lifetime.}
% %{hyp-lost_freq}{Total of lost hard deadlines.}
% {Optimization objectives plotted against variations on the frequency of the
% collector task for the hypothetical application.}

% \fig{hyp-bet_freq}{Results for the objective ``execution rate of best-effort
% tasks'' after optimization procedure for the hypothetical
% application.}{width=\columnwidth}
% 
% \fig{hyp-batt_freq}{Results for the objective ``residual energy'' after
% optimization procedure for the hypothetical application.}{width=\columnwidth}
