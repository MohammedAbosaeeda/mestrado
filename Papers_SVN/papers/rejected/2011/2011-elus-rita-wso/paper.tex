\documentclass[12pt]{article}
\usepackage[brazil]{babel}
\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}  
\usepackage{listings}
\usepackage{subfigure}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}                           
\lstloadlanguages{[ANSI]C++}
\lstdefinestyle{prg} {basicstyle=\scriptsize\ttfamily, lineskip=-0.2ex, tabsize=1,  showspaces=false,breaklines=true,showstringspaces=false,numbers=left,numbersep=-5pt,frame=single,stepnumber=1}

\sloppy

\title{Melhorando  o desempenho do ELUS através de especialização de \textit{templates}}
\author{Rita de Cássia Cazu Soldi, Giovani Gracioli e Antônio Augusto Fröhlich}
\address{Laboratório de Integração de Software e Hardware (LISHA) \\
Universidade Federal de Santa Catarina (UFSC) \\ 
88040900 -- Florianópolis, SC -- Brasil
\email{\{rita,giovani,guto\}@lisha.ufsc.br}
}

\newcommand{\fig}[4][h]{
  \begin{figure}[#1] {\centering{\includegraphics[#4]{fig/#2}}\par}
    \caption{#3\label{fig:#2}}
  \end{figure}
}

\newcommand{\prg}[3][ht!]{
  \begin{figure}[#1]
      \lstinputlisting[language=C++,style=prg,xrightmargin=.2\textwidth,xleftmargin=.2\textwidth]{fig/#2.cc}
    \caption{#3\label{prg:#2}}
  \end{figure}
}

\newcommand{\proxy}{\textsc{Proxy}}
\newcommand{\agent}{\textsc{Agent}}
\newcommand{\adapter}{\textsc{Adapter}}
\newcommand{\scenario}{\textsc{Scenario}}
\newcommand{\handle}{\textsc{Handle}}
\newcommand{\stub}{\textsc{Stub}}
\newcommand{\msg}{\textsc{Message}}
\newcommand{\vtable}{\textsc{vtable}}

\begin{document} 

\maketitle
% não ultrapassar 10 linhas 
\begin{abstract}
Dynamic reconfiguration of software in embedded systems with severe resource constraints is a task that requires a performance optimization, since the reconfiguration process competes with the software for the limited system resources. ELUS is an operating system infrastructure that performs this activity effectively and safely, however, the use of resources can still be improved. This article presents a study of ELUS and proposes a performance improvement using templates specialization.
\end{abstract}
  
% não ultrapassar 10 linhas    
\begin{resumo} 
Reconfiguração dinâmica de \textit{software} em sistemas embarcados com severas restrições de recursos é uma tarefa que exige otimização de desempenho, visto que o processo de reconfiguração compete com o \textit{software} pelos limitados recursos do sistema. O ELUS é uma infraestrutura de sistema operacional que realiza esta atividade de maneira eficaz e segura, porém, a utilização dos recursos ainda pode ser aprimorada. Este artigo apresenta um estudo do ELUS e propõe uma melhoria de desempenho por meio do uso de especialização de \textit{templates}.
\end{resumo}

\section{Introdução}
Reconfiguração dinâmica é a capacidade de atualizar o \textit{software} de um determinado sistema sem perder o seu estado de execução e pode ser usada para diversas finalidades como realizar atualizações, implementar algoritmos para substituir componentes do sistema, monitoramento dinâmico, apoio a otimizações específicas da aplicação, ajuda para que componentes do sistema possam ser recebidos da rede e instalados em tempo de execução, entre outros.

Este tipo de reprogramação é extremamente importante no contexto de sistemas embarcados para que se possa adaptar os dispositivos às mudanças que ocorrem no ambiente, modificar o seu conjunto de tarefas e até aprimorar o uso de seus recursos. Quando a necessidade é aplicar a reconfiguração dinâmica em sistemas com severas restrições (ex. processamento, memória, energia) torna-se um desafio, pois, apesar dos mecanismos de atualização competirem pelos já limitados recursos do sistema, eles não devem influenciar no funcionamento do mesmo.

O ELUS (\textit{Epos Live Update System})~\cite{gracioli2009elus} é uma infraestrutura de sistema operacional para a reconfiguração dinâmica que difere das outras infraestruturas pelo baixo consumo de memória, alta configurabilidade, simplicidade e transparência para as aplicações. Se comparado a trabalhos equivalentes, o ELUS consome menos memória, possui um menor tempo de invocação de métodos e menor tempo de reconfiguração. Apesar dos resultados favoráveis, foi identificado que é possível melhorá-los. O ELUS foi implementado em C++ utilizando o \textit{framework}  de componentes metaprogramado do EPOS~\cite{Froehlich:2001}. O framework utiliza templates e com isso há uma replicação de código sempre que um novo componente é marcado como reconfigurável. Para contonar esse problema, este artigo propõe o uso da técnica de especialização de templates para diminuir a replicação de código dentro do \textit{framework}. Com o uso dessa técnica, foi possível melhorar o consumo de memória sem perder desempenho em outras caracterícias, como o tempo de invocação de métodos e tempo de reconfiguração dos componentes.

A estrutura deste artigo apresenta-se da seguinte forma. A seção~\ref{sec:elus} detalha o ELUS quanto à sua organização e algumas das suas limitações. Na seção~\ref{sec:modelagem} é detalhada a modelagem para a melhoria de desempenho do processo de reconfiguração dinâmica para a infraestrutura ELUS. Os resultados obtidos com as modificações são apresentados na seção~\ref{sec:resultados}. A seção~\ref{sec:rel} apresenta os trabalhos relacionados e, finalmente, a seção \ref{sec:conclusao} conclui o trabalho.

\section{Epos Live Update System (ELUS)}
\label{sec:elus}
O ELUS é uma infraestrutura de reconfiguração dinâmica que pode ser utilizada em sistemas embarcados com recursos limitados. Construída dentro do \textit{framework} de componentes do EPOS (\textit{Embedded Parallel Operating System})~\cite{Froehlich:2001} em torno do aspecto de invocação remota, esta arquitetura permite que um componente seja selecionado como reconfigurável ou não em tempo de compilação. As principais características que a difere dos outros trabalhos relacionados são a configurabilidade, o consumo de memória reduzido, a simplicidade e a transparência para as aplicações e reconfiguração.

\subsection{Arquitetura}
A arquitetura do ELUS é apresentada na Figura~\ref{fig:architecture_v2.pdf}. O \textit{framework} de componentes original do EPOS foi estendido para suportar também reconfiguração dinâmica. A invocação de um método de um componente passa pelo \proxy{} que envia uma mensagem ao \agent{}. O valor de retorno depois da execução do método é enviado de volta ao cliente através de uma mensagem. Um nível de indireção é criado entre o cliente e o método real, tornando o \agent{} o único membro da estrutura ciente da posição do componente na memória do sistema. A \textsc{OS Box} no \agent{} controla o acesso aos métodos do componente através de um semáforo para cada componente, chamando os métodos do \agent{} através de uma tabela. O \agent{} quando recebe uma invocação de método, envia o pedido para o \adapter{} que chama o método real do componente através da tabela de métodos virtuais (\vtable{}) do componente.

\fig{architecture_v2.pdf}{Visão geral da arquitetura do ELUS~\cite{gracioli2010elus}.}{scale=.65}

O \textsc{Elus Transport Protocol} (ETP) é um protocolo para o recebimento de mensagens de reconfiguração e toda atualização ocorre a partir de uma requisição neste formato. O \textit{framework} permite a atualização de componentes, da aplicação e do próprio \textit{framework} de reconfiguração. Conforme pode ser observado na Figura~\ref{fig:update_componente_rita.pdf}, para atualizações referentes a um componente, o ELUS tenta alcançar um estado em que nenhuma \textit{thread} esteja invocando métodos deste componente, ou seja, o estado quiescente. Em seguida é verificada a necessidade de alocar um espaço novo para o código, necessário apenas quando o código novo é maior que o antigo. Na sequência é feita a atualização da tabela de métodos virtuais e é verificado se há necessidade da atualização do componente no \textit{framework}. 

\fig{update_componente_rita.pdf}{Resumo da sequ\^{e}ncia de atividades realizadas pelo ELUS em uma reconfiguração de componentes.\cite{gracioli2009elus}}{scale=.65}

Para a atualização de componentes do \textit{framework} é necessário um pouco mais de cautela, pois o \texttt{Agent} - mais especificamente o método \texttt{trapAgent} - é o ponto de entrada para o serviço de reconfiguração e o seu endereço deve ser conhecido previamente para que o novo código do componente possa ser compilado corretamente. Então para ter certeza de que o endereço do \texttt{trapAgent} não será modificado ele não é uma função passível de reconfiguração.

Na reconfiguração da aplicação, a partir do pedido de atualização se inicia o processo de desabilitar as interrupções para atingir o estado quiescente da aplicação. O tamanho do código recebido é comparado com o código antigo para saber se ocorre uma simples atualização do endereço (se o novo código for menor ou igual ao antigo), caso contrário, é necessário alocar um novo espaço de memória antes de atualizar o endereço. Após a atualização da aplicação o sistema deve ser reiniciado para que suas as novas atividades possam ser realizadas.

%\fig{update_app_rita.pdf}{Diagrama de sequ\^{e}ncia de atividades realizadas pelo ELUS em uma reconfiguração da aplicação.}{scale=.65}

\subsection{Limitações}
Devido à estrutura do ELUS, cada componente selecionado como configurável gera um sobre custo em termos de memória, porque além da implementação real do método pelo próprio componente, ainda se faz necessário incluir os métodos do componente no \textit{framework}. Após a geração do sistema final, o código dos métodos do \textit{framework} é replicado para cada componente. Por exemplo, cada componente selecionado como reconfigurável irá ter o código do método \textit{update} replicado. A configuração de consumo mínimo de memória para adicionar o componente no \textit{framework} seria conter apenas os métodos criar, destruir, atualizar e um método sem parâmetros e retornar o valor e mesmo assim haveria o sobre custo de cerca de 1.6KB de código e 26 \textit{bytes} de dados. 

Outra limitação é o tempo de invocação dos métodos, pois ocorre uma indireção entre a aplicação e a invocação do método real, atribuindo ao \textit{framework} uma série de responsabilidades que acabam aumentando o tempo de invocação. Dentre as atribuições do \textit{framework} estão o armazenamento e controle sobre os objetos reconfiguráveis criados pela aplicação, incluindo alcançar o estado quiescente do componente. Todas estas responsabilidades fazem com que o tempo de invocação de métodos utilizando o \textit{framework} seja cerca de 10 vezes mais lento do que a invocação normal ou através de uma \vtable{}. Mesmo com esse sobrecusto, o ELUS apresenta um melhor desempenho que os trabalhos relacionados, possuindo o tempo de invocação pelo menos 7 vezes mais rápido, o tempo de reconfiguração com cerca de 197 ciclos menor e consumindo menos de 33\% da memória utilizada por qualquer um dos trabalhos relacionados \cite{gracioli2010elus}.

\section{Proposta de modelagem}
\label{sec:modelagem}
Analisando o código do \textit{framework} da infraestrutura ELUS foi possível observar uma estrutura metaprogramada utilizando \textit{templates}, conforme pode ser observado na Figura~\ref{fig:framework.pdf}. 


\fig{framework.pdf}{Interação entre os elementos do \textit{framework} metaprogramado \cite{gracioli2009elus}.}{scale=.4}

Os elementos compõem o \texttt{framework} e são utilizados no processo de reconfiguração que a infraestrutura provê são: \texttt{Handle, Stub, Proxy, Agent, Scenario e ScenarioHash}. Segue abaixo uma pequena descrição das suas respectivas funções.

\begin{itemize}
	\item \texttt{Handle} -  Quando o suporte ao \textit{framework} e à reconfiguração dinâmica estão habilitados, o componente é exportado como um parâmetro para o \texttt{Handle}, que possui a mesma interface (operações) que o componente, mas com a invocação dos métodos encaminhadas para o \texttt{Stub}. O \texttt{Handle} é responsável por verificar se um componente está ou não selecionado como reconfigurável.
	
	\item \texttt{Stub} - Responsável por criar um \texttt{Proxy} ou um \texttt{Adapter} conforme os parâmetros recebidos na sua criação via Handle. Então se a reconfiguração do componente está habilitada, Handle irá criar um \texttt{Stub} que contém todos os métodos do \texttt{Proxy}, permitindo assim a comunicação do \texttt{Proxy} com o \texttt{Agent}, surgindo aqui um nível de indireção entre as chamadas de métodos da aplicação e os componentes reais do sistema.
	 
	\item \texttt{Proxy} - Responsável por efetuar os métodos do componente. Quando recebe um pedido do \texttt{Handle}, ele utiliza a classe \texttt{Message} para passar o \texttt{ID} do componente e a solicitação desejada para o \texttt{Agent}.
	
	\item \texttt{Agent} - Possui duas funções: a invocação de métodos e a reconfiguração dos componentes e do próprio \textit{framework}. Caso seja uma invocação de método, a \texttt{Message} será enviada pelo \texttt{Proxy} e o método real do componente será chamado através da sua \vtable{} após o \texttt{Adapter} recuperar o objeto do componente. Caso contrário, a \texttt{Message} foi enviada pela \textit{thread} \texttt{Reconfigurator}, e o \texttt{Agent} deve fazer a reconfiguração do componente através do método \texttt{update}.
	
	\item \texttt{Scenario} - responsável por aplicar os aspectos selecionados para cada componente recebido pelo metaprograma. Também armazena os objetos criados pelo \texttt{Agent} em tempo de execução.
	
	\item \texttt{ScenarioHash} - Funciona como uma abstração das operações de controle, armazenamento, busca e recuperação de objetos através de uma tabela \textit{hash}.
\end{itemize}

Os elementos auxiliares são:  \texttt{Message}, \texttt{Adapter}, \texttt{Application\underline{ }Update}, \texttt{Reconfigurator} e \texttt{Code\underline{ }Manager}.
\begin{itemize}
	\item \texttt{Message} - Ponto comum entre o \texttt{Proxy} e o \texttt{Agent}. Oferece uma interface para anexar e recuperar informações úteis para a reconfiguração, como por exemplo tamanho do código, tipo de reconfiguração, retorno de um método, entre outros.
	
	\item \texttt{Adapter} - Funciona como um \textit{wrapper} e realiza a adaptação do componente que foi recebido como parâmetro através dos métodos \texttt{leave} e \texttt{enter} do \texttt{Scenario} antes e depois da invocação do método real. 
	
	\item \texttt{Application\underline{}Update} - É um componente criado exclusivamente para dar suporte à atualização da aplicação. Sua tarefa principal é desabilitar interrupções do sistema para conseguir atingir o estado quiescente.
	
	\item \texttt{Reconfigurator} - É uma \texttt{thread} criada na inicialização do sistema e é responsável por receber o pedido de reconfiguração, construir \texttt{Message} e enviar um pedido de reconfiguração para o \texttt{Agent}
	
	\item \texttt{Code\underline{ }Manager} - Responsável por utilizar a estrutura fornecida pelo mediador de \textit{hardware} para gerenciar alocação e liberação de espaços na memória.
\end{itemize}


Apesar de todos os elementos serem importantes para o processo de reconfiguração, o comportamento padrão para implementação de \textit{templates} utilizando C++ é replicar o código para cada função recebida como argumento. Desta forma, os elementos que interagem diretamente com o componente atualizável são replicados para cada argumento de tipo de componente recebido. Uma boa alternativa para evitar a replicação de código é extrair os trechos comuns a todas as funções \textit{template} para uma especialização para ponteiros \textit{void}. 

\subsection{Especializações de \textit{Templates} em C++}
Mecanismos de \textit{templates} providos pelo C++ são uma maneira de adicionar a classes e funções conceitos genéricos, isto é, permitem criar um código reutilizável onde os tipos sejam passados como parâmetro.

Por padrão, as classes \textit{template} possuem uma única implementação para qualquer argumento recebido e quando deseja-se dar um tratamento mais refinado à um determinado tipo de argumento, é necessário realizar descrições alternativas do \textit{template}. Estas descrições, também conhecidas como especializações, são escolhidas pelo compilador com base nos argumentos fornecidos para o \texttt{template}.

O ponteiro \textit{void} é um ponteiro que pode apontar para qualquer tipo de objeto e pode ser explicitamente convertido para qualquer outro tipo. Sendo assim, se for realizada uma especialização de \textit{template} para ponteiros \textit{void}, ela poderia implementar as funções comuns a todos os tipos de argumentos sem que haja replicação de código. 

Como exemplo desta ideia são apresentados na Figura
%~\ref{fig:vector}
4 (classe \texttt{Vetor} genérica) e na Figura
%~\ref{fig:vector_void}
5 (utilizando uma base para os demais argumentos).

\prg{vector}{Classe \texttt{Vector} generalizada \cite{cpp97Stroustrup}.}
\prg{vector_void}{Classe \texttt{Vector} com base especializada para para ponteiros \textit{void} \cite{cpp97Stroustrup}.}


Podemos observar que na Figura 5
%tem que colocar a referencia certa
não há mais a implementação de alguns métodos dentro da classe genérica de \texttt{Vector} e, consequentemente, ao invés de uma replicação haverá apenas uma chamada de método.

Existem vários trechos do \textit{framework} que podem ser modificados de acordo com esta proposta. A Figura~\ref{fig:algoritmo_update_agent.png} mostra um trecho do método \texttt{update} da classe \texttt{Agent}. Nela podemos observar que em grande parte do código não há nenhuma referência ao argumento \texttt{T} do \textit{template} e por isso é uma das classes em que há mais replicação de código.

\fig{algoritmo_update_agent.png}{Trecho do m\'{e}todo \texttt{update} da classe \texttt{Agent}.}{scale=.27}

Considerando as modificações que devem ser realizadas no modelo atual do ELUS, a Figura~\ref{fig:diagramaClasse.pdf} apresenta o novo diagrama de classes. Tanto o \texttt{Agent<void*>} quanto o \texttt{Scenario<void*>} são especializações utilizadas como base para diminuir a replicação código existente. Estas classes realizam os mesmos métodos, porém o retorno agora é um ponteiro \texttt{void} e deve ser reinterpretado pelo tipo \texttt{T} do \textit{template} através das classes \texttt{Agent<T>} e \texttt{Scenário<T>}.

\fig{diagramaClasse.pdf}{Diagrama da classes envolvidas no processo de reconfiguração.}{scale=.35}

\section{Resultados}
\label{sec:resultados}
A avaliação do ELUS modificado foi realizada na plataforma Mica2 \footnote{Microcontrolador Atmel Atmega128 de 8Mhz, 4KB de memória RAM, 128KB de memória flash, 4KB de EEPROM} e o código gerado pelo compilador GNU g++ versão 4.0.2. Os testes realizados visam medir o consumo de memória, desempenho de invocação de métodos e tempo de reconfiguração. Ainda, na medição de consumo de memória foi utilizada a ferramenta GNU \texttt{objdump} na versão 2.16.1 para analisar as imagens do sistema geradas pelo compilador e o tempo gasto na reconfiguração foi medido em ciclos do processador segundo o manual do microcontrolador.

\subsection{Consumo de memória}
Esta avaliação mensurou o sobrecusto adicionado ao sistema quando um componente é marcado como reconfigurável. A Tabela~\ref{tab:resultado_consumo_memoria_individual} apresenta os resultados comparando o ELUS original com a versão modificada. A configuração mínima para o ELUS original é de cerca de 1.6 KB de memória, sendo que com a modificação realizada por este trabalho são necessários apenas 664~bytes para representar o mesmo componente.

Para verificar qual parte do \textit{framework} foi a responsável por este ganho, foram realizadas medições mais específicas, desta vez considerando os métodos \texttt{create, destroy, update} e mais os quatro tipos possíveis de métodos (com parâmetro, sem parâmetro, com valor de retorno e sem valor de retorno), conforme pode também ser observado na Tabela \ref{tab:resultado_consumo_memoria_individual}.

\begin{table}[ht!]
\caption{Consumo de memória dos métodos individuais em ambas versões do ELUS.}
\begin{center}
\begin{tabular}{| c | c | c | c |c | c |}
\hline			
\textbf{Método} &   \multicolumn{2}{c|}{\textbf{ELUS original}}  & \multicolumn{2}{c|}{\textbf{ELUS modificado}} &   \cr \cline{2-5}
\textbf{do} & \multicolumn{2}{c|}{\textbf{Tam. seção (bytes)}} & \multicolumn{2}{c|}{\textbf{Tam. seção (bytes)}} & \textbf{Direfença} \cr \cline{2-6} 
\textbf{Framework} & \textbf{.text} & \textbf{.data} & \textbf{.text} & \textbf{.data} &\textbf{(\%)}\cr
\hline
Create				& 180  & 0 & 178  & 0 & 1,11 \cr\hline
Destory 			& 138  & 0 & 136  & 0 &1,45 \cr\hline
Método sem parâmetro  	& 94 & 0 & 90 & 0 & 4,25  \cr
e valor de retorno 		& & & &	&\cr\hline
Método com um parâmetro   	& 98 & 0 & 94 & 0 & 4,08   \cr
e sem valor de retorno 	& &  & & & \cr\hline
Método sem parâmetro 	& 112  & 0  & 104 & 0 & 7,14  \cr
e com valor de retorno 		& & & & & \cr\hline
Método com um parâmetro  	& 126 & 0 & 122 & 0 & 3,17  \cr
e valor de retorno 		& & & & & \cr\hline
Update	 			& 1250  & 0  & 260  & 0 & 79,20  \cr\hline
Dispatcher 			& 0  & 2 *(\# métodos) & 0  & 2*(\# métodos) & 0  \cr\hline
Semaphore 			& 0  & 18 & 0  & 18  & 0  \cr\hline
\hline
\textbf{Tamanho mínimo}  & 1662 & 26  & 664 & 26 &  59,12 \cr
\hline
\end{tabular}
\label{tab:resultado_consumo_memoria_individual} 
\end{center}
\end{table}

A Tabela mostra que o método \texttt{Update} é o maior responsável por esta diminuição. Este método se encontra na classe \texttt{Agent} que é a classe que continha uma grande parte de código que não utilizava informação de tipo, mas mesmo assim era replicada para cada componente marcado como reconfigurável.

\subsection{Tempos de invocação de método}
O tempo de invocação de métodos é avaliado em termos de quantidade de ciclos para realizar uma chamada de método e analisar se houve algum sobre custo neste processo. É uma avaliação importante porque o \textit{framework} deve realizar uma série de atividades antes e depois da invocação de métodos. A Tabela~\ref{tab:resultado_invocacao_metodo} apresenta o tempo de invocação de métodos do ELUS original, modificado e os compara com a chamada de um método normal e através da tabela de métodos virtuais. Percebe-se claramente que  há uma perda de desempenho causada pelo nível de indireção criado entre a aplicação e a invocação do método real através do \textit{framework} metaprogramado.

\begin{table}[!th]
\caption{Comparação dos tempos de invocação de método entre uma invocação normal, através da vtable, do ELUS e do ELUS modificado}
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline 
	\textbf{Invocação}       	& \textbf{Normal} & \textbf{Vtable} & \textbf{ELUS} & \textbf{ELUS Modificado} \\ \hline
	Método sem parâmetro e      & 4 & 13 & 135 & 135\\
	sem valor de retorno		&&&&	\\ \hline
	Método com parâmetro e      & 7 & 15 & 139 & 139\\
	sem valor de retorno 		&&&&	\\ \hline
	Método sem parâmetro e      & 6 & 14 & 152 & 152\\
	com valor de retorno 		&&&&	\\ \hline
	Método com parâmetro e      & 8 & 16 & 161 & 161\\
	com valor de retorno 		&&&&	\\ \hline
\end{tabular}
\label{tab:resultado_invocacao_metodo} 
\end{center}
\end{table}

Apesar de ser uma das partes substituídas para uma tentativa de melhora de desempenho, o resultado numérico das duas versões foi igual. Estudando o código gerado (e.g, \textit{assembly}) para ambas versões pode-se concluir que houve diferença das instruções, mas após a recontagem do número de ciclos utilizados para a invocação de método, este número permaneceu sem alterações.

\subsection{Tempo de Reconfiguração}
A comparação dos tempos de reconfiguração foi medida em dois cenários: (i) o novo código do componente é menor ou igual ao antigo, sendo assim a atualização pode utilizar a mesma posição do componente e (ii) o novo código de um componente é maior que o antigo, em que se faz necessário a alocação de uma nova posição para o componente. Para ser uma comparação justa em relação aos trabalhos relacionados, esse teste não considerou o tempo de recebimento de dados pela rede e nem o tempo de escrita dos dados na memória de programa. O resultado do teste pode ser observado na Tabela \ref{tab:time}.

\begin{table}[!th]
\caption{Comparação dos tempos de reconfiguração para um componente no ELUS e do ELUS modificado, medido em ciclos}
\begin{center}
\begin{tabular}{|c|c|c|} \hline
\textbf{Atualização} & \textbf{ELUS original} & \textbf{ELUS modificado} \\ \hline
%\cline{1-3}
\multicolumn{1}{|c|}{Mesma posição} & 362 & 368 \\ \hline
\multicolumn{1}{|c|}{Nova posição}  & 414 & 397 \\ \hline
\end{tabular}
\end{center}
\label{tab:time}
\end{table}
 
Examinando o tempo de reconfiguração em relação ao ELUS original e os resultados obtidos pelas modificações é possível observar um aumento no tempo da reconfiguração quando o componente é colocado na mesma posição e uma diminuição do tempo em relação à atualização em uma nova posição. Embora este resultado pareça controverso, pode ser facilmente entendido se o código \textit{assembly} gerado tanto pelo ELUS original quanto pelo ELUS modificado forem analisados. Devido à utilização da especialização para ponteiros \textit{void} o código modificado inclui instruções de cálculo e retorno de um valor pela classe \texttt{Base}, que servirá para verificar se é necessário ou não a atualização do endereço da tabela virtual em cada objeto. 

Já a diminuição do tempo da reconfiguração para uma nova posição pode ser associada à quantidade e à ordem das instruções do código modificado, pois a classe \texttt{Base} é responsável por todas as operações, com exceção da atualização do endereço da tabela virtual em cada objeto. O mesmo não ocorre com o ELUS antigo, que realiza este processo através da classe dependente de \textit{template} e precisa realizar verificações relativas ao tipo.

\section{Trabalhos relacionados}
\label{sec:rel}
Contiki \cite{dunkels2004contiki} tem seu \textit{kernel} baseado em eventos com \textit{multithreads} preemptivas para cada um dos processos, sendo que cada um deles possui uma interface \textit{stub}, responsável por redirecionar as chamadas para a interface que possui ponteiros para as implementações das funções relativas ao serviço oferecido. Quando recebe uma mensagem de reconfiguração, o \textit{kernel} disponibiliza uma interface para a passagem de ponteiros entre as duas versões e, no caso de uma remoção de serviço, é enviado um evento no qual o serviço remove-se 
automaticamente do sistema. Contiki não possui o melhor desempenho para a utilização dos recursos, pois apenas para fornecer à reconfiguração dinâmica já é necessário cerca de  6KB de memória, além disso sua chamada de métodos possui vários ciclos de verificações que devem ser realizadas antes e depois da invocação.

SOS \cite{han2005dynamic} é composto por módulos atualizáveis em tempo de execução e programados de forma cooperativa, de tal modo que conseguem enviar mensagens e se comunicar com o \textit{kernel} através de uma tabela com \textit{jumps}. Para a atualização dos módulos existe um protocolo de distribuição que faz o \textit{download} dos dados, também aloca memória para o novo módulo, além de ajustar os ponteiros na tabela e dar inicio ao processo através da mensagem \texttt{init}. Quando a atualização consiste em uma remoção de módulo, o \textit{kernel} envia uma mensagem \texttt{final} para que o módulo libere todos os recursos que está utilizando e informe sua remoção aos módulos que o utilizam. Observando a utilização de recursos este sistema operacional utiliza cerca de 23KB e ainda possui uma grande perda de desempenho para a invocação de métodos, acrescentando mais de 850 ciclos no processo.

O sistema operacional RETOS pretende contornar de forma eficiente limitações de recursos e ainda atingir os seguintes objetivos: fornecer uma interface para programação \textit{multithread}, ter uma abstração orientada à rede de sensores sem fio (RSSF), ser um sistema resiliente e possuir um \textit{kernel} extensível através de reconfiguração dinâmica \cite{cha2007retos}. O RETOS fornece um mecanismo que utiliza relocação dinâmica de memória e ligação em tempo de execução para a reconfiguração dos módulos. Desta maneira, é capaz de gerar metadados a partir de variáveis e funções em tempo de compilação que são armazenados para posteriormente substituir os endereços utilizados pelo módulo quando o mesmo é carregado pelo sistema. Embora utilizar metadados seja uma boa alternativa para a atualização, existe um sobre custo associado à quantidade extra de dados enviados pela rede, o que resulta em uma maior utilização dos recursos energia e memória. 

Já MOS (\textit{MANTIS sensor OS}) \cite{bhatti2005mantis} é um sistema \textit{multithread} que possui suporte à reprogramação dinâmica e acesso remoto via \textit{shell}. MOS consegue economizar energia através de uma implementação diferenciada do escalonador de eventos, em que é possível identificar quando as \textit{threads} estão ativas e controlar o consumo de energia do microcontrolador. A reconfiguração dinâmica é implementada através de uma chamada para uma biblioteca do \textit{kernel} do MOS e ela pode ser realizada em diversas granularidades, variando desde uma variável dentro de \textit{thread} até o sistema operacional inteiro. O baixo consumo de recursos é uma característica forte no MOS, um exemplo é o tamanho total necessário para armazenar suas estruturas, pois, somando o tamanho do \textit{kernel}, do escalonador de enventos e da rede são utilizados menos de 500 \textit{bytes} de RAM e 14KB de memória de programa.

\section{Considerações finais}
\label{sec:conclusao}
Neste artigo apresentou-se um estudo do \textit{framework} do ELUS e uma proposta de melhoria da desempenho da reconfiguração dinâmica realizada pela infraestrutura. A nova abordagem foi avaliada em termos de consumo de memória, tempo de invocação de métodos e tempo de reconfiguração. A especialização através de ponteiros \textit{void} apresentou resultado positivo para o consumo de memória, pois foi possível reduzir cerca de 60\% do consumo e atualmente o tamanho mínimo para um novo componente do sistema passa a ser 664 KB. Já o tempo de invocação de métodos não sofreu alterações, mas ainda é positivo se comparado aos trabalhos relacionados. Por fim, o tempo de reconfiguração de componentes diminuiu cerca de 17 ciclos para um componente em uma nova posição, entretanto, as modificações também foram responsáveis pelo aumento em 6 ciclos no tempo de atualização de um componente na mesma posição. 

Dentre as implementações futuras estão a medição do consumo de energia, que também é um recurso muito importante no domínio de sistemas embarcados e o aumento da reusabilidade do código.

\bibliographystyle{sbc}
\bibliography{paper}

\end{document}
