\section{Autonomous Power Manager}\label{sec:auto}

A considerable fraction of the research effort around power management
at software-level has been dedicated to design and implement
\emph{autonomous power managers} for general-purpose operating systems,
such as \textsc{Windows} and \textsc{Unix}. Today battery-operated
portable computers, including notebooks, PDAs, and high-end cellphones,
can rely on sophisticated management strategies to dynamically control
how the available energy budget is spent by distinct application
processes. Although not directly applicable to the embedded system
realm, those power managers bear concepts that can be promptly reused in
this domain.

As a matter of fact, autonomous power managers grab to a periodically
activated operating system component (e.g. timer, scheduler, or an
specific thread) in order to trigger operation mode changes across
components and thus save energy. For instance, a primitive power manager
could be implemented by simply modifying the operating system scheduler
to put the CPU in standby whenever there are no more tasks to be
executed.  DVS capabilities of underlying hardware can also be easily
exploited by the operating system in order to extend the battery
lifetime at the expense of performance, while battery discharge alarms
can trigger mode changes for peripheral devices~\cite{Aydin:2008}.
Nevertheless, these basic guidelines of power management for personal
computers must be brought to context before they can be deployed in
embedded systems:

\begin{itemize}
\item Embedded systems are often engineered around hardware platforms
  with very limited resources, so the power manager must be designed
  to be as slim as possible, sometimes taking software engineering to
  its limits.

\item Many embedded systems run real-time tasks, therefore a power
  manager for this scenario must be designed in such a way that its own
  execution does not compromise the deadlines of such tasks.
  Furthermore, the decisions taken by an autonomous power manager must
  be in accordance with the requirements of such tasks, since the
  latency of operating mode changes (e.g. waking up a component) may
  impact their deadlines. For a real-time embedded system, having a
  power manager that runs unpredictably might be of consequences similar
  to the infamous garbage collection issues in \textsc{Java}
  systems~\cite{Bacon:2003}.

\item Embedded systems often pay a higher energy bill for peripheral
  devices than for the CPU. Therefore, CPU-centric strategies, such as
  DVS-aware scheduling, must be reviewed to include external devices.
  Thus an active power manager must keep track of peripheral device
  usage and apply some heuristics to change their operating mode along
  the system lifetime.  The decision of which devices will have their
  operating modes changed and when this will occur is mostly based on
  event counters maintained by the power management infrastructure,
  either in hardware or in software.

\item As a matter of fact, critical real-time systems are almost
  always designed considering energy sources that are compatible with
  system demands. Power saving decisions, such as voltage scaling and
  device hibernation, are also made at design-time and thus are also
  taken in consideration while defining the energy budget necessary to
  sustain the system. At first sight, autonomous power management
  might even seem out of scope for critical systems. Nonetheless,
  complex, battery-operated, real-time embedded system, such as
  satellites, autonomous vehicles, and even sensor networks, are often
  modeled around a set of tasks that include both, critical and
  non-critical tasks. A power manager for one such embedded system
  must respect design-time decisions for critical parts while trying
  to optimize energy consumption by non-critical parts.
\end{itemize}

With these premises in mind, the next section briefly surveys the
current scenario for power management in embedded systems.


\subsection{Current Power Managers}

Just like APIs and infrastructures, most of the currently available
embedded system power managers focus on features exported by the
underlying hardware.  \textsc{$\mu$Clinux} captures \textsc{APM},
\textsc{ACPI} or equivalent events to conduct mode transitions for the
CPU and also for devices whose drivers explicitly registered to the
power manager~\cite{Vaddagiri:2004}.

In \textsc{TinyOS}, OS-driven power management is implemented by the
task scheduler, which makes use of the \texttt{StdControl} interface
to start and stop components~\cite{Hill:2000}. When the scheduler
queue is empty, the main processor is put in \emph{sleep} mode.  In
this way, new tasks will only be enqueued during the execution of an
interrupt handler.  This method yields good results for the main
microcontroller, but leaves more aggressive methods, including
starting and stopping peripheral components up to the application.
When compared to \textsc{$\mu$Clinux}, \textsc{TinyOS} delivers a
lighter mechanism, more adequate to embedded systems, yet suffers from
the same limitations with regard to usability and portability.

\textsc{Mantis} uses an \emph{idle} thread as entry point for the
system's power management policies, which put the processor in
\emph{sleep} mode whenever there are no threads waiting to be
executed~\cite{Bhatti:2005}.

\textsc{Grace-OS} is an energy-efficient operating system for mobile
multimedia applications implemented on top of
\textsc{Linux}~\cite{Yuan:2004}. The system combines real-time
scheduling and DVS techniques to dynamically control energy consumption.
The scheduler configures the CPU speed for each task based on a
probabilistic estimation of how many cycles they will need to complete
their computations. Since the systems is targeted at soft real-time
multimedia applications, loosing deadlines due to estimation errors is
tolerated.  \textsc{Grub-PA} follows the same guidelines, but addresses
hard real-time requirements more consistently by imposing DVS
configuration restrictions for this kind of task~\cite{Scordino:2004}.

Niu also proposes an strategy to minimize energy consumption in soft
real-time systems through adjusts in the system QoS
level~\cite{Niu:2005}.  In this proposal, tasks specify CPU QoS
requirements through \texttt{(m,k)} pairs. These pairs are interpreted
by the scheduler as execution constraints, so that a task must meet at
least \texttt{m} deadlines for any \texttt{k} consecutive releases. The
possibility to lose some deadlines enables the scheduler to explore DVS
more efficiently at the cost of preventing its adoption in many (hard
real-time) embedded systems.

Yet in the line of energy savings through adaptive scheduling and QoS,
\textsc{Odyssey} takes the concept of soft real-time to the limit. The
system periodically monitors energy consumption by applications in order
to adjust the level of QoS.  Whenever energy consumption is too high,
the system decreases QoS by selecting lower performance and power
consumption modes.  In this way, system designers are able to specify a
minimum lifetime for the system, which might be achieved by severely
degrading performance~\cite{Flinn:2004}.

\textsc{ECOS} defines a currency, called \emph{currentcy}, that
applications use to \emph{to pay for} system resources~\cite{Zeng:2005}.
The system distributes \emph{currentcies} to tasks periodically
accordingly to an equation that tracks the battery discharge rate as to
ensure a minimum lifetime for the system.  Applications are thus forced
to adapt their execution pace according to their \emph{currentcy}
balances.  This strategy has one major advantage over others discussed
so far in this paper: the \emph{currentcy} concept encompasses not only
the energy spent by the CPU (to adjust DVS configuration), but the
energy spent by the system as a whole, including all peripheral devices.

Harada explores the trade-off between QoS maximization and energy
consumption minimization by allocating processor cycles and defining
operating frequencies with QoS guarantees for two classes of tasks:
real-time (mandatory) and best-effort (optional)~\cite{Harada:2006}.
The division of tasks in two parts, one \emph{mandatory}, that must
always be executed, and another \emph{optional} that is only executed
after ensuring that there are enough resources to execute the mandatory
parts of all tasks is the basic premise behind \emph{Imprecise
  Computation}~\cite{Liu:1994}, which is also one of the foundations of
the power manager proposed in this work.


\subsection{Proposed Power Manager}

From the above discussion about currently available power managers for
embedded system, one can conclude that no single manager consistently
addresses all the points identified earlier in this section: leanness,
real-time conformance, peripheral device control, and design-time
decision awareness. We follow these premises and build on the API
proposed in section~\ref{sec:api} and on the infrastructure presented
in section~\ref{sec:infra} to propose an effective autonomous power
manager for real-time embedded systems.

% - Prepara a proposta
For the envisioned scenarios of battery-operated, real-time, embedded
systems, energy budgets would be defined at design-time based on
critical tasks, while non-critical tasks would be executed on a
best-effort policy, considering not only the availability of time, but
also of energy.  Along with the assumption that an autonomous power
manager cannot interfere with the execution of hard real-time tasks
(i.e., cannot compromise their deadlines), the separation of critical
and non-critical tasks at design-time lead us to the following
scheduling strategy:

% - RT -> EDF, RM, etc, even DVS
% - BE -> only if all RT AND enough energy
% - PM -> run when a BE is canceled to power down devices
\begin{itemize}
\item Hard real-time tasks are handled by the system as mandatory tasks,
  executed independently of the energy available at the moment.  These
  tasks are scheduled according to traditional algorithms such as
  Earliest Deadline First~(EDF) and Rate Monotonic~(RM)~\cite{Liu:1973},
  either in their original shape or extended to support DVS.

\item Best-effort tasks, periodic or not, are assigned lower
  priorities than hard real-time ones and thus are only executed if no
  hard real-time tasks are ready to run.  Furthermore, the decision to
  dispatch a best-effort task must also take in consideration whether
  the remaining energy will be enough to schedule all hard-real time
  tasks.

\item Whenever a best-effort task is prevented from executing due to
  energy limitations, a speculative power manager is activated in order
  to try to change components, including peripheral devices, to less
  energy-demanding operating modes, thus promoting energy savings.
\end{itemize}

% Corolario
With this strategy, the autonomous power manager will only be executed
if energy consumption is detected excessive (i.e. a best-effort task
has been denied execution) and time is available (i.e. a best-effort
task would be executed). Non-interference between power manager and
hard real-time tasks is ensured, in terms of scheduling, by having the
power manager to run in preemptive mode, so that a hard real-time task
would interrupt its execution as soon as it gets ready to run (e.g.
after waiting for the next cycle).

% Needed infrastructure
This scheduling strategy has only small implications in terms of
process management at the operating system level, but require a
comprehensive power management infrastructure, like the one presented
in section~\ref{sec:infra}, in order to be implemented. In particular,
battery monitoring services are needed to support the scheduling
decisions around best-effort tasks and component dependency maps are
needed to avoid power management decisions that could impact the
execution of hard real-time tasks.

% Energy estimation combining battery monitoring and accounting
The battery monitoring service provided by the PM infrastructure can be
combined with the energy accounting service to reduce the costs of
gauging the amount of energy still available to the system. With updated
statistics from the energy accounting infrastructure in hand, the
scheduler can predict battery discharge without having to physically
interact with it, thus sparing the corresponding energy. In this way,
battery monitoring is programmed to take place sporadically based on the
lifetime specified for the system. An additional trigger is bound to the
prediction counter kept by the scheduler, so monitoring also takes place
when power consumption reaches specified thresholds.

% - SO keeps a list of active components
% - PM takes on propagation networks to shut down devices
The operating mode transition networks introduced in
section~\ref{sec:infra} as means to control the propagation of power
management actions from high-level components down to the hardware can
be used by the autonomous power manager to keep track of dependencies
among components. Along with a list of currently active components
maintained by the operating system, these transition networks build
the basis on which peripheral control can be done by the power
manager. For instance, if a task has an open file that is no longer
being used, the power manager could track that component down to a
flash memory and change its operating mode to standby or off.

% - But PM must respect API hints of RT as orders
Nevertheless, the compromise with real-time systems requires our power
manager to take API calls made by hard real-time tasks as ``orders''
instead of ``hints''. We assume that, if a hard real-time task calls the
\texttt{power()} API method on a component to set its operating mode to
\emph{full}, then that component must be kept in that mode even if the
collected statistics indicate that it is no longer being used and thus
would be a good candidate to be shutdown.  Otherwise, the corresponding
task could miss its deadline due to the delay in reactivating that
component.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "pm"
%%% End:
