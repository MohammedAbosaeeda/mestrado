%\documentclass{acm_proc_article-sp}
%\documentclass[10pt,conference,final]{IEEEtran}
\documentclass[preprint,10pt]{sigplanconf}
%\documentclass[10pt]{sigplanconf}

\usepackage[latin1]{inputenc}	% for Latin languages
\usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support
\usepackage{graphicx}
%\usepackage{multirow}
%\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage{color}
\definecolor{Red}{rgb}{.9,0,0}

\include{utils} %new commands 

\begin{document}

%\title{Aspect-oriented Design of Hardware Components}
\title{An AOP-based approach for hardware design}


%IEEE template

%\author{Tiago Rogério Mück and Antônio Augusto Fröhlich\\
%\IEEEauthorblockA{Software/Hardware Integration Lab\\
%Federal University of Santa Catarina\\
%Florianópolis, Brazil\\ 
%Email: \{tiago,guto\}@lisha.ufsc.br}
%}

%\author{Authors omitted for blind review}

%SIGPLAN template

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2005} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\authorinfo{Tiago Rogério Mück \and Antônio Augusto Fröhlich}
           {Software/Hardware Integration Lab\\
           Federal University of Santa Catarina\\
           Florianópolis, Brazil}
           {\{tiago,guto\}@lisha.ufsc.br}


\maketitle



\begin{abstract}
With the increasing complexity of digital hardware designs, hardware description languages are
being pushed to higher levels of abstraction, thus allowing the use of design artifacts which were
previously exclusive to the software domain. In this paper we aim to contribute to this scenario by
proposing artifacts and guidelines for digital hardware design using object-oriented and
aspect-oriented programming concepts. Our methodology is based on features provided by SystemC, a
C++-based hardware description language, and leverages on its synthesizable subset in order to
produce designs suitable for circuit synthesis. Our experimental results show that our design
artifacts provide an increased level of flexibility and reusability at the cost of a small physical
overhead.
\end{abstract}

%IEEE template
%\begin{IEEEkeywords}
%Aspect-oriented programming, digital hardware design, reconfigurable hardware
%\end{IEEEkeywords}

%SIGPLAN template
\category{B.6.3}{LOGIC DESIGN}{Hardware description languages }

\terms
Design, Languages

\keywords
Aspect-oriented Programming, Digital Hardware Design, Hardware Description Languages, SystemC

\section{Introduction}
\label{INTRO}
%Hw design problem, complexity, etc.
%Solution is reuse: OOP solved problems in SW, now in HW too
The complexity of digital hardware design is increasing as the advances of the semiconductor
industry allow the use of sophisticated computational resources in a wider range of applications.
This is leading to a growing interest in high-level methodologies for hardware design. Solutions and
methodologies that have been successfully deployed in the scope of large-scale software systems,
such as \textit{object-oriented programming}~(OOP), are being introduced to hardware design as well.
An example of a \textit{hardware description language}~(HDL) which supports OOP is SystemC, a
C++-based HDL~\cite{Panda:2001}.

HDLs are often used to create descriptions of electronic circuits. These descriptions can be used
either for design verification or for hardware synthesis (i.e. generate the circuit from a
description). Differently from most software programming languages, HDLs are intrinsically parallel
and provide explicit means to describe timing. VHDL~\cite{VHDL:2000} and Verilog~\cite{Verilog:2001}
are the most widely used HDLs and on design at the \textit{register transfer level}~(RTL). In RTL,
circuits are described in terms of the operations between storage elements which are synchronized
using clock signals. In this level, a hardware design may be composed by several \emph{modules}
(analogous to an OOP class), whose instances are interconnected to build the system. However, in
contrast to programming languages, the modules communication is data-driven, and occurs through
signals defined by the modules input/output interface.

The use of OOP-capable HDLs (e.g. SystemC) allows an increased level of flexibility and reusability
in hardware design, however, analogous to software, in hardware some system-wide cross-cutting
concerns still cannot be elegantly encapsulated. For example, in complex circuits, interconnection
of several entities is realized by introducing buses. A bus physically interacts with other
components (e.g. CPU, DMA, ...), but it is difficult to use a module or a class to encapsulate the
bus because its interface and arbitration method has to be implemented in every attached
component~\cite{Engel:2008}. Other examples of crosscutting concerns in hardware designs can be also
found in parts of a system related to its overall functionality or the implementation of
non-functional properties (e.g. fault-tolerance and low-power mechanisms, hardware debugging through
scan chains, clock handling, ...)~\cite{Endoh:2011}. Even by using OOP in hardware, this scattered
code is hard to maintain and bugs may be easily introduced. This motivates the introduction of
\emph{aspect-oriented programming}~(AOP) techniques for hardware design. AOP is expected to provide
the easy encapsulation of cross-cutting concerns and an increase in the overall design quality.

In this paper we describe a digital hardware design method which leverages on SystemC features in
order to enable the implementation of hardware components using OOP and AOP concepts. We propose the
use of a domain engineering strategy which yields components in which its dependencies from the
execution scenario are encapsulated as \emph{aspects} and \emph{configurable features}. These
artifacts can be implemented using only standard C++ metaprogramming~\cite{Czarnecki:2000}, hence
eliminating the need of extra non-standard tools and compilers. Additionally, such features are
within the SystemC synthesizable subset~\cite{systemc_subset}, thus yielding \emph{synthesizable
components}. This significantly distinguishes our approach from previous
works~\cite{Kallel:2010,Liu:2010,Deharbe:2006,FengLiu:2009,Endoh:2011}, which had introduced AOP
features which were not supported by standard hardware synthesis tools, thus allowing only the
simulation of the hardware descriptions. Our method is finally illustrated by the design and
implementation of case studies extracted from a typical embedded system application.

In summary, this work has the following contributions:
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
 \item We provide a comprehensive analysis of related work in the area of AOP applied to the
hardware domain.
 \item We describe an AOP-based method for designing synthesizable hardware components.
 \item We present the design and implementation of a several case studies, which allowed us to
elucidate the tradeoffs of AOP applied to hardware.
\end{itemize}

The remaining of this paper is organized as follows: section \ref{RELATED_WORK} presents a
discussion about related work; sections \ref{PROPOSAL} and \ref{RESULTS} presents our design
methodology and its evaluation through case studies; and section \ref{CONCLUSION} closes the paper
with our conclusions.

\section{Related work}
\label{RELATED_WORK}

%works discussing AOP in hardware
%\cite{Engel:2008} - AOP discussion and proposed VHDL extension / no implementation\newline
%\cite{Bainbridge-Smith:2005} - AOP discussion and proposed new language / few details\newline
%\cite{Burapathana:2005} - very low-level HW design / discussion and proposal / no
%implementation\newline
Several works have already addressed the use of AOP concepts for hardware design. \emph{Engel and
Spinczyk}~\cite{Engel:2008} discussed the nature of crosscutting concerns in VHDL-based hardware
designs and proposed a hypothetical AOP extension for VHDL. However, the work lacks a concrete
implementation and an evaluation of the impact of AOP in the design. In \emph{Bainbridge-Smith and
Park} ~\cite{Bainbridge-Smith:2005} the authors discussed how the separation of concerns may relate
to different levels of algorithmic abstraction. They have mentioned the development of ADH, a new
HDL based on AOP, but further details about ADH are not mentioned. \emph{Burapathana et
al.}~\cite{Burapathana:2005} proposed the use of AOP concepts to sequential logic design.
Nevertheless, they focused on very simple and low level examples like flip-flops and logic gates.

%works that focus on verification
%\cite{Kallel:2010} - TLM\cite{Cai:2003} verification / simulation only / SystemC+AspectC++\newline
%\cite{Liu:2010} - high-level power estimation / simulation only / SystemC+AspectC++\newline
%\cite{Vachharajani:2004} - high-level specification (but AOP features only for verification)/
%simulation only / new language\newline
%\emph{Endoh et al.}~\cite{Endoh:2008} used AOP to enable assertion-based verification in high-level
%hardware design, in which assertions are based on pointcuts instead of specifiers to signal
%changes. They have designed and implemented two assertion languages with pointcut-based assertions,
%ASystemC and ASpecC, which work alongside SystemC and SpecC, respectively. ASystemC uses pointcut
%of AspectC++, and its implementation translates assertions into aspects of AspectC++.
There are also several works which proposed the use of AOP concepts mostly for 
hardware verification. \emph{Kallel et al.}~\cite{Kallel:2010} proposed the use of SystemC and
AspectC++ to implement assertion checkers. The authors focused on the verification of
transaction-level models (TLM)~\cite{Cai:2003} in which transaction state updates are used as
pointcuts. They provide a framework in which the user's verification classes extend base aspect
classes that implement the pointcuts and the verification primitives. In \emph{Vachharajani et
al.}~\cite{Vachharajani:2004} the authors developed the \textit{Liberty Structural
Specification Language}~(LSS). In LSS each module can declare instances which emit certain
events at runtime. These events behave like pointcuts of AOP. Each time a certain state is reached
or a value is computed, the instance will emit the corresponding event and user-defined aspects will
perform statistics calculation and reporting. \emph{Liu et al.}~\cite{Liu:2010} also proposed
AOP-based instrumentation, but focusing high-level power estimation.  They have developed a
methodology based on SystemC in which AspectC++ is used to define special power-aware aspects. 
These aspects are used as configuration files to link power aware libraries with SystemC models.

%works that focus on design
%\cite{Endoh:2011} - component design and verification / simulation only /
%SystemC extension
%\cite{Deharbe:2006} - component design and verification / simulation only /
%SystemC+AspectC++\newline
%\cite{Vax:2007} - modeling and verification (mainly) / simulation only / new language\newline
%\cite{FengLiu:2009} - component design / simulation only / SystemC+AspectC++\newline
%\cite{Jun:2009} - FOP+AOP for hardware design / simulation-only / SystemC\newline
Other works provide AOP features not only for verification, but also for the actual
design of hardware. \emph{D\'{e}harbe and Medeiros}~\cite{Deharbe:2006} present and assess possible
applications of AOP in the context of integrated system design by using SystemC with AspectC++.
Differently from the works discussed previously, they showed how AOP can be used to encapsulate some
functional characteristics of hardware components. They modeled as aspects the replacement policy of
a cache, the data type of an FFT, and the communication protocol between modules. However, only
simulation results are shown and they do not compare the implementation of aspect-based components
against components with all the functionalities hand-coded. In a similar work, \emph{Liu et
al.}~\cite{FengLiu:2009} implemented a SystemC model for a 128-bit floating-point adder and
described the implementation of the same model using AOP techniques. But, synthesis results are not
provided and the two models are compared only in terms of functionality to show that the AOP design
works like the original SystemC-only design. ASystemC~\cite{Endoh:2011} also extends SystemC in a
similar fashion, but, instead of using AspectC++, the authors developed their own aspect weaver.
The new aspect language was introduced through different case studies involving high-level
estimation of circuit size, feature-configurable products, and assertion-based verification.
However, the evaluation of ASystemC has the same flaws of the works discussed above.

Other works in this area follow different approaches. The \emph{e} programming
language~\cite{Vax:2007} was designed for modeling and verification of electronic systems and some
of its mechanisms can be used to support AOP features. Apart from its OOP features, \emph{e} has
some constructs to define the execution order of overloaded methods in inherited classes, which can
be used to define pointcuts and implement aspects. Indeed, this can be used to implement the
behavior of hardware components, but \emph{e} is more focused in high-level specification and there
is not any tool support for synthesis. \emph{Jun et al.}~\cite{Jun:2009} analyzed the application of
\textit{Aspectual Feature Module} ~(AFM)~\cite{Apel:2008} to HDLs. They have implemented a RISC
processor using SystemC and FeatureC++~\cite{Apel:2008}, and showed how AFM enables the incremental
development of hardware through the modularization of code fragments for the implementation of a
function. However, AOP is used only for encapsulation of verification code and the authors
do not provide synthesis results of the resulting code.

%-Discussion
%Most works focus on high-level specification and verification
%There are no related work aiming at using aspects for the actual
%design of synthesizable hardware
In summary, several of the previous works have focused on high-level specification and AOP features
are used mostly for code instrumentation and verification. Also, there are not any related work
aiming at using AOP for the actual design of synthesizable hardware, since, as discussed above, all
works present experiments only at the simulation level and lack a more comprehensive discussion
about the overheads related to the use of AOP.

\section{Designing hardware components using scenario adapters and configurable features}
\label{PROPOSAL}

%-Introduction
%Introduction to ADESD (previously known as AOSD\cite{Froehlich:2001})
%Use the techniques proposed by ADESD and implemented in C++ to
%implement HW components in SystemC
Similarly to previous works, we also based our approach on methodologies which have been used in the
software domain. The \textit{Application-driven Embedded System
Design}~(ADESD)~\cite{Froehlich:2001} methodology elaborates on commonality and variability
analysis---the well-known domain decomposition strategy behind OOP---to add the concept of aspect
identification and separation at early stages of design. It defines a domain engineering strategy
focused on the production of families of scenario-independent components. Dependencies observed
during domain engineering are captured as \emph{aspects}, thus enabling components to be reused on a
variety of execution scenarios with the application of proper \emph{aspects}. This aspect weaving is
performed by constructs called \emph{Scenario adapters}\cite{Froehlich:2000}. The design artifacts
proposed in ADESD were implemented and validated on the \textit{Embedded Parallel Operating System}
(EPOS)~\cite{Froehlich:2001}. EPOS aims to automate the development of dedicated computing systems,
and features a set of tools to select, adapt, and plug components into an application-specific
framework, thus enabling the automatic generation of an application-oriented system instance. EPOS
is implemented in C++ and leverages on \emph{generic programming}~\cite{Czarnecki:2000} techniques
such as \emph{static metaprogramming} in order to achieve high reusability with low overhead.

Whether such guidelines can also be defined for designing hardware has not yet been investigated,
but nonetheless, SystemC enables the introduction of convenient C++ constructs to increase the
quality of hardware designs. This will be demonstrated in the next sections.

%-Describe the design artifacts
%Describe the artifacts belows in terms of hardware (with signals, etc)
\subsection{Scenario adapters}
\label{PROPOSAL:SCENARIO_ADAPTER}
%Scenario adapters\cite{Froehlich:2000}.
Scenario adapters were developed around the idea of components getting in and out of an execution
scenario, allowing actions to be executed at these points, therefore, a scenario must define at
least two different operations: \emph{enter} and \emph{leave}. These actions must take place
respectively before and after each of the component's operation in order to setup the conditions
required by the scenario. For example, in a compressed scenario, enter would be responsible to
decompress the component's input data, while leave would compress its outputs. 

In the software domain, components are objects which communicate using method invocation
(considering an OOP-based approach) and the execution of all operations are naturally sequential, so
the scenario adapters were originally developed to provide means to efficiently wrap the method
calls to an object. However, in the hardware domain, components have input and output signals
instead of a method or function interface (considering an RTL design), and all operations are
intrinsically parallel. These different characteristics required a redefinition of the original
design artifacts.  Figure \ref{fig_scenario_adapters_uml_detail} shows the structure of the new
scenario adapter.

\fig[ht]{.5}{fig_scenario_adapters_uml_detail}
{UML class diagram showing the general structure and behavior of a scenario adapter. The grayed
classes form the basic constructs which can be extended to build scenario-independent components.
The declaration of some signals, methods and parameters are omitted for simplicity.}

SystemC defines hardware components by the specialization of the \emph{sc\_module} class. Components
communicate using special objects called \emph{channels}. SystemC channels can be used to
encapsulate complex communication protocols at register transfer or higher levels of abstraction.
However, these complex channels lie outside the SystemC synthesizable subset, so we use only use
\emph{sc\_in} and \emph{sc\_out} channels, which define simple RTL input and output ports for
components. Methods which implement the component's behavior must be defined as SystemC processes.
In our components we use SystemC clocked threads (\emph{SC\_CTHREAD}), in which all operations are
synchronous to a clock signal. The implementation of the \emph{Component::controller} method
in figure \ref{fig_scenario_adapters_uml_detail} shows the common behavior of a \emph{SC\_CTHREAD}.
SystemC \emph{wait()} statements must be used to synchronize the operations with the clock, in other
words, all operations defined between two \emph{wait()} statements occur in the same clock cycle.

Using these constructs, we define each aspect as a single and independent hardware component
(\emph{Aspect} class). \emph{Enter} and \emph{leave} operations are triggered using a simple
handshaking protocol. With this kind of handshaking communication protocol we can produce more
reusable components, since the number of clock cycles required for each operation is hidden by
the protocol, thus making it easier to synchronize the component execution with the rest of the
design. Figure \ref{fig_scenario_adapters_uml_detail} shows how the class \emph{Aspect\_Common}
encapsulates this protocol. It defines basic input/outputs signals and a SystemC process on which
the aspect behavior is going to execute. Each class defining an aspect inherits from
\emph{Aspect\_Common} and must implement at least two methods: \emph{Aspect::trigger\_behavior},
which defines the behavior executed when an operation is triggered; and
\emph{Aspect::idle\_behavior}, which defines the behavior executed when the aspect is in an idle
state. Notice that the aspects classes derive from template instantiations of \emph{Aspect\_Common}
using themselves as template. This is known as \textit{Curiously Recurring Template
Pattern}~(CRTP)~\cite{Coplien:1995}, and we use it to avoid the use of dynamic polymorphism, which
is not supported for hardware synthesis.

The \emph{Scenario} class represents the execution scenario and incorporates, via aggregation, all
of the aspects which define its characteristics. It defines \emph{enter} and \emph{leave} methods to
encapsulate the implementation of the handshaking protocol which trigger the aspects. Figure
\ref{fig_scenario_adapters_uml_detail} shows how the scenario's \emph{enter} operation could be
implemented. All aspects are triggered at the same time and executes in parallel, however, if
required by the scenario, this can be modified in order to execute each aspect sequentially at the
cost of additional clock cycles. If the aspects execution order is unimportant, the scenario can
have a \emph{configurable feature} to define if the aspects are to be executed sequentially or in
parallel (the concept of \emph{configurable features} is explained in the next section).

The adaptation of the component to the scenario is performed by the \emph{Scenario\_Adapter} 
class via inheritance. This adaptation can be achieved through the separation of the component's
input/output protocol from the implementation of its behavior. A SystemC process
(\emph{Component::controller} method) handles the input/output protocol (\emph{Component::behavior}
method) and calls the requested operations, which are each implemented in its own methods. These
methods are overridden in the \emph{Scenario\_Adapter} class, which wraps the original methods with
calls to the scenario's enter and leave. Notice that, although scattered through a class hierarchy
and different methods, all operations (from the handling of the component's input/output protocol,
to the triggering of the aspects) executes inside the \emph{Component::controller}
\emph{SC\_CTHREAD} process. For the proposed scheme to work, \emph{wait()} statements are also used
to schedule the operations among the clock cycles, instead of defining explicit state machines. If
the latter is used, it would not be possible to elegantly implement the structure described in
figure \ref{fig_scenario_adapters_uml_detail}, since a state machine would require manual
intervention in the component to add the operation defined by the scenario.

%Figure \ref{fig_scenario_adapters_block}
%also show how the design entities interacts by using a representation which is closer
%to the physical implementation.
%\fig{.6}{fig_scenario_adapters_block}
%{Block diagram showing the general structure of a scenario adapter.}  

\subsection{Configurable features}
\label{PROPOSAL:CONF_FEATURES}
%Configurable features using static metaprogramming.

Additionally to the analysis and domain engineering process, several characteristics can be
identified as configurable features of the components. In fact, such characteristics represent fine
variations within a component, which can be set in order to change slightly its behavior or
structure. Figure \ref{fig_config_features_uml} shows how this features can be implemented using
static metaprogramming~\cite{Czarnecki:2000} techniques. Special template classes called
\emph{Traits} are used to define which characteristics of each component is activated. Metaprograms
are then used to conditionally modify the component behavior or modify its structure through
inheritance.

\fig{.5}{fig_config_features_uml}
{Components behavior and structure modified by configurable features}

In the examples in figure \ref{fig_config_features_uml}, additional behavior is executed inside
\emph{Component::operation} if the feature \emph{feature\_1} is enabled. Since the condition in the
\emph{if statement} can be statically evaluated, the additional code is completely optimized away by
the synthesis tool when the condition is false. The other example shows how we can define the base
class of \emph{Component} as a configurable feature. This is easily achieved through a
\emph{metaprogram} implemented using partial template specialization.


\subsection{ADESD and classic AOP}
%-Discussion: ADESD X classic AOP (for hardware design)
%Basically, needs to justify the use of the above artifacts for HW design
%instead of other stuff proposed by other authors
%Using AspectC++ for example allows for full AOP in SystemC 
%(more powerful then scenario adapters), so why don't we use it ?
%The resulting code is not synthesizable, AspectC++ introduces dynamic pointers
%and objects outside the SystemC synthesizable subset (strong claim, actually needs further
%investigation)
%Most of the examples in the related works used have design problems that could be 
%more elegantly solved using other techniques rather than AOP (e.g. inheritance, 
%template parameters -- when using C++/SystemC)\cite{Afonso:2007, Deharbe:2006}
%The remaining problems can be easily solved by scenario adapters
%Only standard languages features are used. No extensions or extra tools are required.
%Can use OOP + scenario adapters + static metaprogramming and still remains within the
%SystemC synthesizable subset.
%Maybe talk something about homogeneous and heterogeneous crosscutting~\cite{Jun:2009}

Several previous works have already discussed aspect-oriented hardware design using SystemC and
proposed solutions based on classic AOP concepts using the well known AspectC++ language. Indeed,
AspectC++ provides more powerful mechanisms for aspect implementation then ADESD, especially when it
comes to the definition of the pointcut, however, this additional mechanisms are usually either
unnecessary or can be efficiently replaced. For example, the aspects shown in \emph{D\'{e}harbe and
Medeiros}~\cite{Deharbe:2006}~(section \ref{RELATED_WORK}) could be more elegantly implemented using
other standard C++ features like inheritance and templates parameters. In the scope of ADESD, we can
say that scenario adapters can be used to implement \emph{homogeneous crosscutting}~\cite{Jun:2009}
(the process of adding the same behavior for all classes). \emph{Heterogeneous
crosscutting}~\cite{Jun:2009}(when a concern is specific to a certain component or family of
components) can be easily implemented with standard OOP (e.g. inheritance) and configurable
features.
 
Another advantage of ADESD over the methodologies proposed previously, is the implementation of its 
mechanisms, which can be realized using only standard SystemC features. No extensions to the
language or extra steps in the design flow are required. Previous works focus on tools and
mechanisms that were deployed originally for software development (e.g. AspectC++), therefore
limiting its use for the generation of synthesizable hardware. For example, AspectC++ introduces
dynamic pointers and objects that are outside the SystemC synthesizable
subset~\cite{systemc_subset}, thus allowing for the development of simulation-only models. This also
limits the evaluation of the physical overheads (e.g. silicon area and performance) associated to
AOP.

As can be seen in the following sections, the use of OOP, scenario adapters, and configurable
features yield synthesizable code, thus enabling the use of ADESD's mechanisms in all levels of the 
design process.


\section{Experimental results}
\label{RESULTS}
In this section we describe the experimental results for the evaluation of our approach. First, we
describe the components which are part of our case studies along with the scenario aspects that we
have identified. Then, we provide an evaluation of the designs, considering both hardware synthesis
results and code quality metrics.

\subsection{Case studies}
\label{CASE_STUDY}
We have analyzed a \textit{Private Automatic Branch Exchange} (PABX) application from one of our
industry partners and designed some of its basic building blocks using the proposed design
artifacts. The basic components defined as case studies are described below. All of them
were designed according to the guidelines described in sections \ref{PROPOSAL:SCENARIO_ADAPTER} and
\ref{PROPOSAL:CONF_FEATURES}.

\begin{description}
    \item[Resource scheduler]: a hardware implementation of the EPOS's
scheduler~\cite{Froehlich:2001,Marcondes:2009:2}. A scheduler may perform operations both
synchronously (upon request by another component) or asynchronously (by preempting the execution of
another component). Furthermore, a hardware-implemented scheduler can provide deterministic
execution time, eliminating jitter and improving the support of real-time applications. This can
provide a major impact in the PABX system, since any new command received in the PABX central is
handled in software by a new thread.
    
    \item[FIR filter]: \textit{finite impulse response}~(FIR) filters are the most used and well
known components in digital hardware design and digital signal processing, thus offering a high
reuse potential in a wide range of application domains. This motivated a careful and flexible
design. The main feature of our filter is the support to both complex and real arithmetic by
using configurable features.
    
    \item[DTMF detector]: the \textit{Dual-Tone Multi-Frequency}~(DTMF) detector is one of the
basic building blocks of any PABX system. The DTMF detector receives signals sampled from the phone
lines connected to the central and detects DTMF tones.
\end{description}


\subsection{Scenario aspects}
We have identified two different execution scenarios in our application domain. A \emph{debugged}
scenario, in which on-chip debugging is required, and a \emph{compressed} scenario, in which
compression and decompression of audio data is required. Figure \ref{fig_all_aspects_uml_lite}
shows the aspects implemented for each scenario and their interface. The aspects inherit the basic
handshaking protocol from \emph{Aspect\_Common} (section \ref{PROPOSAL:SCENARIO_ADAPTER}) and
implement only their specific interface and operations. More details about the scenarios and its
aspects are given below.

\figTC{.5}{fig_all_aspects_uml_lite}
{The debug and compression scenarios implemented}

\begin{description}
  \item[Debugged scenario]: the upper part of figure \ref{fig_all_aspects_uml_lite} shows the
aspects that can be part of a debugged scenario. Unlike previous works, which focused mostly on
simulation-time tracing and logging, we have focused on \emph{design for
testability}~\cite{Williams:1983} and implemented aspects for on-chip debugging using a JTAG scan
chain. The implemented aspects define the following debugging functionalities: \emph{Watched} causes
the state of a component to be dumped every time it is modified; \emph{Traced} causes every
operation execution to be signalized; and \emph{Profiled} counts the number of clock cycles used by
the component for each operation.

  \item[Compressed scenario]: the lower part of figure \ref{fig_all_aspects_uml_lite} shows the
aspects that can be part of a compressed scenario. These aspects provide means to compress digital
signals, thus reducing the number bits required to represent them. The
\emph{Dynamic\_Range\_Compression} aspect provides operations to compress or expand the dynamic
range of a signal (i.e. the largest and smallest possible values of a signal) using a linear
transformation. The \emph{ADPCM\_Encoder/Decoder} aspects implement the same operations using an
\emph{adaptative differential pulse-code modulation}~(ADPCM) algorithm~\cite{adpcm} to convert
16-bit samples to 4-bit samples.
\end{description}


\subsection{Scenario adapters implementation}
%TODO maybe include EPOS-framework-like picture explaining the compilation flow and talk about the
%framework

Figure \ref{fig_case_study_all} shows how we have applied the aspects using scenario adapters (for
simplicity, some details such as methods, ports, and hierarchies are omitted). The highlighted
components are the scenarios adapters, which applies the scenario aspects to the components, as
described in section \ref{PROPOSAL}. The \emph{Debugged\_Scenario} class incorporates the aspects
\emph{Profiled}, \emph{Traced}, and \emph{Watched}. The \emph{Compressed\_Scenario} class
incorporates the aspects \emph{Dynamic\_Range\_Compression}, \emph{ADPCM\_Encoder}, and
\emph{ADPCM\_Decoder}. In our application domain, the compression aspects may not be used together.
For this reason, the aspects which are part of the \emph{Compressed\_Scenario} are defined as
configurable features. When \emph{ADPCM} is enabled, the scenario includes ADPCM encoding/decoding;
when \emph{Dynamic Range} is enabled, the scenario includes dynamic range compression.

\figTC{.5}{fig_case_study_all}
{Overview of the aspect-oriented design. The highlighted components are the scenario adapters
implemented as case studies.}

\subsection{Evaluation}
We have evaluated the efficiency and code quality of our case studies by comparing the
aspect-oriented implementation described previously with an object-oriented-only implementation in
which the aspects behavior are \emph{hand-coded} in the core components. To evaluate the efficiency
we have synthesized the designs to a physical circuit in a \textit{field-programmable gate
array}~(FPGA), and to evaluate the design quality we have analyzed the number of \emph{lines of
code} in each case study. The three case studies mentioned in the subsequent evaluation are
described below.

\begin{description}
    \item[Case 1 - Debugged scheduler]: the \emph{Scheduler\_Adapter} class implements the scenario
adapter for our scheduler. It inherits from the \emph{Scheduler} and \emph{Debugged\_Scenario}
classes, adding support for on-chip debugging.

    \item[]\textbf{Case 2 - Debugged FIR filer with dynamic range compression}: the
\emph{FIR\_Adapter} class inherits from\\ \emph{Debugged\_Scenario} and \emph{Compressed\_Scenario},
thus adapting \emph{FIR} for both scenarios. In this case study the configurable feature
\emph{ADPCM} is disabled, while \emph{Dynamic range} is enabled. The final implementation compresses
the samples before the filter, and expands them afterwards, thus trading-off precision for resource
consumption.

    \item[Case 3 - Debugged DTMF detector with ADPCM]: the \emph{DTMF\_Detector\_Adapter} follows
the same approach of \emph{FIR\_Adapter}. However, in this case study, the configurable feature
\emph{ADPCM} is enabled. The final implementation can now be used in a scenario in which the data
is ADPCM-encoded.
\end{description}

\subsubsection{Design quality evaluation}

Tables \ref{tab_results_code_modules} and \ref{tab_results_code_cs} show the number of lines of code
in each class and in each case study, respectively. In order to provide an accurate evaluation, we
have considered different metrics in the code analysis. \emph{Declarations} are the lines of code
used for class's attributes declaration, which includes the declaration of constants, ports,
modules, and signals. \emph{Behavior} includes only the body of methods implementing
behavior. \emph{Interconnection} are the lines of code used to define the interconnection among
modules and SystemC processes declaration (i.e. the content of the constructor method of classes
which inherit from \emph{sc\_module}). \emph{Other} includes the remaining lines.

\tabTC[ht]{tab_results_code_modules}
{Number of lines of code used to implement the case studies modules}

\tabTC[ht]{tab_results_code_cs}
{Number of lines of code used to implement the scenarios and adapters in each case study}

Table \ref{tab_results_code_modules} shows the number of lines of code in each module. For modules
which are implemented using more than one C++ class, the respective column includes the information
for the entire class hierarchy. The number of lines in common superclasses such as \emph{sc\_module}
and \emph{Aspect\_Common} is not considered. Table \ref{tab_results_code_cs} summarizes the
information for each case study. The columns \emph{Scenarios + Adapter} show the
number of lines in the classes which implement the scenario and the adapter. The columns
\emph{Total SA} shows the total number of lines in each case study, this includes the number of
lines in column \emph{Scenarios + Adapter} plus the number of lines in the core components and the
aspects included in the scenario (from table \ref{tab_results_code_modules}). The columns
\emph{Total HC} show the number of lines when our approach is not used and the aspects are
hand-coded in the core components.

The results show that there is a considerable increase in the number of written lines of code when
scenario adapters are used. However, most of the additional code comes from the declaration and
interconnection of new modules and classes yielded by the scenario--adapter hierarchy. When
considering only code describing the actual behavior, the difference between the scenario-adapted
and the hand-coded case studies ranges from $2.9\%$ (case study 1) to $111\%$. 

Table \ref{tab_results_code_total} shows the total number of lines of code when the three case
studies are considered together. The difference in the total number of lines now falls to $18.1\%$, 
and to $1.8\%$ when only behavior is considered. This highlights the impact of reusability when we
use scenario adapters, since the classes which implement the debugging aspects and scenario are
reused in all case studies. Yet, the hand-coded cases still yield smaller designs, however, the
number of lines increased in a higher rate from table \ref{tab_results_code_cs} to table
\ref{tab_results_code_total}. Figure \ref{fig_lines_approximation} shows this increase for both the
scenario-adapted and hand-coded study cases. We have used the data from tables
\ref{tab_results_code_cs}-\ref{tab_results_code_total} and a regression function to approximate the
average number of lines in designs composed by an increasing number of components. While the
complexity of scenario-adapted designs increases in a logarithmic rate, for hand-coded design the
increase is linear.

\tab[ht]{tab_results_code_total}
{Total number of lines of code }

\fig{.5}{fig_lines_approximation}
{Estimation of the number of lines of codes in a design}

\subsubsection{Efficiency evaluation}

In order to evaluate the efficiency of our approach, we have synthesized our design to physical
circuits targeting a FPGA and analyzed their performance and size (area). Figure
\ref{fig_synth_flow} shows the synthesis flow. The SystemC designs are first converted to VHDL
descriptions using Celoxica's Agility 1.3. Then, Xilinx ISE 13.1 is used for both logic synthesis
and place-and-route (the process of fitting a circuit for a specific FPGA device). As our target
device we have chosen a Xilinx Virtex6 XC6VLX240T FPGA.

\fig{.55}{fig_synth_flow}
{Design synthesis flow targeting FPGAs}

Table \ref{tab_results_fpga} shows the number of \textit{slices} used (a configurable logic element
in Xilinx's FPGA) and the \textit{longest path delay}~(LPD) of the three case studies. The LPD
represents the performance of the circuit, while the number of slices is used to evaluate the area.
The results show that the use of scenario adapters yields a very low overhead in terms of both
resource consumption and performance. The average area of the scenario-adapted components is about
$2\%$ higher than the hand-coded components. This small overhead comes basically from the additional
signal and registers required by the handshaking protocol that is used to trigger the aspects, which
is not required when everything is coded within a single SystemC module. The average difference in
performance is also small($0.78\%$). Curiously, in the first case study, the hand-coded design has
a smaller LPD. This may be the result of some optimization algorithm applied in the place-and-route
backend.

\tab[ht]{tab_results_fpga}
{FPGA synthesis results}


\section{Conclusion}
\label{CONCLUSION}
In this paper we have introduced an AOP-based method for designing hardware components using
SystemC. We have shown how our domain engineering strategy can be applied by designing and
implementing hardware components with different characteristics. The components dependencies
from different specific execution scenarios were successfully encapsulated and further applied to
the core components through the use of scenario adapters and configurable features.

The reusability of components based on our design artifacts was evaluated by analyzing the
number of lines of code from different perspectives. The analysis showed that most of the extra code
yielded by the scenario adapters comes from the syntax characteristics of SystemC and from the
description of the interconnection between components. In a future work, such code could be
automatically generated by an aspect weaver, thus greatly reducing the coding effort. Indeed, our
code analysis even shows that the number of lines of code in our AOP-based designs increases in a
logarithmic rate, while a common OOP approach yields a linear rate. In addition, we have also
focused in the design of synthesizable hardware components, rather than verification and
simulation-only models. The synthesis results showed that our design artifacts can not only increase
reusability but also be efficiently synthesized to physical hardware.


%\section*{Acknowledgments}
%This work was partially supported by the 
%\emph{Coordination for Improvement of Higher Level Personnel}~(CAPES) grant,
%projects RH-TVD 006/2008 and 240/2008. 

%\bibliographystyle{IEEEtran}
\bibliographystyle{abbrvnat}
\bibliography{paper}

\end{document}
