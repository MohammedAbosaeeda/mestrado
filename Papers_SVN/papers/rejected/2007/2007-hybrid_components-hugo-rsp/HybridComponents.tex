%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title: Allowing Design Space Exploration through a Hybrid Hw/Sw Component
%        Architecture
% Autor: Hugo Marcondes
% Co-autores: Antonio Augusto M. Fröhlich and Fabiano Hessel
% Problem: Embedded System Design
% Problem's Nature: Hybrid Hw/Sw Component Archictecture
% Scope: Design Space Exploration
% Contribution: An architecture for exploring design space, through hybrid
%		Hw/Sw Components
% Case Studies: Semaphore (Hw is analogous to Sw)
%		Scheduler (Sw is analogous to Hw)
%
% Initial Literature:
%   David Andrews
%   Ahmed A. Jerraya
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[twocolumn]{article}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage{latex8}
\usepackage{graphicx}

\newcommand{\epos}{\textsc{Epos}}
\newcommand{\aosd}{Application Oriented System Design}
\newcommand{\fig}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

\pagestyle{empty}

\begin{document}

\title{Allowing Design Space Exploration through a Hybrid Hw/Sw Component
Architecture}

\author{Hugo Marcondes, Antônio Augusto M. Fröhlich\\
	%LISHA - INE - UFSC\\
        Federal University of Santa Catarina\\
        Laboratory for Software and Hardware Integration\\
        PO Box 476, 88049-900\\ Florianópolis, SC, Brazil\\
        \{hugom,guto\}@lisha.ufsc.br\\
	\and
	Fabiano Passuelo Hessel\\
	%PPGCC - FACIN - PUC-RS\\
	Pontifical Catholic University of Rio Grande do Sul\\
        Post-graduation in Computer Science\\
        Av. Ipiranga 6681, 90619-900\\ Porto Alegre, RS, Brazil\\
	hessel@inf.pucrs.br\\
}

\maketitle
\thispagestyle{empty}
\begin{abstract}
Design space exploration helps the developer determine the best compromise
between the metrics involved in the design of embedded systems.
For successful use of it, is important that the system has the ability to adapt
itself in order to achieve the desired metrics of development, specially the
partition of components between hardware and software. We define hybrid
hardware/software component as a software engineering construct that freely
combine hardware and software elements. Nonetheless, devising the proper
interface for such a component is certainly not a straightforward task. This
paper presents a strategy to handle the construction of a hybrid
hardware/software component \emph{architecture} that delivers architectural
transparency to clients, enabling an effective design space exploration.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction\label{sec:intro}}

% AOSD as a ES design methodology
% - AOSD overview
% - AOSD and Hardware mediators
Embedded systems are pervasive in our daily lives, from brake control
systems in our vehicles to smart appliances in our homes. Hardware
production technology advances and manufacturing costs reductions have
promoted the development and popularization of very complex embedded
applications. In this sense, the Application-Oriented System
Design~(AOSD) methodology~\cite{Frohlich:2001} guides the development of
embedded systems through a domain engineering process that aims at
yielding components that can be promptly reused in a variety of
application-specific systems. The portability of such components---and
thus of applications using them---across distinct hardware platforms is
achieved by means of a construct named \emph{hardware mediator}, which
defines a hardware/software interface contract between higher-level
components and the hardware~\cite{Polpeta:2004}.

% Hardware Mediators and Hybrid Components
% - HM -> GP
% - Example
Hardware mediators are meant to be implemented using Generative
Programming techniques~\cite{Czarnecki:2000} and, instead of building an
ordinary \emph{Hardware Abstraction Layer}~(HAL), implicitly adapt
existing hardware components to match the required interface by adding
software to client components. For example, the hardware mediator for a
hardware component that already presents the desired interface would be
totally eliminated during the system generation process; while the
hardware mediator for a hardware component that does not provide all the
desired functionality could exceed the role of interface and include
software elements to complement the hardware functionality.

% Hybrid Components
% - FPGAs
Indirectly, the concept of hardware mediator defines a kind of
\emph{hybrid hardware/software component}, since different mediator
implementations can exist for the same hardware component, each designed
around a particular set of goals such as performance and energy
efficiency.  If the hardware platform can be itself synthesised---as is
the case with IP-based platforms---then the notion of a hybrid component
becomes even more appealing, since some hardware mediators could exist
in different pre-validated combinations of hardware and software.

% Hybrid components and Design Space Exploration
% - Pre-validated components -> cost model
The idea of \emph{hybrid hardware/software component} behind AOSD
hardware mediators also constitutes an important tool for design space
exploration. The fact that hybrid components in this sense exist in
advance enables a scenery in which components can be tagged with
information about required silicon area and features, energy
consumption, performance, reliability, cost (e.g. associated royalties),
and whatever other metric becomes convenient, thus sustaining an
effective exploration of design space.

% - How to design and implement HC?
Nonetheless, devising the proper interface for a hybrid
component---specially the more complex ones, such as CODECs, storage
systems, and interconnects---and designing it in a way that is flexible
enough to support implementations that freely combine hardware and
software elements is certainly not a straightforward task. This paper
presents a strategy to handle these issues through a well-defined hybrid
hardware/software component \emph{architecture}. This architecture
emerged during the implementation of several hybrid components in the
scope of the Embedded Systems Development Environment
Project~(PDSCE)\footnote{The PDSCE Project is funded by FINEP grant no.
  01.04.0903.00.}.

% - Paper Structure
The forthcoming sections are dedicated to explain the hardware mediator
construct and its connotation of hybrid component in depth, to present
the case studies that yielded the proposed hybrid component
architecture, and to discuss the architecture itself.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Application-Oriented System Design\label{sec:AOSD}}

% AOSD
% - Intro, history, features
Application-Oriented System Design~(AOSD) is a domain engineering
methodology that elaborates on the well-known domain decomposition
strategies behind Family-Based Design~(FBD) and Object-Orientation~(OO),
i.e. \emph{commonality} and \emph{variability} analysis, to add the
concept of \emph{aspect} identification and separation yet at the early
stages of design~\cite{Frohlich:2001}. In this way, AOSD guides a domain
engineering towards families of components, of which execution scenario
dependencies are factored out as "aspects" and external relationships
are captured in a component framework. This domain engineering strategy
consistently addresses some of the most relevant issues in
component-based development:

\begin{description}

\item [Reusability:] components tend to be highly reusable, for they are
  modeled as abstractions of real elements of a given domain and not as
  parts of a target system. Moreover, by factoring out execution
  scenario dependencies as aspects, components can be reused unmodified
  in a variety of scenarios simply by defining new aspect programs.

\item [Complexity management:] the identification and separation of
  execution scenario dependencies implicitly reduces the number of
  components in each family, since those components that would have been
  modeled to express a variation in the domain that originates from a
  scenario dependency are suppressed whenever the dependency can be
  modelled as an aspect. Simply stated, a set of 100 components could be
  modeled as a set of 10 components plus a set of 10 aspects and a
  mechanism to apply aspects to components. The overall complexity (and
  functionality) in the new set of 100 generated components is the same,
  but it is now confined in fewer constructs. This directly improves on
  maintainability.

\item [Composability:] by capturing component relationships in a
  component framework, AOSD enables components to be more easily
  combined while generating a system instance. It also put some limits
  to the misbehaviors that can arise from applying aspect programs to
  pre-validated components. \emph{Feature-based models} are of great
  value at this point to capture configuration knowledge and thus make
  system generation a more predictable procedure.

\end{description}

\fig{.6}{aosd_full}{Overview of domain decomposition guided by AOSD.}

Figure~\ref{fig:aosd_full} illustrates the main elements of an AOSD
domain decomposition, with domain entities being captured as
abstractions that are organized in families and exported to users
through comprehensive interfaces. Abstractions designate scenario
independent components, since scenario dependencies are captured as
aspects during design. Subsequent factorization captures configurable
features as constructs that can be reused thorough the family.
Relationships between families of abstractions delineate a component
framework. Each of these elements are subsequently modelled according
with the guidelines of Object-Oriented Design~(OOD).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hybrid Hardware/Software Components\label{sec:HC}}

% Introduce the HC concept
As described in the introduction of this article, \emph{hardware
  mediator} is the concept of AOSD responsible for preserving the
architectural independence of high-level system components. Although the
portability aspect of hardware mediators was consistently discussed in a
previous paper~\cite{Marcondes:ETFA:2006}, illustrating the role of a
hardware mediator with a real case study will be of great use while
trying to demonstrate how hybrid hardware/software components emerge
from it. Therefore, the mediators involved in the management of
processes in \epos\footnote{The EPOS system is currently the main
  laboratory for AOSD experiments.} will be revisited here.

In \epos, processes management is delegated to the \texttt{Thread} and
\texttt{Task} abstractions.  \texttt{Task} abstractions corresponds to
the activities specified in the application program, while
\texttt{Threads} are the entities that perform such activities. Some of
the main requisites and dependencies of these system abstractions are
deeply related with the architecture of the target processor, which is
mediated by the \texttt{CPU} hardware mediator. For example, the
execution context of a process comprises the values stored in
user-visible registers of the processor, and the stack structure is
determined by the Application Binary Interface~(ABI) of the processor.
Details like these are encapsulated in \texttt{CPU} and hidden from
\texttt{Thread} and \texttt{Task}.

\fig{.7}{cpu_family}{Overview of the CPU hardware mediator.}

Figure~\ref{fig:cpu_family} depicts some interface elements of the \texttt{CPU}
mediator. The class \texttt{Context} defines all the internal data
structures that must be stored for any given execution flow. As part of
the \texttt{CPU} mediator, this class is redefined for every new
architecture the system is intended to run on. \texttt{Thread} and
\texttt{Task} simply use it as a black-box. The context of a thread is
thus represented by an object that is dynamically stored on the thread's
stack. A pointer to the location where the context is currently stored
is maintained as an attribute of \texttt{Thread} that is implicitly
updated by the method \texttt{CPU::switch\_context()}.

Another architecture dependency in process management is related to
stack initialization. In \epos, a thread can be created to execute any
ordinary function in the program (i.e., \texttt{Task}), regardless of
the number of parameters it has and also regardless of the fact is
encodes an explicit call to \texttt{Thread::exit()}. In order to sustain
this programming model, the stack of a thread must be pre-initialized
with the corresponding function parameters, as well as a return address
that will properly guide the execution flow throughout
\texttt{Thread::exit()}.  However, compilers for different architectures
use different function calling conventions, and having the
\texttt{Thread} abstraction to manipulate the stack by its own would
render undesirable architectural dependencies. The solution is to have a
meta-program that is able to properly initialize the stack inside the
\texttt{CPU} mediator. This interaction between \texttt{Thread} and
\texttt{CPU} is illustrated by figure~\ref{fig:thread_colaboration}, which
depicts the steps involved in creating (steps 1.*) and scheduling (steps
2.*) threads\footnote{If the \emph{preemptive} feature is enabled then step
1.3 is also considered during thread creation (e.g., higher priority
thread).}.

\fig{.6}{thread_colaboration}{Thread creation and scheduling.}

The \texttt{CPU} hardware mediator also implements some functionality
for other system abstractions, such as bus-locked read-and-write
transactions (i.e., \emph{Test and Set Lock}), which is required by the
\texttt{Synchronizer} family of abstractions, and endianness conversion
(e.g. host to network and CPU to Little Endian) used by
\texttt{Communicator}.  The process scheduling algorithm is itself
implemented by another abstraction that also uses \texttt{CPU}: the
\texttt{Scheduler}.

With this example in mind, it is now easier to elaborate on the idea of
hybrid hardware/software components emanating from hardware mediators.
Consider, for instance, that a soft-core processor has bus-locked
read-and-write memory transactions implemented as a configurable
feature.  Two members of the corresponding hardware mediator family
could deliver the process synchronization mechanism alternatively in
software or hardware and yet preserve the interface contract. These two
mediators could thus be viewed by client components as a single hybrid
component.

More sophisticated combinations could be devised for the
\texttt{Scheduler} component, which could exist in a variety of shapes,
including, for instance, a hardware-mostly implementation that features
timers and queues; a software-mostly implementation that uses an
external timer (\texttt{Alarm} in figure~\ref{fig:thread_colaboration}); a
hardware/software implementation with caches, timers and policies in
hardware, and queues in software.

\fig{.7}{hybrid_component}{Hybrid hardware/software component
  organization.}

The general form of such hybrid components is depicted in
figure~\ref{fig:hybrid_component}. Each hybrid component aggregates a
hardware mediator that interfaces several software and hardware
implementations. These implementations can be selected by the system
developer in order to achieve the best compromise between performance,
cost, energy consumption, silicon area, etc. The main challenge in the
use of hardware mediators to construct a repository of hybrid hw/sw
components is to design them in such a way that the interface with other
components is preserved independently of the fact that sometimes the
component will be implemented in hardware and other times in software.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hybrid Components in PDSCE\label{sec:studies}}

% PDSCE -> TVD -> MUX x CODEC -> VirtexII-PRO
During the PDSCE Project, some hybrid components were developed for
\epos\ as an answer to very distinct application requirements for a same
hardware component. For instance, some digital television applications
developed in the project, in particular the H.222 MPEG multiplex, called
for strict real-time support and guided us toward the design of
hardware-based scheduling and synchronizing components. Another
application, the encoder, had far more trouble with high-performance
algorithms and demanded advanced math support in hardware. Both
applications coexisted on the same base architecture, the VirtexII-Pro,
and used hybrid components selected and configured by \epos\ tools. The
design and implementation of \texttt{Semaphore} and \texttt{Scheduler}
hybrid components will be described next aiming at sustaining the
reasoning about the systematization of the development of hybrid
components presented in the next section.

\SubSection{Semaphore}
% Describe the hybrid semaphore implementation
A semaphore is a synchronization tool represented by a integer variable
that can be accessed only by two \emph{atomic} operations: \texttt{p}
(from the Dutch \emph{proberen}, to test) and \texttt{v} (from Dutch
\emph{verhogen}, to increment). In \epos, this abstraction is realized
by the \texttt{Semaphore} member of the \texttt{Synchronizer} family of
components, which is outlined in figure~\ref{fig:semaphore-sw}.

\fig{.7}{semaphore-sw}{\epos\ family of synchronization components.}

% - Apresentação do IP
% 	- Características
% 	- Funcionamento
% 	- Integração com barramento
Figure~\ref{fig:semaphore-hw} illustrates the organization of the
hardware semaphore IP. Basically, the IP has an internal memory that
stores the semaphore's values and pointers to the blocked threads
queues. The size of the internal memory is proportional to the maximum
number of available semaphores, the maximum number of blocked threads
and the number of bits that represent each semaphore value (e.g.,
32-bits).  The IP was integrated with the PLB bus using the IPIF
interface provided by the \textsc{Xilinx}~\cite{IPIF}. 

When a semaphore is created, the IP performs a search within the
internal memory to find out a free slot. If this operation succeeds,
then the semaphore is set as valid and its \texttt{id} is returned to be
referenced on subsequent commands (i.e., \texttt{p}, \texttt{v}, and
\texttt{destroy}). For a \texttt{p} operation, the client must supply,
in addition to the semaphore's \texttt{id} in the
\texttt{Command\_Register}, a pointer to the running thread in the
\texttt{Thread\_Pointer} register. These information is made available to
the semaphore IP respectively via the \texttt{ID} and \texttt{DATA\_IN}
ports. If the operation causes the semaphore's value to become negative,
then the running thread reference is inserted in the corresponding queue
and a flag in the \texttt{Status\_Register} is set. The associated
software routine can then invoke the scheduler. A \texttt{v} operation
that causes a thread to be resumed reports the thread pointer via the
same register and signalizes a flag on the \texttt{Status\_Register}.

\fig{.4}{semaphore-hw}{Overview of the hardware semaphore organization.}

% The semaphore hybrid component was tested on the H.222 MPEG multiplexer
% developed in the context of the Brazilian Digital Television System
% (\textsc{SBTVD}) and PDSCE project. The multiplexer was implemented on a
% \textsc{ML310} development board from Xilinx which contains a VirtexII-Pro
% XC2V30 FPGA (\textit{Field Programmable Gate Array}) to implement the system.

\subsection{Thread Scheduler}

%Describe the hybrid thread scheduler implementation
The implementation of the scheduler hybrid component was based on the
\texttt{SoRTS} and \texttt{HaRTS} scheduler~\cite{VENTROMILLE:2006}.
For the PDSCE Project, that rate monotonic scheduler was integrate in
\epos\ and gave rise to a hybrid component.
Figure~\ref{fig:scheduler-sw} illustrates the family of schedulers in
\epos. The \texttt{CPU\_Scheduler} abstraction interacts with the
\texttt{CPU} mediator described in section~\ref{sec:HC} to provide the
mechanisms necessary to suspend and resume the execution of threads. A
\texttt{Policy} object is consulted to select a thread to occupy the
processor whenever it becomes idle.

\fig{.7}{scheduler-sw}{\epos\ family of schedulers.}

The hardware scheduler IP is depicted in figure~\ref{fig:scheduler-hw}.
It has four main modules: scheduler, queue control, time control and
interface (IPIF). The \emph{scheduler} module consists of three VHDL
processes: running, ready and fail. The running and ready processes are
responsible for task scheduling, which is done based on dead-line and
period information stored on a per-process basis in the process queue.
The fail process checks for task scheduling failures (e.g. missed
dead-line) in order to provide the scheduler with addition information
and eventually signalizes failures to the main processor by means of
interrupts.  The \emph{time control} module implements a hardware timer
that generates \emph{ticks} for the scheduler. The \emph{queue control}
module implements the scheduler's process list as a joint list of ready
and suspended processes, thus saving FPGA area.

\fig{.4}{scheduler-hw}{Overview of the hardware scheduler organization.}

% As the semaphore hybrid component, the hardware scheduler IP was
% integrated on the PLB bus using the Xilinx IPIF interface and tested on
% the H.222 MPEG multiplexer implementation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An Architecture for Hybrid Components\label{sec:lessons}}

% Intro
% - Review experiments in PDSCE
% - Suggest we have observed important things about HCs
% - Architecture transparency
The development of hybrid components for the PDSCE Project described in
the previous section called our attention to several issues that seems
to be inherent to the design of this kind of component. As mentioned
earlier in this paper, the main issue is certainly architectural
transparency for client components, which expect an hybrid component to
behave identically whether a hardware, software, or mixed implementation
is taken.

% Classes of HCs
% - Viewed by Clients as Synchronous
%   - e.g. Semaphore (interaction with system only at P and V)
% - Viewed by Clients as Asynchronous
%   - e.g. Disk I/O (call-back)
% - Viewed by Clients as Autonomous
%   - e.g. CPU scheduling (timers, contexts, stacks)
Analyzing how client components interact with their providers, we
observed three distinct interaction patterns:

\begin{description}
\item [Synchronous:] observed in components with sequential objects that
  only perform tasks when their methods are explicitly invoked; client
  components are blocked on the method call until service is completed.

\item [Asynchronous:] observed in components around active objects that
  perform tasks when their methods are explicitly invoked, but do not
  block the execution of the client component; some sort of call-back
  mechanism is used to notify the client about service completion.

\item [Autonomous:] components implemented as active objects that
  performs tasks independently of clients; the services provided by the
  component are either ubiquitous or generate events for clients.
\end{description}

% Viewed by Clients as Synchronous
% - EX: any normal object, semaphore
% - SW -> HW: status register polling or semaphore (performance)
% - HW -> SW: method call
The \texttt{Semaphore} component described in section~\ref{sec:studies}
is an example of \emph{synchronous} component, for any action derived
from it originates on the calls to \texttt{p} or \texttt{v}. On the
context of hybrid components, synchronous components can be easily
shifted from software to hardware or vice-versa. When one such component
is moved from software to hardware, the corresponding hardware mediator
must block the clients until the hardware finish the requested service.
This can be implemented on the hardware mediator either by polling a
\emph{status register} (a busy waiting mechanism) or by deploying a
semaphore (an idle waiting alternative).  For the opposite direction,
that is, moving a synchronous component from hardware to software, the
synchronicity is usually implicitly preserved by the method call
mechanism on the processors.

% Viewed by Clients as Asynchronous
% - EX: non-blocking primitives (with call-back), disk I/O
% - SW -> HW: interrupt = call-back
% - HW -> SW: exception, signal = call-back
\emph{Asynchronous} components receive service requests via method calls
just like synchronous ones, but differently from them, they do not block
the calling client until the service is finished, allowing client and
provider components to progress in parallel. Typical examples for this
class of hybrid components are I/O related subsystems, such as file
systems and communication systems. In order to get notifications about
service completion, clients must register call-back functions or event
handlers (e.g. \textsc{Unix} signals). The moving of a asynchronous
component from software to hardware is done by interrupts that activate
the corresponding hardware mediator in order to trigger the original
call-back mechanism.  The opposite direction can be achieved with the
use of concurrent programming techniques such as multithreading, with
the call-back mechanism being triggered by software when the service is
finished (i.e. thread exit).

% Viewed by Clients as Autonomous
% - EX: scheduler
% - SW -> HW: interrupt
% - HW -> SW: interrupt
\emph{Autonomous} components execute their services independently of
explicit client requests. The \texttt{Scheduler} component described in
section~\ref{sec:studies}, along with components such as garbage
collectors and energy managers, is an example of autonomous component.
The activity of this kind of component is usually driven by events. For
instance, a scheduler is usually driven by a timer, a garbage collector
is driven either by a timer or by the realization that the system is
running out of memory, an energy manager is usually driven by activity
counters in combination with power supply status. In this scenario,
moving a hybrid component from software to hardware is feasible as long
as the triggering events can be forward to the hardware component. The
other way around is usually accomplished by having the hardware to
generate interrupts to notify other components about general system
status changes that might result from autonomous activities.

% Generalization
% - HC with mediator that does polling or installs interrupt handlers
While dealing with these three categories of components in the PDSCE
Project we realized that the hardware mediator concept of AOSD is indeed
an underlying architecture for hybrid components. Components modeled
according with AOSD guidelines were successfully transformed in hybrid
components without major redesigns and based on well-know implementation
techniques (i.e. status register polling, interrupts, and event
handling). Furthermore, the interface contract inherent to hardware
mediators is a major architectural transparency means when making a
component hybrid.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work\label{sec:related_work}}
% Intro 
%  - Hardware/Software CoDesign work
%  - Architectural transparency
%  - Integration of components in heterogeneous MPSoC
Several works in the field of hardware/software co-design have addressed
issues pertaining architectural transparency and integration of
components in heterogeneous environments.

%- Jerraya - Hw/Sw Interface CoDesign
Jerraya an Wolf analyses the evolution of Hw/Sw interface codesign
techniques and defines a long-term roadmap for future
success~\cite{JERRAYA:2005}. This work highlight several aspects
presented by hardware mediator, as architectural transparency without
incurring in excessive overhead.

% Mooney
Mooney proposed a framework to generate a partitioned hardware/software
RTOS~\cite{MOONEY:2002}. Independent of task requirements, this approach
generates only one OS that is replicated on every processor. The
designer does not have the flexibility to choose which components are
implemented in software or hardware. Additionally, the designer cannot
control the task mapping onto the target processors.

% Nanako
Nakano implemented a partitioned OS, called STRON (Silicon
TRON)~\cite{NAKANO:1995}. Nevertheless, the system does not allow
choosing which components are going to be implemented in hardware and
which ones are going to be developed in software.

% Cesário - Modelo interessante para gerar componentes com interfaces 
Cesário et al. presents a high-level component-based design methodology
that lets MPSoC designers handle hardware-software interfaces at a high
abstraction level~\cite{CESARIO:2002}. This approach integrates tools
for hardware, software, and cosimulation wrapper generation that aids in
the high-level modeling and generation of efficient hardware-software
interfaces, helping on the development of hybrid components.

%- David Andrews - hThreads - A possible programming model between SW/HW HW/HW
%  interface
Anderson et al. presents the hthreads, a uniform programming model for
specifying application threads running within a hybrid CPU/FPGA
system~\cite{Anderson:2006}. Hthreads provides system service libraries
that encapsulate platform specific operations under pthreads compatible
API's, thus enabling the systematic migration of application functions
through the software/hardware barrier providing an interesting way to
implement asynchronous hybrid components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions\label{sec:conclusions}}

% Paper review
This paper discusses a Hybrid Hw/Sw Components architecture based on the
\emph{hardware mediator} concept of Application-Oriented System Design.
The concept was initially proposed by AOSD as a portability artifact,
and was approached in this paper as a means to support design space
exploration. A \emph{hybrid component} defined around an AOSD hardware
mediator can hide a series of implementations, some pure hardware, some
pure software and some that are a combination of software and hardware.
By tagging hybrid components with design constraints such as silicon
area, energy consumption, and performance, effective exploration can be
sustained.

% Conclusion
% - proposed HC architecture can deliver architectural transparency for client 
%   components 
The development of complex embedded applications in the PDSCE project
corroborated such architecture, as components modeled within this
project were successfully transformed in hybrid components without major
redesigns and based on well-know implementation techniques. Moreover,
this hybrid architecture can deliver architectural transparency for the
client components, a key issue when dealing with design space
exploration.

% Next steps ...
This work is aiming now on the development of new hybrid components in
order to achieve a consistent repository for further research on design
space exploration tools and methods.

\section*{Acknowledgment}
The work in this article is partially supported by FINEP - Financiadora
de Estudos e Projetos under grant no. 01.04.0903.00.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{latex8}
\bibliography{HwSwCoDesign,lisha}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
