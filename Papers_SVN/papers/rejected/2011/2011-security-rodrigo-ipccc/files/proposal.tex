\section{Building a Trustful Infrastructure for WSNs}
\label{sec:solution}
In this Section we describe the EPOSMote II platform, the AES algorithm, our communication protocol stack (TCP/IP/C-MAC), and our security threats countermeasures.

\subsection{EPOSMote}
The EPOSMote is an open hardware project~\cite{eposmote}. 
The project main objective is delivering a hardware platform to allow research on energy harvesting, biointegration, and MEMS-based sensors.
The EPOSMote II platform focus on modularization, and thus is composed by interchangeable modules for each function.
Figure \ref{emote2-mc13224v-pictures-real_white_background} shows the development kit which is slightly larger than a R\$1 coin. 

\fig{.07}{emote2-mc13224v-pictures-real_white_background}{EPOSMote II SDK side-by-side with a R\$1 coin. On the left the sensoring module. On the right the main module.}

Figure \ref{emote2-block_diagram} shows an overview of the EPOSMote II architecture.
Its hardware is designed as a layer architecture composed by a main module,
a sensoring module, and a power module. The main module is responsible for processing
and communication. It is based on the Freescale MC13224V microcontroller~\cite{mc13224v}, which possess 
a 32-bit ARM7 core, an IEEE 802.15.4-compliant transceiver, 128kB of flash memory, 80kB of ROM memory
and 96kB of RAM memory. We have developed a startup sensoring module, which contains some sensors  
(temperature and accelerometer), leds, switches, and a micro USB (that can also be used as power supply). 

\fig{.45}{emote2-block_diagram}{Architectural overview of EPOSMote II.}

\subsection{AES}
Most symmetric-key algorithms require simple hash, rotation, or scrambling operations, which can be efficiently implemented in hardware or software.
On the other hand, asymmetric-key algorithms require exponential operations over a field modulo a large prime number, which are more complex than symmetric-key operations.
Therefore, the symmetric-key technology is more viable on resource constrained low-end devices than the asymmetric-key technology.
Reason why most of security protocols in WSNs literature are based on symmetric-key technology~\cite{Zhou:2008}.

The Advanced Encryption Standard is a symmetric-key algorithm considered to be resistant against mathematical attacks. 
It consists in a block cipher containing a 128-bit block size, with key sizes of 128, 192, and 256 bits.
The hardware-assisted security mechanism present in EPOSMote II supports only key sizes of 128 bits.
It also supports three encryption modes: Counter (CTR), Cipher Block Chaining-Message Authentication Code (CBC-MAC), and the combination of these two modes Counter with CBC-MAC (CCM).
CCM mode provides both confidentiality and authentication, and thus is the mode we use.

\subsection{C-MAC}
C-MAC is a highly configurable MAC protocol for WSNs realized as a framework of
medium access control strategies that can be combined to produce
application-specific protocols~\cite{steiner:2010}. It enables application
programmers to configure several communication parameters (e.g.  synchronization,
contention, error detection, acknowledgment, packing, etc) to adjust the protocol
to the specific needs of their applications. 

Figures~\ref{cmac_act_sync}, \ref{cmac_act_receive}, and~\ref{cmac_act_send} presents C-MAC architecture. 
Each activity in theses diagrams is executed by a microcomponent which can have different implementations.
These microcomponents alongside with the flow control can be combined to produce application-specific protocols.
By using static metaprogramming techniques, microcomponents representing activities that do not make sense for a certain protocol can be completely removed.
When an activity is removed, its inputs are forwarded to the activity targeted by its outputs, still maintaining the original flow semantics.

\fig{.3}{cmac_act_sync}{C-MAC Synchronization Activity Diagram.}
\fig{.3}{cmac_act_receive}{C-MAC Reception Activity Diagram.}
\fig{.3}{cmac_act_send}{C-MAC Transmission Activity Diagram.}

The main C-MAC configuration points include:

\textbf{Physical layer configuration:} These are the configuration points defined
by the underlying transceiver (e.g. frequency, transmit power, date rate).

\textbf{Synchronization and organization:} Provides mechanisms to send or receive
synchronization data to organize the network and synchronize the nodes duty
cycle.

\textbf{Collision-avoidance mechanism:} Defines the contention mechanisms used to
avoid collisions. May be comprised of a carrier sense algorithm (e.g. CSMA-CA),
the exchange of contention packets (\emph{Request to Send} and \emph{Clear to
Send}), or a combination of both.

\textbf{Acknowledgment mechanism:} The exchange of \emph{ack} packets to
determine if the transmission was successful, including preamble acknowledgements.

\textbf{Error handling and security:} Determine which mechanisms will be used to
ensure the consistency of data (e.g. CRC check) and the data security.

C-MAC was evaluated with figures comparable to other MAC protocols for WSNs.
This is due to the use of static metaprogramming techniques (e.g. templates, inline functions, and 
inline assembly), which ensures that configurability does not come at expense of performance or code size. 

Through C-MAC configurability we were able to adequate the MAC functionalities to our needs, instead of using a general non-optimal solution.
Since TCP provides end-to-end reliability and ordered delivery we configured C-MAC in a very simplistic form, disabling acknowledgements and complex synchronization mechanisms.
We decided to use just CSMA and backoff periods to avoid colisions.

\subsection{TCP/IP}
\label{sec:tcp}
Reliable -- in a sense of packet delivery -- transport protocols such as TCP have been tuned for traditional networks made up of wired links and stationary hosts.
TCP performs very well on such networks by adapting to end-to-end delays and packet losses caused by congestion, providing reliability by retransmitting any packet whose acknowledgment is not received within a predefined time.
Due to the relatively low bit-error rates over wired networks, all packet losses are correctly assumed to be because of congestion.
In the presence of the high error rates and intermittent connectivity characteristic of wireless links, TCP reacts to packet losses as it would in the wired environment.
These measures result in an unnecessary reduction in the link's bandwidth utilization, thereby causing a significant degradation in performance in the form of poor throughput and very high interactive delays~\cite{Balakrishnan:1995}.

Focusing on sensor battery's useful life, \textit{Braun and Dunkels}~\cite{Braun:2007} introduces an approach to support energy efficient TCP operation in sensor networks.
The concept called TCP Support for Sensor nodes (TSS) allows intermediate sensor nodes to cache TCP data segments and to perform local retransmissions when they assume that a cached segment has not been received by the successor node towards the destination, by not receiving an acknowledgement packet.
TSS does not require any changes to TCP implementations at end points, and simulations show that it reduces the number of TCP data segment and acknowledgement transmissions in a wireless network.
\textit{Ganesh}~\cite{Ganesh:2009} also introduces a similar mechanism which improves TCP performance, called TCP Segment Caching.

\textit{Elrahim et al.}~\cite{Elrahim:2011} also proposes an energy-efficient way to implement TCP protocol in scenarios with high losses.
They present a modified Congestion Control Algorithm for WSN. 
Since a TCP sender constantly tracks the Round Trip Time (RTT) for its packets, and uses a timeout mechanism to trigger retransmissions in case an ACK is not received before the timer expires.
By increasing the retransmission timeout value, they reduce the number of TCP segment transmissions that are needed to transfer a certain amount of data across a wireless sensor network with relatively high bit/packet error rates.

The size of TCP implementation also is very important when developing for resource-constrained sensors.
NanoTCP~\cite{Jardak:2008}  is a protocol stack for WSNs with reduced overhead.
The low memory consumption of the protocol show its suitability to resource constrained devices.
But nanoTCP is a simplified version of TCP protocol, not respecting its fields and not being compatible.
%However, other implementations such as uIP and lwIP faithfully represent the TCP protocol.
%uIP intended for tiny microcontroller systems where code size and RAM are severly constrained and it only requires 4-5 kilobytes of code space and a few hundred bytes of RAM.
%The other TCP stack, lwIP, is larger than uIP, but provides better throughput.%~\cite{citar uIP e lwIP: http://www.sics.se/~adam/software.html}.

\subsection{Security Threats Countermeasures}
For key management we opted for a centralized key distribution scheme, as shown in Figure~\ref{network_architecture}.
Each sensor shares a unique key with the base station, and no one else.
We assume that most of communication occurs between a node and the base station (data request and reply).
In this case there is no overhead besides the encryption/decryption process.
Two nodes can communicate with each other consulting the base station for authentication.
But, since node to node communication is sporadic, it does not result in large communication overhead.

\fig{.45}{network_architecture}{Network architecture.}

To countermeasure replay attacks we introduce a field in our packet which contains time information.
This time information can be provided by a GPS device. 
Another alternative is to use one of many clock synchronization protocols for WSNs present in the literature~\cite{Fontanelli:2009}~\cite{Fontanelli:2010}~\cite{Swain:2010}.
Using time, the network can protect itself from replay attacks discarding a message that was eavesdropped by an observer and used later in an attack.
Figure~\ref{packet_format} shows our packet format.
Each packet includes our communication protocols headers, the application data, the current time, and the message authentication code.

\fig{.35}{packet_format}{Packet format.}
