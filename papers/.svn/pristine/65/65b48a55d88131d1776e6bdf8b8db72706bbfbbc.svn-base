\note{Políticas tradicionais analisam dinamicamente o comportamento do
sistema e da aplicação. APIs (drivers) rígidas e
incompletas. Padronização num nível muito baixo.}

%%% essa afirmação das APIs/drivers ficou leviana. o foco de critica deveria
%%% ser o 'nivel' da abstracao.

Power management policies in conventional operating system (e.g. Linux,
Windows) dynamically analise the system's behavior in order to determine
when a hardware component should change its operation to a lower or
higher power consumption mode. The software implementation responsible
for those state migrations often rely on hardware-specific interfaces,
which are exported through rigid, and sometimes incomplete APIs
(application programming interfaces) or device drivers. In these
environments, power managing interfaces are standardized in a very low
abstraction level, closer to the actual hardware than the system's
abstractions.


\note{APM e ACPI são ``tentativas'' de padronização. Muito usados, definem
interface entre hardware e software. Não se adaptam a SE.}

%%% A segunda parte ficou muito esquisita, e desconexa. 
%%% Que tem a ver o servidor e o laptop? Porque não
%%% dá pra usar o mesmo procedimento do servidor (desligar qd nao usa)
%%% num SE? Acho que perdeu o foco aqui.

Most general purpose computer hardware devices implement either
\textsc{Apm} (\textit{Advanced Power Management}) or \textsc{Acpi}
(\textit{Advanced Configuration Power Interface}) standard interfaces to
allow power management. Although these standards share little in comon,
their objective is the same: to allow devices to be turned on, off or to
be put in a low power consumption mode for a certain period of time.
These techniques work well in environments such as servers that
frequently do not use certain resources or laptop computers, that may
\emph{suspend to disk} or turn off the system when battery charge is
low. These procedures, however, are hardly ever applicable in embedded
systems.

\note{Diversidade da necessidade das aplicações em termos de consumo
de energia demanda uma granularidade fina de configuração de modos de
operação. PM em computação genérica foca CPU. SE tem que focar
periféricos.}

%%% não é o mesmo objetivo nos dois mundos? economizar, permitindo
%%% operar adequadamente?

Most of the resource in power managing interfaces and techniques is
focused on general purpose computer hardware (e.g. personal computers,
servers, laptop and handheld computers), and many research efforts focus
on managing the consumption of the main microprocessor (CPU), as these
devices are responsible for most of the power consumption in these
systems. In embedded systems, however, processors and microcontrollers
are usually very simples, and consume little power. Most of the power
consumed by these systems comes from peripheral devices. Thus, power
managing for these systems must focus on fine grain techniques that
conserve power from peripheral devices, while allowing the system to
operate properly.


\note{Análise dinâmica não pode ser comportada. Considerando que a
maioria dos SE rodam apenas uma aplicação (computação dedicada), o
melhor lugar pra determinar a estratégia de gerência de energia é na
própria aplicação}

%%% o texto original estava só repetindo o que já tinha sido
%%% dito antes. mudei um pouco, mas acho que ainda não tá 100%.

%%% gerente 'ativo' não "soa" melhor do que gerente 'dinamico'?

Embedded systems often have to deal with severe resource restrictions,
from restricted hardware capabilities (e.g. memory, processing power) or
functional requirements (e.g. availability, real-time responsiveness).
Thus, most embedded systems cannot afford the cost of dynamic, active
power managers. Previous research \cite{1,2,3,4} indicates that the most
efficient power managing techniques are the ones that take into
consideration the behavior of the target applications for a given
system.  Considering that most embedded system perform specific tasks,
and run a single application~\cite{seilaquem}, we may conclude that the
best place to define a power managing strategy is in the application
itself.

\note{Sumarizar a proposta.}

%%% tá bem explicado, mas não fica claro o objetivo. naqueles
%%% itens da introdução acho que tá melhor.

In this paper, we present a software infra-structure that allows
application-driven power management for embedded systems. We provide an
uniform, hardware-independent \textsc{API} (\textit{Application
  Programming Interface}) that allows applications to change operating
modes for every component in an embedded operating system. In order to
ensure correct and deterministic behavior, relations and dependencies
regarding power management for every component are formalized through
Petri Networks. This formalization allows high-level analisys of the
power state migration procedures for every component, and stablishes a
message exchange mechanism in which components coordenate to ensure
consistent power state changes in subsystems (e.g. communication,
processing, sensing), or the system as a whole.


\note{Esta seção descreve a proposta (API, Redes e propagação)}

\note{novamente o nome :-)}

This section describes DSPM, an application-driven, Deterministic Static
Power Manager for embeddded systems. We stablish an \emph{Application
  Programming Interface} (API) implemented by every system component,
that allows changes in the component's power state.  \emph{Migration
  Networks} formalize the changes in operating modes of components or
groups of components (subsystems), and controls components instancies,
allowing the system to know every component that is currently in use and
to propagate systemwide changes in operation modes.

\subsection{Power Managing Interface for Software and Hardware Components}


\note{Foi definida uma API que permite acesso das aplicações aos
  componentes do sistemas, bem como a troca de mensagens entre os
  componentes internos.}

%%% a historia do 'acordar automaticamente' ficou mal-explicada

In our power management strategy, the application programmer is
expected to specify in his source code, whenever ceitain 
components will not be used. Thus, an uniform API to allow power management 
was defined. This interface allows interaction between the application
and the system, between system components and hardware devices,
and directly between application and hardware. In order to
free the application programmer from having to \emph{wakeup}
components whenever they are needed, the power managing mechanism
abstracted by this interface ensures that components return to
their previous operational states whenever they are used.

\largefig{api}{Power Manager API}{.7}

\note{Figura apresentando modos de acesso, dando exemplo em sistema
hipotético}

Figure~\ref{fig:api} presents all these interaction modes in a
hipothetical system instance. The application may access a global
component (\texttt{System}) that has knowledge of every other component
in the system (in this case \texttt{IPC}, \texttt{Processing},
\texttt{Sensing} and their respective underlying components), triggering
a system-wide power mode change. Annother way the application may use
this interface is through subsystems (e.g., \textit{Inter-Process
  Communication} (\texttt{IPC}), \texttt{Processing}, \texttt{Sensing}). In this
way, messages are propagated only to the components used in the
implementation of each subsystem. The application may also acess the
hardware directly, using the API available in the device drivers, such
as \textit{Network Interface Card} (\texttt{NIC}), \texttt{CPU},
\texttt{Thermistor}. The API is also used between the system's
components, as the message exchanges between \texttt{System} and the
three subsystems in the figure illustrates.




\note{Portabilidade e facilidade de desenvolvimento da aplicação.\\
Simplicidade da interface -> facilidade de uso.\\
Modos universais -> evita consulta a manuais de HW.}

In order to attain application portability, and to facilitate
application development, the power managing interface was defined with a
minimal set of methods and universal operating modes with unified
semantics thoughout the system. Portability comes from the fact that the
application doesn't need to implement specific procedures for each
device in order to change its operating mode.  These procedures are
abstracted by the API. Easiness of use comes from the fact that the
application programmer doesn't need to analyse specific hardware manuals
in order to indentify available operating modes, the procedures to
change those modes, and the consequences of these changes.


% Contudo, a API ainda fornece acesso aos componentes de hardware, não
% impedindo que o programador de aplicação gerencie o dispositivo
% diretamente se desejar.


\note{Composição da API:\\
- Métodos de interface 'set' e 'get'.\\
- Relação de modos de operação universais.}

Two methods are defined in the API: one to change the operating mode,
and another to identify the current mode. In addition to these methods,
the API includes a list of modes available to each component. This list
does not have a fixed size, as each component must enumerate in it every
operating mode available. Low-power hardware components often present a
wide range of operating modes. Allowing every mode to be used increses
system configurability, but may increase application complexity and
compromise portability. In order to deal with this issue, a set of high
level universal operations was defined: \texttt{FULL}, \texttt{LIGHT},
\texttt{STANDBY} and \texttt{OFF}.  These modes free the programmer from
having to know details regarding the modes available hardware components
in the system. However, these modes may be extended as necessary. It is
up to the application programmer to associate universal modes to
specific modes available to hardware devices.




\note{Semântica dos modos de operação:\\
- FULL: Alto consumo, todas funcionalidades, máximo desempenho.\\
- LIGHT: Menor consumo, maioria
das funcionalidades (documentação), desempenho degradado.}

When the device is operating at full capacity, it is in the
\texttt{FULL} mode. In this operation mode, the system configures the
device to operate providing its service in the most efficient manner
possible, including all its functionalities, but at full power
consumption. The \texttt{LIGHT} mode puts the device in an operating
mode where it offers most of its functionalities, but consumes less
power than the full mode and, very likely degrades its performance.
Examples of this mode include devices that allow operation in different
voltage supplies or frequencies (\textsc{DVFS} - \textit{Dynamic Voltage
  and Frequency Scaling}). The migration from the \texttt{LIGHT} mode to
the \texttt{FULL} mode is fast, and usually does not imply in
considerable delay for the application.

\note{- STANDBY: Baixíssimo consumo, quase nenhuma funcionalidade, parado.\\
  - OFF: Nenhum (ou mínimo) consumo, nenhuma funcionalidade, parado (RESET).}

In the \texttt{STANDBY} and \texttt{OFF} modes, the device stops
operating.  When in \texttt{STANDBY}, however, the device is ready to
continue operating when necessary, and is able to continue its operation
from the point before it was stoped. An exemple of such a mode is the
``sleep'' modes of a processor. Altough in this mode the device is
stopped, it still consumes a small amount of power. This power is
required to keep the device's internal memory and registers alive until
it is restarted.  In the \texttt{OFF}, however, the device is turned
off, and loses its internal configuration. When a component migrates
from an \texttt{OFF} state to another state, it is reset.

%\note{- Extensão: Comunicação: modos SEND\_ONLY e RECV\_ONLY.\\
%- Outros: definidos especificamente -  portabilidade comprometida.}

%\input{tbl/modos}

\fig[t]{manager}{UML Diagram for the Power Management aspect}{0.55}



\note{Gerênia de energia -> Propriedade não funcional.\\
Adaptador de Cenário para gerenciamento de energia:\\
- Métodos set e get para power.\\
- Variável de estado.}

In addition to the functional requirements, the API should be easily
mantainable and appliable to existing systems, As power management is a
non-functional requirement for operating systems~\cite{Lohmann:2004},
our power management API was modeled as an aspect~\cite{Kiczales:1997},
and may thus be isolated from the rest of the system.
Figure~\ref{fig:manager} presents an UML diagram for this aspect,
representing also its dependancies to other system components.







\note{Compatibilidade dos componentes com o adaptador: Fornecer a API.}


\fig{general_net_behaviour}{Generalized Migration Network Behavior}{.45}

In order for a power management strategy to be properly abstracted as an
aspect, this strategy must be scenario-independent, and appliable to any
component. There is no generic method to implement the migration between
different operating modes, as these procedures are dependant to the
particular characteristics of different devices. Thus, each system
component must implement a method to allow changes in its power state.
This method must be private, and innacessible from the application and
other components whenever the power management aspect has not been
applied to the system.


\subsection{Operation mode migration networks}
\label{sc:migration_nets}

\note{Formalização das migrações entre modos de operação.\\
Redes de Petri devido ao mapeamento envento->condições e à
representatividade gráfica e algébrica:\\
- Transições -> Ações.\\
- Lugares -> Ativadores de ações.\\}



% a explicacao de petri nets ficou horrivel, mas não sei como melhorar.

In order to map coherent conectivity between different abstraction
levels in the system, a formal operating mode migration network was
defined. In this section, we describe this formal mechanism, which was
defined through Petri networks. These networks feature clear graphical
representation, and a wide range of mathematical analisys
models~\cite{Peterson:1977}. These models allow proof of liveness and
reachability of desirable states, as well unreachability of incorrect
states.

\note{Migrações generalizadas. Comportamento da rede
generalizada. Figura simplificada. Rede completa em anexo.}

Altough the procedures to migrate power states are specific to each
component (both software and hardware), the control and dispatch of
these migrations may be expressed in a generic form.  In order to allow
that, a network of mode migrations that specifies the transitions
between different operating modes was formalized.
Figura~\ref{fig:general_net_behaviour} presents a simplified overview of this
network, illustrating the migration of a component from the OFF to the FULL
mode. As illustrated in the figure, there are places associated with the
existing operating modes (FULL and OFF). A resource in these places marks
the component's current operating mode.



\largefig{hierarchical_net}{Hieralquical Petri Network}{0.6}


\note{Descrever sequência de disparo de transições.}

The \texttt{Atomic\_Execution} place is responsible for ensuring that
different mode change operatiions do not execute simultaniously. For
that, this palce is always initialized with one resource. This resource
enables the transactions that enable changes in operating mode. The
moment this transaction is triggered (through a function call to the
power management API), the transactions that would start different
migrations are disabled, as the resource in the
\texttt{Atomic\_Execution} place is consumed. Additionallym a new
resource inserted into the \texttt{Triggering\_FULL} place enables the
transactions that remove the resources that marks the component's
current operating mode (OFF). As the component in the example is in the
OFF state, only the \texttt{OFF\_TO\_FULL} transaction is enabled.  When
this transaction is triggered, the resource that marked the \texttt{OFF}
place is conumed, and three resources are inserted into the
\texttt{FULL\_Enable} place. This anables the \texttt{Enter\_FULL}
transaction, that is responsible for executing the operations that
actually change the component's power mode. After this transaction is
triggered, two resources are inserted into the \texttt{FULL} place,
anebling the \texttt{FULL\_Entered} transaction, which finalizes the
process, consuming the final resource in the \texttt{FULL\_Enable}
place, and inserting one resource back into the
\texttt{Atomic\_Execution} place. The entire process results with a
resource removed from the \texttt{OFF} place and inserted into the
\texttt{FULL} place. In order to avoid deadlocks when transactions that
result in the component's current operating mode, a \texttt{Recurrence}
transaction was inserted into the model. This transaction returns the
resource removed from the \texttt{Atomic\_Execution} place in case of
recurrency.


\note{Provas matemáticas.}

This Petri network was analysed through tradditional Petri net tools,
and was found to be deadlock free, and to have finite reachability.:


\note{Vivacidade -> deadlock free.}


\note{Hierarquia -> Redes de Petri Hierárquicas.}

The generalized network represents the transitions of operating mode
from a high level perspective, where the particular characteristics
involved in the transition of each component are not specified. However,
a refinement process is required in order to allow the inferrence of the
migration proderes from this network model. This refinement explores the
hierarquical characteristic of Petri nets, which allows an entire
network to be replaced by a place or transaction in order to model a
higher level abstraction and, on the other hand, allows places and
transactions to be replaced with sub-networks in order to provide a
refined, more detailed model. Figure~\ref{fig:hierarchical_net} presents
the notation for this representation. In this example, the higher
abstraction network \texttt{P0} abstracts the \texttt{A} sub-network,
and the \texttt{T2} abstracts the \texttt{B} sub-network.


\note{Substituição utilizando subrede para chamada 'Enter'. Exemplo.}

In order to refine the migration procedures responsible for migrating
the operating mode, the \texttt{Enter} transactions are replaced by
sub-networks that implement the migration procedures in higher detail.
Figure~\ref{fig:mac_full} presents the sub-network that implements the
migration of the \texttt{B-MAC} component to the FULL operating mode. In
order to form the migration network for this component, this subnetwork
replaces the \texttt{Enter\_FULL} transaction in the general migration
network. This subnetwork also presents transactions that abstract the
triggering of transactions that change the operating mode of other
components.


\fig[t]{mac_full}{Sub-network implementing the migration procedures for
  the \texttt{B-MAC} component.}{.6}

% \subsubsection{Exemplos}

% Sensor->ADC

% Communicator->...->NIC ::>> Novos problemas aqui.


%\subsubsection{Interpretação estática das redes de migração}

% Meta-programa (Aspecto) implementa o comportamento da rede
% generalizada e utiliza a API para implementar as transições 'Enter'


\subsection{Message Propagation}

\note{Quanto mais componentes, mais complexo o sistema, mais complexo
gerenciar o consumo de energia destes componentes individualmente.}

As the complexity of embedded application increases, more system
components are used. Thus, the control of individual components' power
consumption by the application may be inpracticable. For example,
figure~\ref{prg:app_complexa} presents a hipothetical \emph{power-aware}
application. The application implements a remote monitoring module, that
periodically samples a pressure sensor, and sends the value read through
a GPRS modem. Figure~\ref{prg:app_complexa}(a) illustrates the
complexity resulting from controlling individual components. In this
example, the application must stop the TCP/IP communication stack prior
to turning off a modem, i.e. all pening data must be sent before the
communication may be stopped. After the modem is turned off, the
application turns off the serial ports (UART) used to communicate with
the modem. Similar complexities are present in almost every subsystem.
Abstracting these details enhances the usability of the power management
API, as figures~\ref{prg:app_complexa}(b) and~\ref{prg:app_complexa}(c)
present.


\input{prg/app_evolucao}


% Contudo, sistemas orientados a objeto trazem um fator complicante
% para esta proposta, já que, devido a recursos que permitem
% configurabilidade aos componentes (e.g., recursos de programação
% genérica e polimorfismo), não é possível saber de antemão exatamente
% quais componentes estão sendo utilizados. As seções seguintes
% apresentam a proposta para a solução deste problema.


%\subsubsection{Propagação hierárquica de mensagens}

\note{O que é necessário?\\
  Estabelecer mecanismo de ``comunicação'' entre componentes para
  garantir o correto desligamento dos subsistemas.
}

In order for a subsystem to be deactivated or migrated to low-power
operating modes in an efficient manner, it is necessary to ensure that
the software and hardware artifacts first finalize operations currently
executing, or adapt to the new operating parameters. It is also necessary
to ensure that these subsystems operate correctly after returning to 
their funcional operating modes. Thus, a mechanism and a policy for 
interaction between components must be established.


\note{Como fazer?
  Inferir métodos de troca de modo de operação a partir das redes.
}

Given the presented API and migration networks, it is simple to infer
the migration procedures for each subsystem. The interaction mechanism
is thus formed by message exchanges through the API.  The policy may be
derived from the migration networks for each subsystem. This policy
forms the correct sequence for the migration of each component.
Figure~\ref{fig:mac_full},presents transactions that trigger migrations
in the networks of other components (e.g.,
\texttt{Radio.Trigger\_FULL}). These transactions are the points in
which messages are exchanged between components.


\note{Geração automática dos métodos de migração é realizada através
  da interpretação estática das redes.}

A partir da interpretação destas redes é possível a montagem, em tempo
de compilação, dos métodos que garantirão a sequência correta de
execução dos procedimentos de migração.  No exemplo da
Figura~\ref{fig:mac_full} pode-se observar a conexão de três outras
redes de migração à rede do \texttt{B-MAC} (\texttt{Timer},
\texttt{SPI} e \texttt{Radio}).  O \texttt{B-MAC} é uma implementação
em software de um MAC (Media Access Control) para um módulo de rede de
sensores sem fio~\cite{Mica2}.  Neste dispositivo, a comunicação entre
o processador e o rádio é realizada através de um barramento serial
(SPI).  Neste exemplo, espera-se que a aplicação utilize a API do
componente \texttt{B-MAC} como interface do subsistema de comunicação.
Ao executar um comando ``\texttt{MAC.power(OFF)}'', por exemplo, o
desligamento do subsistema de comunicação deve iniciar pelo
desligamento do próprio \texttt{B-MAC}, que deve esvaziar seus buffers
de envio e desligar o \texttt{Timer} que utiliza para recepções antes
de requisitar que o rádio se desligue.  Como as redes de migração
foram organizadas de modo hierárquico, o resultado final da geração do
procedimento de migração do subsistema de comunicação seria um
procedimento algoritmico como o representado na
Figura~\ref{prg:mignet_mac.cc}.

\prg{C++}{mignet_mac.cc}{Métodos de migração de modo de operação derivados
da redes de migração}

% \fig{mignet_mac}{Rede de Migração do modo de operação STANDBY do \texttt{MAC}}{1}


\begin{description}
\item{\bf{Propagação para todo o sistema}}
\end{description}

\note{Listas de instâncias para acessar todos os componentes.}
Ações de gerência do consumo de energia do sistema como um todo são
tradadas por um componente global do sistema (\texttt{System}). Este
componente contém referências para todos os subsistemas em uso pela
aplicação. Então, se uma aplicação deseja alterar o modo de operação
do sistema inteiro, isto pode ser feito acessando a API deste
componente, que propagará este pedido para todos os subsistemas. Esta
lista deve ser montada em tempo de execução através do aspecto de
gerência de energia, que utilizará as chamadas de construção e
destruição de componentes para, respectivamente, incluir e remover
referências a instâncias de componentes desta lista. Quando a API de
gerência do consumo de energia do sistema é acessada pela aplicação, o
sistema realiza uma varredura pela lista de instâncias que possui,
disparando chamadas às APIs dos componentes que registrou.


\subsubsection{Compartilhamento de recursos}

\note{Hardware compartilhado. Esclarecer problema. Exemplo ADC c/ figura.}
O compartilhamento de recursos é uma característica de sistemas
computacionais que precisa ser tratada nesta proposta. Problemas podem
ocorrer na migração de modos de operação quando componentes de alto
nível compartilham, o mesmo componente de hardware. Por exemplo, uma
aplicação que utiliza dois sensores que compartilham o mesmo conversor
analógico-digital (ADC) multiplexado não pode ter o ADC desligado
devido à solicitação de um dos sensores se o outro sensor ainda o está
utilizando.

\largefig{sensor}{ADC sendo compartilhado por dois sensores.}{.6}

\note{Descrever estrutura de contadores.}
Para resolver este problema, adotou-se um mecanismo de
\emph{contadores de uso}. Cada componente compartilhado possui
contadores que indicam quantos componentes solicitam cada modo de
operação. Sempre que uma chamada é realizada à API, o contador
referente ao estado atual do componente é decrementado, e o contador
referente ao estado pretendido é incrementado. A migração solicitada é
realizada sempre que a maioria absoluta das referências estiverem
contabilizadas em um único contador.

\note{Estudar o problema do roteamento na rede.}