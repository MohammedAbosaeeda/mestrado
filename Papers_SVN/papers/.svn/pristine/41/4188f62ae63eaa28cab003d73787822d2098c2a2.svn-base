+ Changes to makedefs: the following lines were added

MACH_ATMEGA1281	:= atmega1281

$(MACH_ATMEGA1281)_MEM_BASE          := 0x00800100
$(MACH_ATMEGA1281)_MEM_TOP     	     := 0x00801100
$(MACH_ATMEGA1281)_BOOT_ADDR         := 0x00000000
$(MACH_ATMEGA1281)_SETUP_ADDR        := 0x00000000
$(MACH_ATMEGA1281)_INIT_ADDR         := 0x00000000
$(MACH_ATMEGA1281)_SYS_CODE_ADDR     := 0x00000000
$(MACH_ATMEGA1281)_SYS_DATA_ADDR     := 0x00800150
$(MACH_ATMEGA1281)_APP_CODE_ADDR     := 0x00000000
$(MACH_ATMEGA1281)_APP_DATA_ADDR     := 0x00800150
$(MACH_ATMEGA1281)_BOOT_LENGTH_MIN   := 128
$(MACH_ATMEGA1281)_BOOT_LENGTH_MAX   := 512

$(MACH_ATMEGA1281)_CC_FLAGS	:= -mmcu=atmega1281 -Wno-inline
$(MACH_ATMEGA1281)_AS_FLAGS	:= -mmcu=atmega1281
$(MACH_ATMEGA1281)_LD_FLAGS	:= -m avr5
$(MACH_ATMEGA1281)_CODE_NAME	:= .hash
$(MACH_ATMEGA1281)_DATA_NAME	:= .data

+ Changes in src/mach: created the atmega1281 directory

cp -R atmega128 atmega1281
renamed the classes

+ Changes in include/mach: created the atmega1281 directory

cp -R atmega128 atmega1281
renamed the classes

+ Changes to include/system/config.h: the following lines were added

#elif defined (__atmega1281)

#define MACH atmega1281
typedef ATMega1281		        Machine;
typedef ATMega1281_IC		        IC;
typedef ATMega1281_Timer		Timer;
typedef ATMega1281_RTC		        RTC;
typedef ATMega1281_EEPROM	        EEPROM;
typedef Dummy<0>		        PCI;
typedef ATMega1281_UART		        UART;
typedef ATMega1281_SPI		        SPI;
typedef IF<Traits<ATMega1281_Display>::on_serial,
	   Serial_Display,
	   PC_Display>::Result	        Display;
typedef ATMega1281_NIC		        NIC;
typedef ATMega1281_ADC		        ADC;
typedef ATMega1281_Temperature_Sensor   Temperature_Sensor;
typedef ATMega1281_Photo_Sensor	        Photo_Sensor;
typedef ATMega1281_Accelerometer        Accelerometer;
#define __MACH_H		__HEADER_MACH(machine)
#define __IC_H			__HEADER_MACH(ic)
#define __TIMER_H		__HEADER_MACH(timer)
#define __RTC_H			__HEADER_MACH(rtc)
#define __EEPROM_H		__HEADER_MACH(eeprom)
#define __UART_H		__HEADER_MACH(uart)
#define __SPI_H			__HEADER_MACH(spi)
#define __NIC_H			__HEADER_MACH(nic)
#define __ADC_H			__HEADER_MACH(adc)
#define __SENSOR_H		__HEADER_MACH(sensor)

+ Changes to include/traits.h: the following lines were added

// Mediators - Machine - ATMega1281
#ifdef __atmega1281
class ATMega1281_Common;
template <> struct Traits<ATMega1281_Common>: public Traits<void>
{
};

template <> struct Traits<ATMega1281>: public Traits<ATMega1281_Common>
{
    static const unsigned long long CLOCK     = 8000000;
    static const unsigned int BOOT_IMAGE_ADDR = 0x0000;

    static const unsigned int APPLICATION_STACK_SIZE = 256;
    static const unsigned int APPLICATION_HEAP_SIZE  = 512;

    static const unsigned int SYSTEM_STACK_SIZE = 64;
    static const unsigned int SYSTEM_HEAP_SIZE  = 2300; //8 *  APPLICATION_STACK_SIZE;

};

template <> struct Traits<ATMega1281_Timer>: public Traits<ATMega1281_Common>
{
    // Should be between 30 and 7200 Hz
    static const int FREQUENCY = 720; // Hz
    
};

template <> struct Traits<ATMega1281_RTC>: public Traits<ATMega1281_Common>
{
    static const unsigned int EPOCH_DAY   = 1;
    static const unsigned int EPOCH_MONTH = 1;
    static const unsigned int EPOCH_YEAR  = 1970;
    static const unsigned int EPOCH_DAYS  = 719499;
};

template <> struct Traits<ATMega1281_EEPROM>: public Traits<ATMega1281_Common>
{
    static const unsigned int SIZE = 4096; //8192; // bytes
};

template <> struct Traits<ATMega1281_UART>: public Traits<void>
{
    enum {
        FULL    = 0,//Tx AND Rx enabled
	LIGHT   = 1,//Only Tx enabled
	STANDBY = 2,//Only Rx enabled
	OFF     = 3 //Tx AND Rx disabled
    };
    static const char Power_Management = FULL;
};

template <> struct Traits<ATMega1281_ADC>: public Traits<void>
{
};

template <> struct Traits<ATMega1281_SPI>: public Traits<ATMega1281_Common>
{
};

template <> struct Traits<ATMega1281_Display>: public Traits<ATMega1281_Common>
{
    static const bool on_serial = true;
};

template <> struct Traits<ATMega1281_NIC>: public Traits<void>
{
    typedef LIST<CMAC> NICS;

    static const unsigned int RADIO_UNITS = NICS::Count<Radio>::Result;
};

template <> struct Traits<CMAC>: public Traits<void>
{
    static const unsigned int FREQUENCY = 0;
    static const unsigned int POWER     = 5;
};

template <> struct Traits<ATMega1281_Temperature_Sensor>: public Traits<void>
{
    typedef LIST<MTS300_Temperature> SENSORS;
};

template <> struct Traits<ATMega1281_Photo_Sensor>: public Traits<void>
{
    typedef LIST<MTS300_Photo> SENSORS;
};

template <> struct Traits<ATMega1281_Accelerometer>: public Traits<void>
{
    typedef LIST<ADXL202> SENSORS;
};
#endif

+ Changes to include/arch/avr8/cpu.h: the following lines were added, or modified

#elif defined (__atmega1281)
        SMCR  = 0x33, 
	SM2   = 0x08,
	SM1   = 0x04,
	SM0   = 0x02,
	SE    = 0x01,

        switch(ps) {
	case IDLE:
            #if defined (__atmega1281)
	    out8(SMCR,in8(SMCR) & ~((SM0 | SM1 | SM2)));
            #else
	    out8(MCUCR,in8(MCUCR) & ~((SM0 | SM1 | SM2)));
            #endif
	    ASMV("sleep");
	    break;
	case ADC_NOISE_REDUCTION:	
            #if defined (__atmega1281)
	    out8(SMCR,in8(SMCR) & ~((SM1 | SM2)));
	    out8(SMCR,in8(SMCR) | SM0);
            #else
	    out8(MCUCR,in8(MCUCR) & ~((SM1 | SM2)));
	    out8(MCUCR,in8(MCUCR) | SM0);
            #endif
	    ASMV("sleep");
	    break;
	case POWER_DOWN:	
            #if defined (__atmega1281)
	    out8(SMCR,in8(SMCR) & ~((SM0 | SM2)));
	    out8(SMCR,in8(SMCR) | SM1);
            #else
	    out8(MCUCR,in8(MCUCR) & ~((SM0 | SM2)));
	    out8(MCUCR,in8(MCUCR) | SM1);
            #endif
	    ASMV("sleep");
	    break;
	case POWER_SAVE:	
            #if defined (__atmega1281)
	    out8(SMCR,in8(SMCR) & ~(SM2));
	    out8(SMCR,in8(SMCR) | (SM0 | SM1));
            #else
	    out8(MCUCR,in8(MCUCR) & ~(SM2));
	    out8(MCUCR,in8(MCUCR) | (SM0 | SM1));
            #endif
	    ASMV("sleep");
	    break;
	case NATIVE_STANDBY:	
            #if defined (__atmega1281)
	    out8(SMCR,in8(SMCR) & ~(SM0));
	    out8(SMCR,in8(SMCR) | (SM1 | SM2));
            #else
	    out8(MCUCR,in8(MCUCR) & ~(SM0));
	    out8(MCUCR,in8(MCUCR) | (SM1 | SM2));
            #endif
	    ASMV("sleep");
	    break;
	case EXTENDED_STANDBY:	
            #if defined (__atmega1281)
	    out8(SMCR,in8(SMCR) | (SM0 | SM1 | SM2));
            #else
	    out8(MCUCR,in8(MCUCR) | (SM0 | SM1 | SM2));
            #endif
	    ASMV("sleep");
	    break;
        default:
            break;
	}

+ Changes to include/arch/avr8/tsc.h: as follow

#if defined (__atmega1281)
	TCNT1L	= 0x84,
	TCNT1H	= 0x85,
	TCCR1B	= 0x81,
	TCCR1A	= 0x80,
	TIMSK1	= 0x6F
#else 
	TCNT1L	= 0x2C,
	TCNT1H	= 0x2D,
	TCCR1B	= 0x2E,
	TCCR1A	= 0x2F,
	TIMSK	= 0x37,
#endif

#if defined (__atmega1281)
	// TIMSK1
	TOIE1  = 0x01
#else
	// TIMSK
	TOIE1  = 0x04
#endif

#if defined (__atmega1281)
    static void enable() { timsk1(timsk1() | TOIE1); }
    static void disable() { timsk1(timsk1() & ~TOIE1); }
    static Reg8 timsk1() { return AVR8::in8(IO::TIMSK1); }
    static void timsk1(Reg8 value) { AVR8::out8(IO::TIMSK1,value); }
#else
    static void enable() { timsk(timsk() | TOIE1); }
    static void disable() { timsk(timsk() & ~TOIE1); }
    static Reg8 timsk() { return AVR8::in8(IO::TIMSK); }
    static void timsk(Reg8 value) { AVR8::out8(IO::TIMSK,value); }
#endif
    static Reg8 tccr1a() { return CPU::in8(TCCR1A); }
    static void tccr1a(Reg8 value) { CPU::out8(TCCR1A, value); }    
    static Reg8 tccr1b() { return CPU::in8(TCCR1B); }
    static void tccr1b(Reg8 value) { CPU::out8(TCCR1B, value); }       
    static Reg16 tcnt1hl() { return CPU::in16(TCNT1L); }
    static void tcnt1hl(Reg16 value) { return CPU::out16(TCNT1L, value); }

+ Changes to src/arch/avr8/avr8/mcu: two files were added, copied from /usr/local/avr/gcc/avr/include/avr

iom1281.h
iomxx0_1.h

+ Changes to src/arch/avr8/avr8/io.h: the following lines were added

#elif defined (__AVR_ATmega1281__)
#  include "mcu/iom1281.h"

+ Changes to include/mach/atmega1281/memory_map.h: as follow

{
    enum {
	PINA	= 0x00,
	DDRA	= 0x01,
	PORTA	= 0x02,
	PINB	= 0x03,
	DDRB	= 0x04,
	PORTB	= 0x05,
	PINC	= 0x06,
	DDRC	= 0x07,
	PORTC	= 0x08,   
	PIND	= 0x09,
	DDRD	= 0x0A,
	PORTD	= 0x0B,
	PINE	= 0x0C,
	DDRE	= 0x0D,
	PORTE	= 0x0E,
	PINF	= 0x0F,
	DDRF	= 0x10,
	PORTF	= 0x11,
	PING	= 0x12,
	DDRG	= 0x13,
	PORTG	= 0x14,
	TIFR0	= 0x15,
	TIFR1	= 0x16,
	TIFR2	= 0x17,
	TIFR3	= 0x18,
	TIFR4	= 0x19, 
	TIFR5	= 0x1A,
	PCIFR	= 0x1B, 
	EIFR	= 0x1C, 
	EIMSK	= 0x1D,
	GPIOR0	= 0x1E,
	EECR	= 0x1F,
	EEDR	= 0x20,
	EEAR	= 0x21,
	EEARL	= 0x21,
	EEARH	= 0x22,
	GTCCR	= 0x23,
	TCCR0A	= 0x24,
	TCCR0B	= 0x25,
	TCNT0	= 0x26,
	OCR0A	= 0x27,
	OCR0B	= 0x28,
        /* Reserved [0x29] */
	GPIOR1	= 0x2A,
	GPIOR2	= 0x2B,
	SPCR	= 0x2C,
	SPSR	= 0x2D,
	SPDR	= 0x2E,
        /* Reserved [0x2F] */
	ACSR    = 0x30,
	MONDR   = 0x31,
        OCDR    = 0x31,
        /* Reserved [0x32] */
	SMCR	= 0x33,
	MCUSR	= 0x34,
	MCUCR	= 0x35,
        /* Reserved [0x36] */
	SPMCSR	= 0x37,
        /* Reserved [0x38..0x3A] */
	RAMPZ	= 0x3B,
	EIND	= 0x3C, 
        SPL     = 0x3D,
        SPH     = 0x3E,
        SREG    = 0x3F,
	WDTCSR  = 0x60,
	CLKPR   = 0x61,
        /* Reserved [0x62..0x63] */
	PRR0    = 0x64,
	PRR1    = 0x65,
	OSCCAL  = 0x66,
        /* Reserved [0x67] */
	PCICR   = 0x68,
	EICRA   = 0x69,
	EICRB   = 0x6A,
	PCMSK0  = 0x6B,
	PCMSK1  = 0x6C,
	PCMSK2  = 0x6D,
	TIMSK0  = 0x6E,
	TIMSK1  = 0x6F,
	TIMSK2  = 0x70,
	TIMSK3  = 0x71,
	TIMSK4  = 0x72,
	TIMSK5  = 0x73,
	XMCRA   = 0x74,
        XMCRB   = 0x75,
        /* Reserved [0x76..0x77] */
        ADC     = 0x78,
        ADCW    = 0x78,
        ADCL    = 0x78, 
        ADCH    = 0x79,
        ADCSRA  = 0x7A,
        ADCSRB  = 0x7B,
        ADMUX   = 0x7C,
        DIDR2   = 0x7D,
        DIDR0   = 0x7E,
        DIDR1   = 0x7F,
        TCCR1A  = 0x80,
        TCCR1B  = 0x81,
        TCCR1C  = 0x82,
        /* Reserved [0x83] */
        TCNT1   = 0x84,
        TCNT1L  = 0x84,
        TCNT1H  = 0x85,
        ICR1    = 0x86,
        ICR1L   = 0x86,
        ICR1H   = 0x87,
        OCR1A   = 0x88,
        OCR1AL  = 0x88,
        OCR1AH  = 0x89,
        OCR1B   = 0x8A,
        OCR1BL  = 0x8A,
        OCR1BH  = 0x8B,
        OCR1C   = 0x8C,
        OCR1CL  = 0x8C,
        OCR1CH  = 0x8D,
        /* Reserved [0x8E..0x8F] */
        TCCR3A  = 0x90,
        TCCR3B  = 0x91,
        TCCR3C  = 0x92,
        /* Reserved [0x93] */
        TCNT3   = 0x94,
        TCNT3L  = 0x94,
        TCNT3H  = 0x95,
        ICR3    = 0x96,
        ICR3L   = 0x96,
        ICR3H   = 0x97,
        OCR3A   = 0x98,
        OCR3AL  = 0x98,
        OCR3AH  = 0x99,
        OCR3B   = 0x9A,
        OCR3BL  = 0x9A,
        OCR3BH  = 0x9B,
        OCR3C   = 0x9C,
        OCR3CL  = 0x9C,
        OCR3CH  = 0x9D,
        /* Reserved [0x9E..0x9F] */
        TCCR4A  = 0xA0,
        TCCR4B  = 0xA1,
        TCCR4C  = 0xA2,
        /* Reserved [0xA3] */
        TCNT4   = 0xA4,
        TCNT4L  = 0xA4,
        TCNT4H  = 0xA5,
        ICR4    = 0xA6,
        ICR4L   = 0xA6,
        ICR4H   = 0xA7,
        OCR4A   = 0xA8,
        OCR4AL  = 0xA8,
        OCR4AH  = 0xA9,
        OCR4B   = 0xAA,
        OCR4BL  = 0xAA,
        OCR4BH  = 0xAB,
        OCR4C   = 0xAC,
        OCR4CL  = 0xAC,
        OCR4CH  = 0xAD,
        /* Reserved [0xAE..0xAF] */
        TCCR2A  = 0xB0,
        TCCR2B  = 0xB1,
        TCNT2   = 0xB2,
        OCR2A   = 0xB3,
        OCR2B   = 0xB4,
        /* Reserved [0xB5] */
        ASSR    = 0xB6,
        /* Reserved [0xB7] */
        TWBR    = 0xB8,
        TWSR    = 0xB9,
        TWAR    = 0xBA,
        TWDR    = 0xBB,
        TWCR    = 0xBC,
        TWAMR   = 0xBD,
        /* Reserved [0xBE..0xBF] */
        UCSR0A  = 0xC0,
        UCSR0B  = 0xC1,
        UCSR0C  = 0xC2,
        /* Reserved [0xC3] */
        UBRR0   = 0xC4,
        UBRR0L  = 0xC4,
        UBRR0H  = 0xC5,
        UDR0    = 0xC6,
        /* Reserved [0xC7] */
        UCSR1A  = 0xC8,
        UCSR1B  = 0xC9,
        UCSR1C  = 0xCA,
        /* Reserved [0xCB] */
        UBRR1   = 0xCC,
        UBRR1L  = 0xCC,
        UBRR1H  = 0xCD,
        UDR1    = 0xCE,
        /* Reserved [0xCF] */
        TCCR5A  = 0x120,
        TCCR5B  = 0x121,
        TCCR5C  = 0x122,
        /* Reserved [0x123] */
        TCNT5   = 0x124,
        TCNT5L  = 0x124,
        TCNT5H  = 0x125,
        ICR5    = 0x126,
        ICR5L   = 0x126,
        ICR5H   = 0x127,
        OCR5A   = 0x128,
        OCR5AL  = 0x128,
        OCR5AH  = 0x129,
        OCR5B   = 0x12A,
        OCR5BL  = 0x12A,
        OCR5BH  = 0x12B,
        OCR5C   = 0x12C,
        OCR5CL  = 0x12C,
        OCR5CH  = 0x12D
    };
    
    typedef volatile unsigned char IO_Port;  
    struct IO_Ports {
	IO_Port pina;		// [0x20]
	IO_Port ddra;		// [0x21]
	IO_Port porta;		// [0x22]
	IO_Port pinb;		// [0x23]
	IO_Port ddrb;		// [0x24]
	IO_Port portb;		// [0x25]
	IO_Port pinc;	 	// [0x26]
	IO_Port ddrc;		// [0x27]
	IO_Port portc;		// [0x28]   
	IO_Port pind;		// [0x29]
	IO_Port ddrd;		// [0x2A]
	IO_Port portd;		// [0x2B]
	IO_Port pine;		// [0x2C]
	IO_Port ddre;		// [0x2D]
	IO_Port porte;		// [0x2E]
	IO_Port pinf;		// [0x2F]
	IO_Port ddrf;		// [0x30]
	IO_Port portf;		// [0x31]
	IO_Port ping;		// [0x32]
	IO_Port ddrg;		// [0x33]
	IO_Port portg;		// [0x34]
	IO_Port tifr0;		// [0x35]
	IO_Port tifr1;		// [0x36]
	IO_Port tifr2;		// [0x37]
	IO_Port tifr3;		// [0x38]
	IO_Port tifr4;		// [0x39] 
	IO_Port tifr5;		// [0x3A]
	IO_Port pcifr;		// [0x3B] 
	IO_Port eifr;		// [0x3C] 
	IO_Port eimsk;		// [0x3D]
	IO_Port gpior0;		// [0x3E]
	IO_Port eecr;		// [0x3F]
	IO_Port eedr;		// [0x40]
	IO_Port eearl;		// [0x41]
	IO_Port eearh;		// [0x42]
	IO_Port gtccr;		// [0x43]
	IO_Port tccr0a;		// [0x44]
	IO_Port tccr0b;		// [0x45]
	IO_Port tcnt0;		// [0x46]
	IO_Port ocr0a;		// [0x47]
	IO_Port ocr0b;	 	// [0x48]
	IO_Port reserved0; 	// [0x49]
	IO_Port gpior1;	 	// [0x4A]
	IO_Port gpior2;	 	// [0x4B]
	IO_Port spcr;	 	// [0x4C]
	IO_Port spsr;	 	// [0x4D]
	IO_Port spdr;	 	// [0x4E]
	IO_Port reserved1; 	// [0x4F]
	IO_Port acsr;		// [0x50]
	IO_Port ocdr;		// [0x51]
	IO_Port reserved2;	// [0x52]
	IO_Port smcr;		// [0x53]
	IO_Port mcusr;	 	// [0x54]
	IO_Port mcucr;		// [0x55]
	IO_Port reserved3;	// [0x56]
	IO_Port spmcsr;		// [0x57]
	IO_Port reserved4;	// [0x58]
	IO_Port rampz;		// [0x59]
	IO_Port eind;		// [0x5A]
	IO_Port spl;	 	// [0x5B]
	IO_Port sph;		// [0x5C] 
	IO_Port sreg;		// [0x5D]
	IO_Port wdtcsr;		// [0x5E]
	IO_Port clkpr;		// [0x5F]
	IO_Port reserved5;	// [0x60]
	IO_Port reserved6;	// [0x61]
	IO_Port prr0;	       	// [0x62]
	IO_Port prr1;	    	// [0x63]
	IO_Port osccal;       	// [0x64]
	IO_Port reserved7;     	// [0x65]
	IO_Port pcicr;  	// [0x66]
	IO_Port eicra;  	// [0x67]
	IO_Port eicrb;     	// [0x68]
	IO_Port pcmsk0;  	// [0x69]
	IO_Port pcmsk1;      	// [0x6A]
	IO_Port pcmsk2;  	// [0x6B]
	IO_Port timsk0;      	// [0x6C]
	IO_Port timsk1;      	// [0x6D]
	IO_Port timsk2;  	// [0x6E]
	IO_Port timsk3;     	// [0x6F]
	IO_Port timsk4;       	// [0x70]
	IO_Port timsk5;       	// [0x71]
	IO_Port xmcra;       	// [0x72]
	IO_Port xmcrb;       	// [0x73]
	IO_Port reserved8;     	// [0x74]
	IO_Port reserved9;  	// [0x77]
	IO_Port adcl;     	// [0x78]
	IO_Port adch;     	// [0x79]
	IO_Port adcsra;     	// [0x7A]
	IO_Port adcsrb;  	// [0x7B]
	IO_Port admux;      	// [0x7C]
	IO_Port didr2;     	// [0x7D]
	IO_Port didr0;  	// [0x7E]
	IO_Port didr1;  	// [0x7F]
	IO_Port tccr1a;      	// [0x80]
	IO_Port tccr1b;      	// [0x81]
	IO_Port tccr1c;     	// [0x82]
	IO_Port reserved10;    	// [0x83]
	IO_Port tcnt1l;     	// [0x84]
	IO_Port tcnt1h;     	// [0x85]
	IO_Port icr1l;     	// [0x86]
	IO_Port icr1h;     	// [0x87]
	IO_Port ocr1al;     	// [0x88]
	IO_Port ocr1ah;     	// [0x89]
	IO_Port ocr1bl;     	// [0x8A]
	IO_Port ocr1bh; 	// [0x8B]
        IO_Port ocr1cl;         // [0x8C]
        IO_Port ocr1ch;         // [0x8D]
	IO_Port reserved11; 	// [0x8E]
	IO_Port reserved12; 	// [0x8F]
	IO_Port tccr3a;     	// [0x90]
	IO_Port tccr3b; 	// [0x91]
	IO_Port tccr3c; 	// [0x92]
	IO_Port reserved13; 	// [0x93]
	IO_Port tcnt3l; 	// [0x94]
	IO_Port tcnt3h;     	// [0x95]
	IO_Port icr3l;  	// [0x96]
	IO_Port icr3h;   	// [0x97]
	IO_Port ocr3al;     	// [0x98]
	IO_Port ocr3ah;     	// [0x99]
	IO_Port ocr3bl;     	// [0x9A]
	IO_Port ocr3bh;     	// [0x9B]
	IO_Port ocr3cl;       	// [0x9C]
	IO_Port ocr3ch;     	// [0x9D]
	IO_Port reserved14; 	// [0x9E]
	IO_Port reserved15; 	// [0x9F]
        IO_Port tccr4a;         // [0xA0]
        IO_Port tccr4b;         // [0xA1]
        IO_Port tccr4c;         // [0xA2]
        IO_Port reserved16;     // [0xA3]
        IO_Port tcnt4l;         // [0xA4]
        IO_Port tcnt4h;         // [0xA5]
        IO_Port icr4l;          // [0xA6]
        IO_Port icr4h;          // [0xA7]
        IO_Port ocr4al;         // [0xA8]
        IO_Port ocr4ah;         // [0xA9]
        IO_Port ocr4bl;         // [0xAA]
        IO_Port ocr4bh;         // [0xAB]
        IO_Port ocr4cl;         // [0xAC]
        IO_Port ocr4ch;         // [0xAD]
        IO_Port reserved17;     // [0xAE]
        IO_Port reserved18;     // [0xAF]
        IO_Port tccr2a;         // [0xB0]
        IO_Port tccr2b;         // [0xB1]
        IO_Port tcnt2;          // [0xB2]
        IO_Port ocr2a;          // [0xB3]
        IO_Port ocr2b;          // [0xB4]
        IO_Port reserved19;     // [0xB5]
        IO_Port assr;           // [0xB6]
        IO_Port reserved20;     // [0xB7]
        IO_Port twbr;           // [0xB8]
        IO_Port twsr;           // [0xB9]
        IO_Port twar;           // [0xBA]
        IO_Port twdr;           // [0xBB]
        IO_Port twcr;           // [0xBC]
        IO_Port twamr;          // [0xBD]
        IO_Port reserved21;     // [0xBE]
        IO_Port reserved22;     // [0xBF]
        IO_Port ucsr0a;         // [0xC0]
        IO_Port ucsr0b;         // [0xC1]
        IO_Port ucsr0c;         // [0xC2]
        IO_Port reserved23;     // [0xC3]
        IO_Port ubbr0l;         // [0xC4]
        IO_Port ubbr0h;         // [0xC5]
        IO_Port udr0;           // [0xC6]
        IO_Port reserved24;     // [0xC7]
        IO_Port ucsr1a;         // [0xC8]
        IO_Port ucsr1b;         // [0xC9]
        IO_Port ucsr1c;         // [0xCA]
        IO_Port reserved25;     // [0xCB]
        IO_Port ubrr1l;         // [0xCC]
        IO_Port ubrr1h;         // [0xCD]
        IO_Port udr1;           // [0xCE]
        IO_Port reserved26;     // [0xCF]
        IO_Port tccr5a;         // [0x120]
        IO_Port tccr5b;         // [0x121]
        IO_Port tccr5c;         // [0x122]
        IO_Port reserved27;     // [0x123]
        IO_Port tcnt5l;         // [0x124]
        IO_Port tcnt5h;         // [0x125]
        IO_Port icr5l;          // [0x126]
        IO_Port icr5h;          // [0x127]
        IO_Port ocr5al;         // [0x128]
        IO_Port ocr5ah;         // [0x129]
        IO_Port ocr5bl;         // [0x12A]
        IO_Port ocr5bh;         // [0x12B]
        IO_Port ocr5cl;         // [0x12C]
        IO_Port ocr5ch;         // [0x12D]
    };
};

+ Changes to to /include/mach/atmega1281/timer.h: as follow

    void frequency(const Hertz & f) {
	ocr0a(freq2count(f));
	tccr0a(WGM01 | TIMER_PRESCALE_1024);
    };

    void enable(){ timsk0(timsk0() | OCIE0A); }
    void disable(){ timsk0(timsk0() & ~OCIE0A); }

    void frequency(const Hertz & f) {
	ocr2a(freq2count(f));
	tccr2a(WGM21 | TIMER_PRESCALE_1024);
    };

    void enable(){ timsk2(timsk2() | OCIE2A); }
    void disable(){ timsk2(timsk2() & ~OCIE2A); }

    void enable(){ timsk3(timsk3() | OCIE3A); }
    void disable(){timsk3(timsk3() & ~OCIE3A);}

    void frequency(const Hertz & f) {
	ocr3a(freq2count(f));
	tccr3b(TIMER_PRESCALE_1024|WGMn2);
    };

+ Changes to /include/mach/atmega1281/ic.h: the following lines were added, modified

    // Interrupt IO Registers
    enum {	
	EIMSK   = IO::EIMSK, 
	EIFR    = IO::EIFR,
	TIMSK0  = IO::TIMSK0,
	TIMSK1  = IO::TIMSK1, 
	TIMSK2  = IO::TIMSK2,  
	TIMSK3  = IO::TIMSK3,
	TIMSK4  = IO::TIMSK4,
	TIMSK5  = IO::TIMSK5, 
	TIFR0   = IO::TIFR0,
	TIFR1   = IO::TIFR1,
	TIFR2   = IO::TIFR2,
	TIFR3   = IO::TIFR3,
	TIFR4   = IO::TIFR4,
	TIFR5   = IO::TIFR5,
	SPCR    = IO::SPCR,  
	SPSR    = IO::SPSR,
	UCSR0A  = IO::UCSR0A, 
	UCSR0B  = IO::UCSR0B,
	UCSR0C  = IO::UCSR0C,
	UCSR1A  = IO::UCSR1A,
	UCSR1B  = IO::UCSR1B,
	UCSR1C  = IO::UCSR1C,
	ADCSRA  = IO::ADCSRA, 
	ADCSRB  = IO::ADCSRB, 
	EECR    = IO::EECR,  
	ACSR    = IO::ACSR  
    };    
    
    // Interrupt Register Flags
    enum {
	// EIMSK
	INT7     = 0x80,
	INT6     = 0x40,
	INT5     = 0x20,
	INT4     = 0x10,
	INT3     = 0x08,
	INT2     = 0x04,
	INT1     = 0x02,
	INT0     = 0x01,
	// EIFR
	INTF7    = 0x80,
	INTF6    = 0x40,
	INTF5    = 0x20,
	INTF4    = 0x10,
	INTF3    = 0x08,
	INTF2    = 0x04,
	INTF1    = 0x02,
	INTF0    = 0x01,
        // TIMSK0
        OCIE0B   = 0x04,
        OCIE0A   = 0x02,
        TOIE0    = 0x01,
        // TIMSK1
        ICIE1    = 0x20,
        OCIE1C   = 0x08,
        OCIE1B   = 0x04,
        OCIE1A   = 0x02,
        TOIE1    = 0x01,
	// TIMSK2
        OCIE2B   = 0x04,
        OCIE2A   = 0x02,
	TOIE2	 = 0x01,
        // TIMSK3
        ICIE3    = 0x20,
        OCIE3C   = 0x08,
        OCIE3B   = 0x04,
        OCIE3A   = 0x02,
        TOIE3    = 0x01,
        // TIMSK4
        ICIE4    = 0x20,
        OCIE4C   = 0x08,
        OCIE4B   = 0x04,
        OCIE4A   = 0x02,
        TOIE4    = 0x01,
        // TIMSK5
        ICIE5    = 0x20,
        OCIE5C   = 0x08,
        OCIE5B   = 0x04,
        OCIE5A   = 0x02,
        TOIE5    = 0x01,
        // TIFR0
        OCF0B    = 0x04,
        OCF0A    = 0x02,
        TOV0     = 0x01,
        // TIFR1
        ICF1     = 0x20,
        OCF1C    = 0x08,
        OCF1B    = 0x04,
        OCF1A    = 0x02,
        TOV1     = 0x01,
        // TIFR2
        OCF2B    = 0x04,
        OCF2A    = 0x02,
        TOV2     = 0x01,
        // TIFR3
        ICF3     = 0x20,
        OCF3C    = 0x08,
        OCF3B    = 0x04,
        OCF3A    = 0x02,
        TOV3     = 0x01,
        // TIFR4
        ICF4     = 0x20,
        OCF4C    = 0x08,
        OCF4B    = 0x04,
        OCF4A    = 0x02,
        TOV4     = 0x01,
        // TIFR5
        ICF5     = 0x20,
        OCF5C    = 0x08,
        OCF5B    = 0x04,
        OCF5A    = 0x02,
        TOV5     = 0x01,
	// TWCR
	TWINT	 = 0x80,
	TWIE	 = 0x01,
	// SPCR
	SPIE	 = 0x80,
	// SPSR
	SPIF	 = 0x80,
	// UCSRnA
	RXCn	 = 0x80,
	TXCn	 = 0x40,
	UDREn	 = 0x20,
	// UCSRnB
	RXCIEn	 = 0x80,
	TXCIEn	 = 0x40,
	UDRIEn	 = 0x20,
	//ADCSRA
	ADIF	 = 0x10,
	ADIE	 = 0x08,
	// EECR
	EERIE	 = 0x08,
	// ACSR
	ACI	 = 0x10,
	ACIE	 = 0x08
    };

    enum {
	IRQ_RESET        = 0,
	IRQ_IRQ0         = 1,
	IRQ_IRQ1         = 2,
	IRQ_IRQ2         = 3,
	IRQ_IRQ3         = 4,
	IRQ_IRQ4         = 5,
	IRQ_IRQ5         = 6,
	IRQ_IRQ6         = 7,
	IRQ_IRQ7         = 8,
        IRQ_PCINT0       = 9,
        IRQ_PCINT1       = 10,
        IRQ_PCINT2       = 11,
        IRQ_WDT          = 12,
        IRQ_TIMER2_COMPA = 13,
        IRQ_TIMER2_COMPB = 14,
	IRQ_TIMER2_OVF   = 15,
	IRQ_TIMER1_CAPT  = 16,
	IRQ_TIMER1_COMPA = 17,
	IRQ_TIMER1_COMPB = 18,
	IRQ_TIMER1_COMPC = 19,
	IRQ_TIMER1_OVF   = 20,
        IRQ_TIMER0_COMPA = 21,
        IRQ_TIMER0_COMPB = 22,
	IRQ_TIMER0_OVF   = 23,
	IRQ_SPI_STC      = 24,
	IRQ_USART0_RXC   = 25,
	IRQ_USART0_UDRE  = 26,
	IRQ_USART0_TXC   = 27,
	IRQ_ANA_COMP     = 28,
	IRQ_ADC          = 29,
	IRQ_EE_RDY       = 30,
	IRQ_TIMER3_CAPT  = 31,
	IRQ_TIMER3_COMPA = 32,
	IRQ_TIMER3_COMPB = 33,
	IRQ_TIMER3_COMPC = 34,
	IRQ_TIMER3_OVF   = 35,
	IRQ_USART1_RXC   = 36,
	IRQ_USART1_UDRE  = 37,
	IRQ_USART1_TXC   = 38,
	IRQ_TWI          = 39,
	IRQ_SPM_RDY      = 40,
	IRQ_TIMER4_CAPT  = 41,
	IRQ_TIMER4_COMPA = 42,
	IRQ_TIMER4_COMPB = 43,
	IRQ_TIMER4_COMPC = 44,
	IRQ_TIMER4_OVF   = 45,
	IRQ_TIMER5_CAPT  = 46,
	IRQ_TIMER5_COMPA = 47,
	IRQ_TIMER5_COMPB = 48,
	IRQ_TIMER5_COMPC = 49,
	IRQ_TIMER5_OVF   = 50,
	IRQ_USART2_RXC   = 51,
	IRQ_USART2_UDRE  = 52,
	IRQ_USART2_TXC   = 53,
	IRQ_USART3_RXC   = 54,
	IRQ_USART3_UDRE  = 55,
	IRQ_USART3_TXC   = 56,
    	IRQ_TSC 	 = IRQ_TIMER1_OVF,	
	IRQ_TIMER 	 = IRQ_TIMER0_COMPA
    };

    static void enable(IRQ irq) {

	if (irq <= IRQ_IRQ7) {
	    eimsk(eimsk() | 1 << (irq - 1));
	    return;
	}

	if (irq <= IRQ_TIMER0_OVF) {
	    timsk0(timsk0() | 1 << -(irq - 23)); 
	    return;
	}

	/* There is no linear relation between UART0, UART1 and Timer3
	   Interrupts and their respective register bits :-( */
	
	switch (irq) {
	    case IRQ_SPI_STC:         spcr(spcr()     | SPIE)  ; break;
	    case IRQ_USART0_RXC:      ucsr0b(ucsr0b() | RXCIEn); break;
	    case IRQ_USART0_UDRE:     ucsr0b(ucsr0b() | UDRIEn); break;
	    case IRQ_USART0_TXC:      ucsr0b(ucsr0b() | TXCIEn); break;
	    case IRQ_ADC:             adcsra(adcsra() | ADIE)  ; break;
	    case IRQ_EE_RDY:          eecr(eecr()     | EERIE) ; break;
	    case IRQ_ANA_COMP:        acsr(acsr()     | ACIE)  ; break;
	    case IRQ_TIMER1_COMPC:    timsk1(timsk1() | OCIE1C); break;
	    case IRQ_TIMER3_CAPT:     timsk3(timsk3() | ICIE3) ; break;
	    case IRQ_TIMER3_COMPA:    timsk3(timsk3() | OCIE3A); break;
	    case IRQ_TIMER3_COMPB:    timsk3(timsk3() | OCIE3B); break;
	    case IRQ_TIMER3_COMPC:    timsk3(timsk3() | OCIE3C); break;
	    case IRQ_TIMER3_OVF:      timsk3(timsk3() | TOIE3) ; break;
	    case IRQ_USART1_RXC:      ucsr1b(ucsr1b() | RXCIEn); break;
	    case IRQ_USART1_UDRE:     ucsr1b(ucsr1b() | UDRIEn); break;
	    case IRQ_USART1_TXC:      ucsr1b(ucsr1b() | TXCIEn); break;
	}

    }
    
    static void disable() {
        eimsk(0);
	timsk0(0); 
	timsk1(0); 
	timsk2(0); 
	timsk3(0); 
	timsk4(0); 
	timsk5(0); 
        spcr(spcr() & ~SPIE);
        ucsr0b(ucsr0b() & ~(RXCIEn | UDRIEn | TXCIEn)); 
        ucsr1b(ucsr1b() & ~(RXCIEn | UDRIEn | TXCIEn));
        adcsra(adcsra() & ~ADIE);
        acsr(acsr() & ~ACIE);
        eecr(eecr() & ~EERIE);
    }

    static void disable(IRQ irq) {

	if (irq <= IRQ_IRQ7) {
	    eimsk(eimsk() & ~(1 << (irq - 1)));
	    return;
	}

	if (irq <= IRQ_TIMER0_OVF) {
	    timsk0(timsk0() & ~( 1 << -(irq - 23))); 
	    return;
	}

	/* There is no linear relation between UART0, UART1 and Timer3
	   Interrupts and their respective register bits :-( */
	
	switch (irq) {
	    case IRQ_SPI_STC:         spcr(spcr()     & ~SPIE)  ; break;
	    case IRQ_USART0_RXC:      ucsr0b(ucsr0b() & ~RXCIEn); break;
	    case IRQ_USART0_UDRE:     ucsr0b(ucsr0b() & ~UDRIEn); break;
	    case IRQ_USART0_TXC:      ucsr0b(ucsr0b() & ~TXCIEn); break;
	    case IRQ_ADC:             adcsra(adcsra() & ~ADIE)  ; break;
	    case IRQ_EE_RDY:          eecr(eecr()     & ~EERIE) ; break;
	    case IRQ_ANA_COMP:        acsr(acsr()     & ~ACIE)  ; break;
	    case IRQ_TIMER1_COMPC:    timsk1(timsk1() & ~OCIE1C); break;
	    case IRQ_TIMER3_CAPT:     timsk3(timsk3() & ~ICIE3) ; break;
	    case IRQ_TIMER3_COMPA:    timsk3(timsk3() & ~OCIE3A); break;
	    case IRQ_TIMER3_COMPB:    timsk3(timsk3() & ~OCIE3B); break;
	    case IRQ_TIMER3_COMPC:    timsk3(timsk3() & ~OCIE3C); break;
	    case IRQ_TIMER3_OVF:      timsk3(timsk3() & ~TOIE3) ; break;
	    case IRQ_USART1_RXC:      ucsr1b(ucsr1b() & ~RXCIEn); break;
	    case IRQ_USART1_UDRE:     ucsr1b(ucsr1b() & ~UDRIEn); break;
	    case IRQ_USART1_TXC:      ucsr1b(ucsr1b() & ~TXCIEn); break; 
	}

    }
    
private:

    typedef AVR8::Reg8 Reg8;

    static Reg8 eimsk() { return AVR8::in8(EIMSK); }
    static void eimsk(Reg8 value) { AVR8::out8(EIMSK,value); } 
    static Reg8 eifr() { return AVR8::in8(EIFR); }
    static void eifr(Reg8 value) { AVR8::out8(EIFR,value); } 
    static Reg8 timsk0() { return AVR8::in8(TIMSK0); }
    static void timsk0(Reg8 value) { AVR8::out8(TIMSK0,value); } 
    static Reg8 timsk1() { return AVR8::in8(TIMSK1); }
    static void timsk1(Reg8 value) { AVR8::out8(TIMSK1,value); } 
    static Reg8 timsk2() { return AVR8::in8(TIMSK2); }
    static void timsk2(Reg8 value) { AVR8::out8(TIMSK2,value); } 
    static Reg8 timsk3() { return AVR8::in8(TIMSK3); }
    static void timsk3(Reg8 value) { AVR8::out8(TIMSK3,value); } 
    static Reg8 timsk4() { return AVR8::in8(TIMSK4); }
    static void timsk4(Reg8 value) { AVR8::out8(TIMSK4,value); } 
    static Reg8 timsk5() { return AVR8::in8(TIMSK5); }
    static void timsk5(Reg8 value) { AVR8::out8(TIMSK5,value); } 
    static Reg8 tifr0() { return AVR8::in8(TIFR0); }
    static void tifr0(Reg8 value) { AVR8::out8(TIFR0,value); } 
    static Reg8 tifr1() { return AVR8::in8(TIFR1); }
    static void tifr1(Reg8 value) { AVR8::out8(TIFR1,value); } 
    static Reg8 tifr2() { return AVR8::in8(TIFR2); }
    static void tifr2(Reg8 value) { AVR8::out8(TIFR2,value); } 
    static Reg8 tifr3() { return AVR8::in8(TIFR3); }
    static void tifr3(Reg8 value) { AVR8::out8(TIFR3,value); } 
    static Reg8 tifr4() { return AVR8::in8(TIFR4); }
    static void tifr4(Reg8 value) { AVR8::out8(TIFR4,value); } 
    static Reg8 tifr5() { return AVR8::in8(TIFR5); }
    static void tifr5(Reg8 value) { AVR8::out8(TIFR5,value); } 
    static Reg8 spcr() { return AVR8::in8(SPCR); }
    static void spcr(Reg8 value) { AVR8::out8(SPCR,value); } 
    static Reg8 spsr() { return AVR8::in8(SPSR); }
    static void spsr(Reg8 value) { AVR8::out8(SPSR,value); } 
    static Reg8 ucsr0a() { return AVR8::in8(UCSR0A); }
    static void ucsr0a(Reg8 value) { AVR8::out8(UCSR0A,value); } 
    static Reg8 ucsr0b() { return AVR8::in8(UCSR0B); }
    static void ucsr0b(Reg8 value) { AVR8::out8(UCSR0B,value); } 
    static Reg8 ucsr0c() { return AVR8::in8(UCSR0C); }
    static void ucsr0c(Reg8 value) { AVR8::out8(UCSR0C,value); } 
    static Reg8 ucsr1a() { return AVR8::in8(UCSR1A); }
    static void ucsr1a(Reg8 value) { AVR8::out8(UCSR1A,value); } 
    static Reg8 ucsr1b() { return AVR8::in8(UCSR1B); }
    static void ucsr1b(Reg8 value) { AVR8::out8(UCSR1B,value); } 
    static Reg8 ucsr1c() { return AVR8::in8(UCSR1C); }
    static void ucsr1c(Reg8 value) { AVR8::out8(UCSR1C,value); } 
    static Reg8 adcsra() { return AVR8::in8(ADCSRA); }
    static void adcsra(Reg8 value) { AVR8::out8(ADCSRA,value); } 
    static Reg8 adcsrb() { return AVR8::in8(ADCSRB); }
    static void adcsrb(Reg8 value) { AVR8::out8(ADCSRB,value); } 
    static Reg8 eecr() { return AVR8::in8(EECR); }
    static void eecr(Reg8 value) { AVR8::out8(EECR,value); } 
    static Reg8 acsr() { return AVR8::in8(ACSR); }
    static void acsr(Reg8 value) { AVR8::out8(ACSR,value); } 
        
};

+ Changes to /include/mach/atmega1281/machine.h: the following lines were modified

    static const unsigned int INT_VECTOR_SIZE = 57;

+ Changes to to /include/mach/avr_common/timer.h

#if defined (__atmega1281)
        // TIMSK0
        OCIE0B   = 0x04,
        OCIE0A   = 0x02,
        TOIE0    = 0x01,
        // TIMSK1
        ICIE1    = 0x20,
        OCIE1C   = 0x08,
        OCIE1B   = 0x04,
        OCIE1A   = 0x02,
        TOIE1    = 0x01,
	// TIMSK2
        OCIE2B   = 0x04,
        OCIE2A   = 0x02,
	TOIE2	 = 0x01,
        // TIMSK3
        ICIE3    = 0x20,
        OCIE3C   = 0x08,
        OCIE3B   = 0x04,
        OCIE3A   = 0x02,
        TOIE3    = 0x01,
        // TIMSK4
        ICIE4    = 0x20,
        OCIE4C   = 0x08,
        OCIE4B   = 0x04,
        OCIE4A   = 0x02,
        TOIE4    = 0x01,
        // TIMSK5
        ICIE5    = 0x20,
        OCIE5C   = 0x08,
        OCIE5B   = 0x04,
        OCIE5A   = 0x02,
        TOIE5    = 0x01,
        // TIFR0
        OCF0B    = 0x04,
        OCF0A    = 0x02,
        TOV0     = 0x01,
        // TIFR1
        ICF1     = 0x20,
        OCF1C    = 0x08,
        OCF1B    = 0x04,
        OCF1A    = 0x02,
        TOV1     = 0x01,
        // TIFR2
        OCF2B    = 0x04,
        OCF2A    = 0x02,
        TOV2     = 0x01,
        // TIFR3
        ICF3     = 0x20,
        OCF3C    = 0x08,
        OCF3B    = 0x04,
        OCF3A    = 0x02,
        TOV3     = 0x01,
        // TIFR4
        ICF4     = 0x20,
        OCF4C    = 0x08,
        OCF4B    = 0x04,
        OCF4A    = 0x02,
        TOV4     = 0x01,
        // TIFR5
        ICF5     = 0x20,
        OCF5C    = 0x08,
        OCF5B    = 0x04,
        OCF5A    = 0x02,
        TOV5     = 0x01,
        // GTCCR
	TSM     = 0x80,
	PSRASY  = 0x02,
	PSRSYNC = 0x01,
        // ADCSRB
	ACME   = 0x40,
        // MCUCR
	PUD    = 0x10,
	// TCCR0B 
	FOC0A  = 0x80,
	FOC0B  = 0x40,
	WGM02  = 0x08,
	CS02   = 0x04,
	CS01   = 0x02,
	CS00   = 0x01,
        // TCCR0A
	COM0A1 = 0x80,
	COM0A0 = 0x40,
	COM0B1 = 0x20,
	COM0B0 = 0x10,
	WGM01  = 0x02,
	WGM00  = 0x01,
	// ASSR
	AS2     = 0x20,
	TCN2UB  = 0x10,
	OCR2AUB = 0x08,
	OCR2BUB = 0x04,
	TCR2AUB = 0x02,
	TCR2BUB = 0x01,
	// TCCR1A, TCCR3A
	COMnA1 = 0x80,
	COMnA0 = 0x40,
	COMnB1 = 0x20,
	COMnB0 = 0x10,
	COMnC1 = 0x08,
	COMnC0 = 0x04,
	WGMn1  = 0x02,
	WGMn0  = 0x01,
	// TCCR1B, TCCR3B
	ICNCn  = 0x80,
	ICESn  = 0x40,
	WGMn3  = 0x10,
	WGMn2  = 0x08,
	CSn2   = 0x04,
	CSn1   = 0x02,
	CSn0   = 0x01,
	// TCCR1C, TCCR3C
	FOCnA  = 0x80,
	FOCnB  = 0x40,
	FOCnC  = 0x20,
	// TCCR2B
	FOC2A  = 0x80,
	FOC2B  = 0x40,
	WGM22  = 0x08,
	CS22   = 0x04,
	CS21   = 0x02,
	CS20   = 0x01,
	// TCCR2A
        COM2A1 = 0x80,
        COM2A0 = 0x40,
        COM2B1 = 0x20,
        COM2B0 = 0x10,
        WGM21  = 0x02,
        WGM20  = 0x01
#else
	// TIMSK
	OCIE2  = 0x80,
	TOIE2  = 0x40,
	TICIE1 = 0x20,
	OCIE1A = 0x10,
	OCIE1B = 0x08,
	TOIE1  = 0x04,
	OCIE0  = 0x02,
	TOIE0  = 0x01,
	// ETIMSK
	TICIE3 = 0x20,
	OCIE3A = 0x10,
	OCIE3B = 0x08,
	TOIE3  = 0x04,
	OCIE3C = 0x02,
	OCIE1C = 0x01,
	// TIFR
	OCF2   = 0x80,
	TOV2   = 0x40,
	ICF1   = 0x20,
	OCF1A  = 0x10,
	OCF1B  = 0x08,
	TOV1   = 0x04,
	OCF0   = 0x02,
	TOV0   = 0x01,
	// ETIFR
	ICF3   = 0x20,
	OCF3A  = 0x10,
	OCF3B  = 0x08,
	TOV3   = 0x04,
	OCF3C  = 0x02,
	OCF1C  = 0x01,
	// SFIOR
	TSM    = 0x80,
	ACME   = 0x08,
	PUD    = 0x04,
	PSR0   = 0x02,
	PSR321 = 0x01,
	// TCCR0 
	FOC0   = 0x80,
	WGM00  = 0x40,
	COM01  = 0x20,
	COM00  = 0x10,
	WGM01  = 0x08,
	CS02   = 0x04,
	CS01   = 0x02,
	CS00   = 0x01,
	// ASSR
	AS0    = 0x08,
	TCN0UB = 0x04,
	OCR0UB = 0x02,
	TCR0UB = 0x01,
	// TCCR1A, TCCR3A
	COMnA1 = 0x80,
	COMnA0 = 0x40,
	COMnB1 = 0x20,
	COMnB0 = 0x10,
	COMnC1 = 0x08,
	COMnC0 = 0x04,
	WGMn1  = 0x02,
	WGMn0  = 0x01,
	// TCCR1B, TCCR3B
	ICnC1  = 0x80,
	ICESn  = 0x40,
	WGMn3  = 0x10,
	WGMn2  = 0x08,
	CSn2   = 0x04,
	CSn1   = 0x02,
	CSn0   = 0x01,
	// TCCR1C, TCCR3C
	FOCnA  = 0x80,
	FOCnB  = 0x40,
	FOCnC  = 0x10,
	// TCCR2
	FOC2   = 0x80,
	WGM20  = 0x40,
	COM21  = 0x20,
	COM20  = 0x10,
	WGM21  = 0x08,
	CS22   = 0x04,
	CS21   = 0x02,
	CS20   = 0x01,
#endif

#if defined (__atmega1281)
    static Reg8 timsk0() { return AVR8::in8(IO::TIMSK0); }
    static void timsk0(Reg8 value) { AVR8::out8(IO::TIMSK0,value); } 
    static Reg8 timsk1() { return AVR8::in8(IO::TIMSK1); }
    static void timsk1(Reg8 value) { AVR8::out8(IO::TIMSK1,value); } 
    static Reg8 timsk2() { return AVR8::in8(IO::TIMSK2); }
    static void timsk2(Reg8 value) { AVR8::out8(IO::TIMSK2,value); } 
    static Reg8 timsk3() { return AVR8::in8(IO::TIMSK3); }
    static void timsk3(Reg8 value) { AVR8::out8(IO::TIMSK3,value); } 
    static Reg8 timsk4() { return AVR8::in8(IO::TIMSK4); }
    static void timsk4(Reg8 value) { AVR8::out8(IO::TIMSK4,value); } 
    static Reg8 timsk5() { return AVR8::in8(IO::TIMSK5); }
    static void timsk5(Reg8 value) { AVR8::out8(IO::TIMSK5,value); } 
    static Reg8 tifr0() { return AVR8::in8(IO::TIFR0); }
    static void tifr0(Reg8 value) { AVR8::out8(IO::TIFR0,value); } 
    static Reg8 tifr1() { return AVR8::in8(IO::TIFR1); }
    static void tifr1(Reg8 value) { AVR8::out8(IO::TIFR1,value); } 
    static Reg8 tifr2() { return AVR8::in8(IO::TIFR2); }
    static void tifr2(Reg8 value) { AVR8::out8(IO::TIFR2,value); } 
    static Reg8 tifr3() { return AVR8::in8(IO::TIFR3); }
    static void tifr3(Reg8 value) { AVR8::out8(IO::TIFR3,value); } 
    static Reg8 tifr4() { return AVR8::in8(IO::TIFR4); }
    static void tifr4(Reg8 value) { AVR8::out8(IO::TIFR4,value); } 
    static Reg8 tifr5() { return AVR8::in8(IO::TIFR5); }
    static void tifr5(Reg8 value) { AVR8::out8(IO::TIFR5,value); } 
    static Reg8 gtccr() { return AVR8::in8(IO::GTCCR); }
    static void gtccr(Reg8 value) { AVR8::out8(IO::GTCCR,value); }
    static Reg8 adcsrb() { return AVR8::in8(IO::ADCSRB); }
    static void adcsrb(Reg8 value) { AVR8::out8(IO::ADCSRB,value); }
    static Reg8 mcucr() { return AVR8::in8(IO::MCUCR); }
    static void mcucr(Reg8 value) { AVR8::out8(IO::MCUCR,value); }
    static Reg8 tccr0b() { return AVR8::in8(IO::TCCR0B); }
    static void tccr0b(Reg8 value) { AVR8::out8(IO::TCCR0B,value); }
    static Reg8 tccr0a() { return AVR8::in8(IO::TCCR0A); }
    static void tccr0a(Reg8 value) { AVR8::out8(IO::TCCR0A,value); }
    static Reg8 ocr0b() { return AVR8::in8(IO::OCR0B); }
    static void ocr0b(Reg8 value) { AVR8::out8(IO::OCR0B,value); }
    static Reg8 ocr0a() { return AVR8::in8(IO::OCR0A); }
    static void ocr0a(Reg8 value) { AVR8::out8(IO::OCR0A,value); }
    static Reg8 tccr2b() { return AVR8::in8(IO::TCCR2B); }
    static void tccr2b(Reg8 value) { AVR8::out8(IO::TCCR2B,value); }
    static Reg8 tccr2a() { return AVR8::in8(IO::TCCR2A); }
    static void tccr2a(Reg8 value) { AVR8::out8(IO::TCCR2A,value); }
    static Reg8 ocr2b() { return AVR8::in8(IO::OCR2B); }
    static void ocr2b(Reg8 value) { AVR8::out8(IO::OCR2B,value); }
    static Reg8 ocr2a() { return AVR8::in8(IO::OCR2A); }
    static void ocr2a(Reg8 value) { AVR8::out8(IO::OCR2A,value); }
#else
    static Reg8 timsk() { return AVR8::in8(IO::TIMSK); }
    static void timsk(Reg8 value) { AVR8::out8(IO::TIMSK,value); }
    static Reg8 etimsk() { return AVR8::in8(IO::ETIMSK); }
    static void etimsk(Reg8 value) { AVR8::out8(IO::ETIMSK,value); }
    static Reg8 tifr() { return AVR8::in8(IO::TIFR); }
    static void tifr(Reg8 value) { AVR8::out8(IO::TIFR,value); }
    static Reg8 etifr() { return AVR8::in8(IO::ETIFR); }
    static void etifr(Reg8 value) { AVR8::out8(IO::ETIFR,value); }
    static Reg8 sfior() { return AVR8::in8(IO::SFIOR); }
    static void sfior(Reg8 value) { AVR8::out8(IO::SFIOR,value); }
    static Reg8 tccr0() { return AVR8::in8(IO::TCCR0); }
    static void tccr0(Reg8 value) { AVR8::out8(IO::TCCR0,value); }
    static Reg8 ocr0() { return AVR8::in8(IO::OCR0); }
    static void ocr0(Reg8 value) { AVR8::out8(IO::OCR0,value); }
    static Reg8 tccr2() { return AVR8::in8(IO::TCCR2); }
    static void tccr2(Reg8 value) { AVR8::out8(IO::TCCR2,value); }
    static Reg8 ocr2() { return AVR8::in8(IO::OCR2); }
    static void ocr2(Reg8 value) { AVR8::out8(IO::OCR2,value); }
#endif

+ Changes to /include/mach/avr_common/cmac.h

#if defined (__atmega1281)
    static ATMega1281_Timer_2       _timer;
#else
    static ATMega128_Timer_2        _timer;
#endif
#if defined (__atmega1281)
#include <mach/atmega1281/timer.h>
#else 
#include <mach/atmega128/timer.h>
#endif
