%\documentstyle[times,art10,twocolumn,latex8]{article}
\documentclass[times,10pt,twocolumn]{article} 
\usepackage{latex8}
\usepackage{times}
\usepackage{graphicx}

\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinelanguage{XML} {
  keywords={xml,version,DOCTYPE,SYSTEM,EPOSConfig,family,member,name,type,
  default,pos,pre}}
\lstdefinestyle{prg} {basicstyle=\small\sffamily, lineskip=-0.2ex}
\lstdefinestyle{prgbox} {basicstyle=\small\sffamily lineskip=-0.2ex}
\lstdefinestyle{inlineprg} {basicstyle=\small\sffamily}

%-------------------------------------------------------------------------

\newcommand{\fig}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

\newcommand{\prg}[4][ht]{
  \begin{figure}[#1]
    \vspace{\parskip}
     \lstinputlisting[language=#2,style=prg,
                       basicstyle=\fontfamily{pcr}\fontseries{m}\selectfont\footnotesize
                      ]{prg/#3.prg}
    \vspace{0.5\parskip}
    \caption{#4\label{prg:#3}}
  \end{figure}
}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
%\pagestyle{empty}
%------------------------------------------------------------------------- 

\begin{document}

\title{On the Automatic Generation of SoC-based Embedded Systems}

\author{Fauze Val\'erio Polpeta and Ant\^onio Augusto Fr\"ohlich\\
Federal University of Santa Catarina\\
UFSC/CTC/LISHA - PO Box 476\\
88049-900 Florianópolis - SC, Brazil\\ 
\{fauze,guto\}@lisha.ufsc.br\\
}

%------------------------------------------------------------------------- 

\maketitle
\thispagestyle{empty}

\begin{abstract}

 The increasing complexity of embedded applications has motivated
 system designers to search for methods and tools that enable the
 automatic generation of embedded systems. This paper outlines a
 strategy for generating customized run-time support systems and
 specific hardware platforms for dedicated applications. Relying on
 the \emph{Application-Oriented System Design} methodology, the
 approached strategy proposes the use of \emph{Hardware
 Mediators}---an original portability artifact---as the basis for
 creating IP-based SoCs that match, in association with a run-time
 support system, the requirements of dedicated applications. The
 several steps involved in this process are presented in a detailed
 case study using an experimental application-oriented operating
 system.

\end{abstract}

%------------------------------------------------------------------------- 

\Section{Introduction}

 Embedded systems are becoming more and more complex, yet, there is no
 room for development strategies that incur in extended time-to-market
 in this extremely competitive sector. In this context, the
 \emph{System-on-a-Chip}~(SoC) define a compromise between system
 complexity and development costs. Furthermore, the advances in
 programmable logic devices~(\textsc{PLD}) are enabling developers to
 instantiate and to evaluate complex \textsc{SoC} designs in a short
 period of time. This can drastically decreases the time-to-market and
 turns \textsc{PLD}s an important technologic alternative in the
 development of embedded systems.

 However, getting a \textsc{SoC} out off a \emph{Field-Programmable
 Gate Array}~(FPGA) is not a trivial task and requires an intricate
 engineering process. Much effort has been payed to supporting tools
 that assist designers in selecting and configuring \textsc{IP}s and
 also in generating the necessary glue logic. These tools usually
 presuppose an standardized interconnect, such as Wishbone, Amba or
 Coreconnect~\cite{Pelgrims:cpu:2003}, and thus can be very
 effective. For instance, the \textsc{Coral}~\cite{Bergamaschi:2001}
 project from IBM uses the concept of \emph{Virtual Design} to provide
 the designer with simplified \textsc{IP} descriptions that hide many
 implementation details.

 Indeed, some \emph{embedded systems} can be completely implemented in
 hardware using this approach, but the more complex the application,
 the greater is the probability it will need some kind of
 \emph{run-time support system} and an \emph{application
 program}. This is, after all, the reason why so many groups are
 concentrating efforts to develop processor soft cores such as Leon2
 and OpenRisc~\cite{Mattsson:2004}. Nevertheless, run-time support
 systems are often neglected by currently available \textsc{SoC}
 development methodologies and tools, being mostly restricted to
 simple processor scheduling routines and the definition of a hardware
 abstraction layer. The gap between software and hardware gets even
 bigger when we recall that one of the primary goals of an operating
 system is to grant the portability of applications, since ordinary
 operating systems cannot go with the dynamism of \textsc{SoC}s.

 In this paper we discuss the use of \emph{Hardware
 Mediators}~\cite{Polpeta:euc:2004} to enable the automatic generation
 of SoC-based embedded systems. The deployment of
 \emph{Application-Oriented System
 Design}~(AOSD)~\cite{Froehlich:2001} on the context where hardware
 mediators were originally proposed---\emph{software-hardware
 interfacing}---fosters this portability artifact to a new perspective
 on the design of embedded systems. Mediators are figured as pointers
 for generating a ``machine description'' that matches, in association
 with a run-time support system, the requirements of dedicated
 applications. The following sections describe the basics of the AOSD
 method, the concepts of hardware mediators and how these mediators
 can be deployed on the generation of SoC-based embedded
 systems. Subsequently, in a experimental case study, we consider the
 \textsc{Epos}~system~\cite{Froehlich:sbac:1999}, an
 application-oriented operating system that relies on hardware
 mediators to foster portability and also to enable automatic hardware
 generation. The paper is closed with a discussion of related works
 and the author's perspectives. 

%------------------------------------------------------------------------- 

\Section{Application-Oriented System Design\label{aosd}}

 \emph{Application-Oriented System
 Design}~(AOSD)~\cite{Froehlich:2001} proposes some alternatives to
 proceed the engineering of a domain towards software components. In
 principle, an application-oriented decomposition of the problem
 domain can be obtained following the guidelines of
 \emph{Object-Oriented Decomposition}~\cite{Booch:1994}. However, some
 subtle yet important differences must be considered. First,
 object-oriented decomposition gathers objects with similar behavior
 in class hierarchies by applying variability analysis to identify how
 one entity specializes the other.  Besides leading to the famous
 ``fragile base class'' problem~\cite{Mikhajlov:1998}, this policy
 assumes that specializations of an abstraction
 (i.e. \emph{subclasses}) are only deployed in presence of their more
 generic versions (i.e. \emph{superclasses}).

 Applying variability analysis in the sense of \emph{Family-Based
 Design}~\cite{Parnas:1976} to produce independently deployable
 abstractions, modeled as members of a family, can avoid this
 restriction and improve on application-orientation.  Certainly, some
 family members will still be modeled as specializations of others, as
 in \emph{Incremental System Design}~\cite{Habermann:1976}, but this
 is no longer an imperative rule. For example, instead of modeling
 connection-oriented as a specialization of connectionless
 communication (or vice-versa), what would misuse a network that
 natively operates in the opposite mode, one could model both as
 autonomous members of a family.

 A second important difference between application-oriented and
 object-oriented decomposition concerns environmental dependencies.
 Variability analysis, as carried out in object-oriented
 decomposition, does not emphasizes the differentiation of variations
 that belong to the essence of an abstraction from those that emanate
 from the execution scenarios being considered for it. Abstractions
 that incorporate environmental dependencies have a smaller chance of
 being reused in new scenarios, and, given that an
 application-oriented operating system will be confronted with a new
 scenario virtually every time a new application is defined, allowing
 such dependencies could severely hamper the system.

 Nevertheless, one can reduce such dependencies by applying the key
 concept of \emph{Aspect-Oriented Programming}~\cite{Kiczales:1997},
 i.e.  aspect separation, to the decomposition process.  By doing so,
 one can tell variations that will shape new family members from those
 that will yield scenario aspects. For example, instead of modeling a
 new member for a family of communication mechanisms that is able to
 operate in the presence of multiple threads, one could model
 multithreading as a scenario aspect that, when activated, would lock
 the communication mechanism (or some of its operations) in a critical
 section.

 Based on these premises, Application-Oriented Systems Design guides a
 domain engineering procedure (see Figure~\ref{fig:aosd}) that models
 software components with the aid of three major constructs: families
 of scenario-independent abstractions, scenario adapters and inflated
 interfaces.

\fig{0.65}{aosd}{Overview of application-oriented domain decomposition.}

\subsection*{Families of scenario independent abstractions}

 During domain decomposition, abstractions are identified from domain
 entities and grouped in families according to their
 commonalities. Yet during this phase, aspect separation is used to
 shape scenario-independent abstractions, thus enabling them to be
 reused in a variety of scenarios.  These abstractions are
 subsequently implemented to give rise to the actual software
 components.

 The implementation of the members of a family of abstractions is not
 restricted to the use of specialization as we would do in
 object-orientation, although it can occur, when convenient. For
 example, members could be implemented as classes conjointly
 distributed as a package through aggregation or
 composition. Afterward, some families may contain mutually exclusive
 members, that is, only one of the members can be present in the
 system configuration at a time.

\subsection*{Scenario adapters}

 As explained earlier, AOSD dictates that scenario dependencies must
 be factored out as \emph{aspects}, thus keeping abstractions
 scenario-independent. However, for this strategy to work, means must
 be provided to apply factored aspects to abstractions in a
 transparent way.  The traditional approach to do this would be
 deploying an \emph{aspect weaver}, though the \emph{scenario adapter}
 construct~\cite{Froehlich:sci:2000} has the same potentialities
 without requiring an external tool.  A scenario adapter wraps an
 abstraction, intermediating its communication with scenario-dependent
 clients to perform the necessary scenario adaptations.

\subsection*{Inflated interfaces}

 Inflated interfaces summarize the features of all members of a
 family, creating a unique view of the family as a ``super
 component''. It allows application programmers to write their
 applications based on well-know, comprehensive interfaces, postponing
 the decision about which member of the family shall be used until
 enough configuration knowledge is acquired. The binding of an
 inflated interface to one of the members of a family can thus be made
 by automatic configuration tools that identify which features of the
 family were used in order to choose the simplest realization that
 implements the requested interface subset at compile-time.

%------------------------------------------------------------------------- 
 
 \fig{0.75}{family}{A family of hardware mediators for Network
 Interface Cards.}

\Section{Hardware Mediators}\label{mediators}

 An operating system designed according to the premises of
 Application-Oriented System Design can be summarily viewed as sets of
 software components that can be configured, adapted and integrated in
 order to give rise to highly customized and scenario-specific
 instances of run-time support systems. However, besides all the
 benefits claimed by software component engineering, such a class of
 run-time support systems is prone to the same need for portability as
 their more conventional relatives.

 Traditional portability strategies, mainly focused in hardware
 abstraction layers~(HAL) and virtual machines~(VM), are not concerned
 with the AOSD's purposes. Being a product of a system engineering
 process (instead of a domain engineering process), these strategies
 usually build a monolithic abstraction layer that encapsulates all
 the resources available in the hardware platform without properly
 regarding the application needs. Such modeling may be a problem when
 the platforms to be interfaced are based on \textsc{SoC}s. The
 diversity of architectures and devices in these platforms lead us to
 diagnose that the traditional specification techniques for sw-hw
 interfacing are still far from the ideal
 ``plug-and-play''~\cite{Neville:2003}. In addition, whenever
 \textsc{SoC}s are built on \emph{Programmable Logic Devices} such as
 FPGAs, the hardware specifications can be modified in a short period
 of time~\cite{Rutenbar:2001}, and thus compromising much more the
 portability of the system.

 In order to deal with this dynamism and to foster the portability of
 system abstractions to virtually any architecture, a system designed
 according to the concepts of AOSD relies on the hardware mediator
 construct~\cite{Froehlich:2001}. As discussed in \emph{Hardware
 Mediators: a Portability Artifact for Component-Based
 Systems}~\cite{Polpeta:euc:2004}, the main idea behind this
 portability artifact is not to build an universal hardware
 abstraction layer or virtual machine, but sustaining an
 \emph{interface contract} between the operating system and the
 hardware. Each hardware component is mediated via its own mediator,
 thus granting the portability of abstractions that use it without
 creating unnecessary dependencies. Indeed, hardware mediators are
 intended to be mostly static-metaprograms and thus ``dissolve''
 themselves in the system abstractions as soon as the interface
 contract is met. In other words, a hardware mediator delivers the
 functionality of the corresponding hardware component through a
 system-oriented interface.

 An important element of hardware mediators are \emph{configurable
 features}, which designate features of mediators that can be switched
 on and off according to the requirements dictated by abstractions. A
 configurable feature is not restricted to a flag indicating whether a
 preexisting hardware feature must be activated or not. Usually, it
 also incorporates a \emph{Generic Programmed}~\cite{Musser:1989}
 implementation of the algorithms and data structures that are
 necessary to implement that feature when the hardware itself does not
 provide it. An example of configurable feature is the generation of
 CRC codes in mediators that abstract communication devices.

 Likewise abstractions in AOSD, hardware mediators are organized in
 families whose members represent significant entities in the hardware
 domain. For instance, a family of \texttt{NIC} mediators would
 feature members such as \texttt{91C911}, \texttt{MPC8XX}, and
 \texttt{RT8139} (see Figure~\ref{fig:family}). Such modeling enables
 the generation of object-code only for those mediators that are
 necessary to support the application. Non-functional aspects and
 cross-cutting properties are factored out as \emph{scenario aspects}
 that can be applied to family members as required. For instance,
 families like \texttt{UART} and \texttt{NIC} must often operate in
 exclusive-access mode. This could be achieved by applying a
 share-control aspect to the families.

%------------------------------------------------------------------------- 

\Section{Generating SoCs Using HW Mediators\label{codesign}}

 Although originally devised to give rise to highly adaptable
 system-hardware interface, hardware mediators can be also used for
 generating application-oriented hardware instances. More
 specifically, in the context of programmable logic, where hardware
 components, namely soft-IPs, are described using hardware description
 languages (e.g. VHDL, VERILOG) in order to implement the elements of
 the underlying hardware technology. Hence, by associating hardware
 mediators with those descriptions one can infer which hardware
 components are necessary to support the application.

 \fig{0.58}{idea}{The use of hardware mediators to infer the IPs that
 will be synthesized.}

 A component-based system can thus rely on hardware mediators not only
 to interface its system abstractions to the hardware, but also to
 dictate which components will build-up the target hardware. As soon
 as a hardware mediator is selected to interface a hardware component,
 the associated \textsc{IP} is selected from a repository in order to
 integrate a hardware description that will be synthesized in a
 \textsc{PLD}. Such a description in the form of a \textsc{SoC} would
 embed only the hardware components necessary to support the run-time
 system and, in turn, the application.

 The Figure~\ref{fig:idea} illustrates the idea of using hardware
 mediators to infer hardware components. The \textsc{SoC} generation
 process consists of selecting the \textsc{IPs} that are associated
 with the mediators that have been instantiated to support a given
 application. Such \textsc{IPs} represent significant entities from
 the hardware domain that are grouped in a repository as families of
 hardware components. These families, as well as their members, are
 therefore associated with families of hardware mediators whose
 members are responsible for mediating the respective hardware
 components with which they are associated. The information related to
 this association is held by the \emph{Info} database, which, in turn,
 also provides the information necessary to configure the \textsc{IP}s
 according to the application's requirements and for the synthesis
 process. 

 For instance, reconsider the Figure~\ref{fig:family} presented in 
 Section~\ref{mediators}. As explained earlier, this figure depicts a
 family of \texttt{NIC} hardware mediators. Consider now that it also
 represents a family of \texttt{NIC} hardware components whose members
 are associated to the members of the respective mediator's
 family. From a given application that uses a system abstraction to
 implement an Ethernet network one can infer that a member of the
 family \texttt{NIC} will be instantiated. However, the decision of
 which specific member will be instantiated, since all members are
 functionally equivalent, is up to the application's programmer. This
 situation characterizes what we named a \emph{combined
 IP-selection}. The hardware devices are inferred considering an
 application requirement and a specific decision of the application's
 programmer.

 \fig{0.50}{ip_selection}{The inferring process of system components.}

 Another scenario, named \emph{discreet IP-selection}, is related to
 the selection of hardware components considering only the
 application's requirements --- no explicit programmer decision must
 be taken. A good example for this scenario is related to the memory
 management scheme that will be implemented by the run-time support
 system. Since the application programmer uses system abstractions that
 implement a \emph{paging} scheme, the \texttt{MMU} mediator is
 automatically inferred and, consequently, a memory management unit
 will be selected for synthesis. Conversely, when a \emph{flat} memory
 scheme is adopted no memory management unit is synthesized.

 A third scenario, named \emph{explicit IP-selection}, represents the
 chance of the programmer to choose the hardware components that will
 be instantiated in the system. Even if the respective mediators are
 ``hidden'' by system abstractions, the programmer explicitly selects
 the hardware components that he is intending to embed in the
 \textsc{SoC}. Indeed, this selection strategy is always taken when
 the programmer initially specifies which architecture model
 (e.g. \texttt{SPARCV8}, \texttt{OR32}) the system will follow.

 Furthermore, the approach is not restricted to the specification of
 which \textsc{IP}s will be instantiated in a \textsc{PLD}. The
 element \emph{configurable feature} explained earlier can be also
 deployed on hardware components. They can be used to configure
 \textsc{IP}s in order to properly support the application and also to
 switch on and off some functionalities that can be implemented in
 hardware or in software~\cite{Grunewald:2003}. As exemplified earlier
 with CRC codes, a configurable feature can be used to enable the
 generation of these codes in an \texttt{UART} mediator for data
 transmitted over a serial communication line. Such codes, otherwise,
 could be generated by the hardware itself instead of the software. In
 this case, since the \textsc{IP} that implements the \texttt{UART}
 device supports generation of CRC codes, a hardware configurable
 feature would be activated in order to enable the synthesis of these
 functionalities in the \textsc{SoC}.

 \fig{0.55}{epos_overview}{An overview of the tools involved in the
 automatic generation of run-time support and hardware instances.}

 Two other interesting examples about the deployment of configurable
 features on hardware components are the dimensioning of the
 \texttt{CPU} cache sizes in order to minimize the time taken to
 access data in memory~\cite{Viana:2003} and also the customization of
 \textsc{CPU} register banks. For instance, the \emph{Leon2
 processor}~\cite{LEON2:2004}, which implements a \textsc{SoC} based
 on the \texttt{SPARCV8}~\cite{SPARCV8} architecture, permit us to
 specify the number of register windows that will be synthesized into
 the \texttt{CPU} core. Through a configurable feature, one could set
 up the optimum number of register windows for a given application
 scenario. In other words, this configurable feature represents a
 possibility to explore the scalability of the \texttt{SPARCV8}
 architecture as regards the application's needs. 

 However, it is important to remember that the role played by
 configurable features is not only the configuration of system
 components. Considering that a configurable feature is set in order
 to fulfill a specific application requirement, only those components
 that implement such a feature can be selected to fulfill this
 specific requirement. Consequently, configurable features are also
 deployed in the component selection process, since they guide the
 identification of which members of a family are able to support the
 application. For instance, a \emph{Serial\_Communicator} system
 abstraction could implement a \emph{data\_integrity} configurable
 feature that, when activated, would enable the deployment of a data
 integrity algorithm on transmissions over a serial link. The main
 requisite of this feature, in turn, would be an \emph{UART} mediator
 or an \emph{UART} IP that features a data integrity mechanism such as
 \textsc{HASH} functions and CRC codes.

 The Figure~\ref{fig:ip_selection} presents a diagram of the system's
 component inferring process. The vertical lines represent the
 different entity domains of the system. The rows show the three
 scenarios for \textsc{IP} selection, i.e.~\emph{explicit},
 ~\emph{combined} and \emph{discreet}. As illustrated, the
 configurable features are deployable on operating system
 abstractions, hardware mediators and hardware components. The
 gray area in the figure represents functionalities that for
 one application could be implemented by the hardware mediators and,
 for other, by the hardware itself. 

 \fig{0.55}{leon2}{Block diagram of Leon2.}

%-------------------------------------------------------------------------

\Section{Case Study: SoCs in EPOS\label{epos}}    

 The Embedded Parallel Operating System~(\textsc{Epos}) aims at
 delivering adequate run-time support for dedicated computing
 applications. Relying on the \emph{Application-Oriented System
 Design} method, \textsc{Epos} consists of families of software
 components that can be adapted to fulfill the requirements of
 particular applications. In order to maintain the portability of its
 systems abstractions and to enable the generation of
 application-oriented \textsc{SoC}s, the \textsc{Epos} system relies
 on the hardware mediator construct.

 An application written on \textsc{Epos} can be submitted to a tool
 that scans it searching for references to the inflated interfaces
 (see Section~\ref{aosd}), thus rendering the features of each family
 that are necessary to support the application at run-time. This task
 is accomplished by a tool, the analyzer, that outputs an specification
 of requirements in the form of partial component interface
 declarations, including methods, types and constants that were used
 by the application.

 The primary specification produced by the analyzer is subsequently
 fed into a second tool, the configurator, that consults a build-up
 database to create the description of the system's
 configuration~\cite{Tondello:AICCSA:2005}. This database holds
 information about each component in the repository, as well as
 dependencies and composition rules that are used by the configurator
 to build a dependency tree. The output of the configurator consists
 of a set of keys that define the binding of inflated interfaces to
 abstractions and activate the scenario aspects eventually identified
 as necessary to satisfy the constraints dictated by the target
 application or by the configured execution scenario. On the side of
 the hardware components, the configurator produces a list of
 instantiated mediators and specifies which of these mediators promote
 \textsc{IP} synthesis.

 \prg{C++}{sample_app}{A source code fragment of the experimental
 application.}

 The last step in the generation process is accomplished by the
 generator. This tool translates the keys produced by the configurator
 into parameters for a statically metaprogramed component framework
 and causes the compilation of a tailored operating system
 instance. In addition, whenever a \textsc{SoC} needs to be tailored,
 the \texttt{generator}, based on the \textsc{IP} configurable
 features, produces a synthesis configuration file. Written in a
 hardware description language, this file, as well as the selected
 \textsc{IP}s, are passed to a third-party tool, which in turn
 performs the synthesis of a \textsc{SoC}. An overview of the whole
 procedure is depicted in Figure~\ref{fig:epos_overview}

%-------------------------------------------------------------------------

\SubSection{Sample Instance}

 In order to evaluate our approach for automating the design of
 SoC-based embedded systems we used the \emph{Leon2 Processor}. This
 ``processor'' was created in order to enable the development of
 customized SoCs based on the SPARCV8 CPU core. The ``modular'' design
 of \textsc{Leon2} enable us to specify which of its \textsc{IP}s will
 be synthesized in the \textsc{SoC}. The logic necessary to glue the
 \textsc{IP}s is implicitly defined in the source-code through a set
 of programming asserts, which are, in turn, used to properly
 configure and plug-in the \textsc{IP}s in an \textsc{Amba} bus
 framework~\cite{AMBA}. The Figure~\ref{fig:leon2} shows the block
 diagram of \textsc{Leon2}. Besides the \texttt{CPU} core,
 \textsc{Leon2} includes a set of peripherals that can be plugged in
 as soon as the user selects them.

 \fig{0.60}{leon2_custom}{The block diagram of the SoC generated
 for the experimental application.}

 The experiments were performed on a Virtex2 FPGA development
 kit~\cite{XMB:2002} and consisted of evaluating an application for
 which a run-time support system and a \textsc{SoC} should be
 generated. The application implemented two threads, \emph{Producer}
 and \emph{Consumer}, which were executed in a concurrent environment
 in order to send and receive data stored in a shared \emph{bounded
 buffer} through an \texttt{UART} (see
 Figure~\ref{prg:sample_app}). Aiming at signaling the \emph{Consumer}
 thread to deal with new data in the \textsc{UART} buffer and also for
 thread scheduling, the mechanism of \emph{interrupts} was
 used. Consequently, the mediator and the \textsc{IP} of the Interrupt
 Controller~(\texttt{IC}) were selected to be instantiated. As regards
 the memory management scheme, it was based on a \emph{flat}
 address-space and therefore, no \textsc{MMU} components were
 instantiated in the system. Furthermore, in order to have some
 integrity control on the transmitted data, the configurable feature
 \emph{data\_integrity} was enabled on the \emph{Serial\_Communicator}
 abstraction, which, in turn, provides the programmer with a
 high-level communication system interface.~\footnote{The mutual
 exclusion concerning the Serial\_Communicator is reached through the
 deployment of scenario adapters.} The Figure~\ref{fig:leon2_custom}
 depicts the block diagrams of the \textsc{SoC} that was generated
 after submit the application to the sequence of tools presented in
 Section~\ref{epos}.

 In order to illustrate how the system components were inferred from
 this experimental application the Figure~\ref{fig:ipsel_sample}
 presents the selection decisions that were made by the programmer and
 by the \textsc{Epos} configuration environment in order to identify
 the software and hardware components that better fulfilled the
 application's requirements. The inferring process starts with the
 selection of which architecture model the system will
 follow. Subsequently, based on references to the \emph{inflated
 interfaces}, we infer the operating system abstractions that will
 support the communication system, i.e. the
 \emph{Serial\_Communicator}, \emph{Concurrent\_Thread},
 \emph{Semaphore} and \emph{Flat\_Addr\_Space}. Following, by
 considering which hardware mediators these abstractions rely on, the
 hardware components are also inferred, in this case, the
 \emph{leon2\_uart}, \emph{leon2\_ic} and
 \emph{leon2\_timer}. Additionally, notice that the enabling of the
 configurable feature \emph{data\_integrity} on the
 \emph{Serial\_Communicator} abstraction leads the programmer to
 select only an \texttt{UART} mediator or an \texttt{UART} IP that
 implements some data integrity mechanism. In this experiment, such
 data integrity mechanism was the generation of CRC codes in the
 \emph{leon2\_uart} mediator, since the associated IP does not
 implement such a functionality in hardware.

 \fig{0.51}{ipsel_sample}{The component inferring flow of the
 experimental application.}

 Aiming at clarifying the expressiveness of this sample instance, it
 is important to compare the obtained results to the numbers of
 ordinary operating system that were ported to the \textsc{Leon2}
 platform. Usually these systems are generated to compromise all the
 features that the \textsc{SoC} is able to provide. The absence of a
 component-based engineering and the lack of modern software
 engineering techniques affects not only the size and performance of
 the final system, but also effectively increase NRE costs and
 time-to-market. Table~\ref{tab:sample1} presents the size of the EPOS
 run-time support system that was generated to support this
 experimental application and the sizes of two traditional ports of
 \textsc{uCLinux}~\cite{LeonuClinux:2003} and
 \textsc{eCos}~\cite{Massa:2002}, also customized to support this same
 experimental application on the \textsc{Leon2}
 platform.~\footnote{Since uCLinux and eCos do not implement CRC codes
 in their UART device drivers, the configurable feature
 data\_integrity was disabled in Epos.} Additionally, some statistics
 related to the size of the \textsc{SoC} generated on this sample
 instance and the size of \textsc{Leon2} when it was synthesized with
 all of its implemented devices are showed in
 table~\ref{tab:sample2}.~\footnote{Because of some Leon2's design
 restrictions the co-processor~(CP) and the PCI were not included.}
 
 \begin{table}[ht]
  \begin{center}
    \begin{tabular}{|c|c|c|c|}
      \hline
      \multicolumn{1}{|c|}{\textbf{OS		 }}&
      \multicolumn{1}{|c|}{\textbf{.text (bytes) }}& 	
      \multicolumn{1}{|c|}{\textbf{.data (bytes) }}& 	
      \multicolumn{1}{|c|}{\textbf{.bss  (bytes) }}\\
      \hline
        EPOS & 8,988 & 28 & 8,400 \\
      \hline
 	eCos & 17,152 & 796 & 34,040 \\
      \hline
 	uClinux & 840,712 & 44,700 & 72,649 \\
      \hline   
    \end{tabular}
  \end{center}

  \caption{The code segment sizes of EPOS, uCLinux and eCos system
  images to Leon2.}\label{tab:sample1}

 \end{table} 

 In respect to the \textsc{eCos} system, which is based on a
 component-based approach, it is possible to perform a fine selection
 of the system abstractions that the programmer wants to provides in
 the run-time support system. However eCos does not make use of
 \emph{aspect-oriented programming} and consequently the number of
 system abstractions in \textsc{eCos} may be so large as the number of
 application scenarios that we can in embedded systems. Such modeling
 makes the component selection process difficult, since \textsc{eCos}
 has no automatic component inferring mechanism. In order to minimize
 such a impact, \textsc{eCos} provides libraries of components that
 implement traditional system call interfaces such as
 \textsc{POSIX}~\cite{Jespersen:1995}. Another shortcoming that arises
 is that \textsc{eCos} is based, as \textsc{uClinux}, on a hardware
 abstraction layer portability strategy. Thus, as soon as the
 programmer selects the platform that will support the application,
 the HAL is entirely imputed in the system, improperly increasing the
 size of the run-time support system. For instance, the eCos's HAL for
 the \textsc{Leon2} platform always presupposes an \texttt{UART}
 device.

 \begin{table}[ht]
  \begin{center}
    \begin{tabular}{|c|c|c|}
      \hline
      \multicolumn{1}{|c|}{\textbf{SoC			}}&
      \multicolumn{1}{|c|}{\textbf{Size (LUTs)		}}& 	
      \multicolumn{1}{|c|}{\textbf{Virtex2 FPGA Area	}}\\
      \hline
        Custom & 6,792 & 31,0 \% \\
      \hline
 	Full & 14,582 & 67,0 \%  \\
      \hline	
    \end{tabular}
  \end{center}

  \caption{The sizes of the application-oriented Leon2 instance
  generated in EPOS and the fully synthesized Leon2 SoC.}
  \label{tab:sample2}

 \end{table} 
 
 The presented application was also evaluated in terms of performance
 in \textsc{Epos} and \textsc{eCos}. The choice of \textsc{eCos} was
 made considering the numbers in Table~\ref{tab:sample1} and the fact
 that \textsc{eCos} is tagged as a \emph{configurable} system
 alternative for embedded systems. The system instances were
 experimented under same conditions in a Leon2 SoC running at 54 Mhz
 with a physical loop-back plugged to the serial I/O connector in
 order to use the same port for data relaying. The application
 execution time was measured after 16,000 send-receive operations. The
 obtained results are showed in Table~\ref{tab:sample3}. Notice that
 these numbers do not reflect the transmission times, which represent
 approximately 16 seconds in total when the serial transmission
 baud-rate is limited to 38,400 bps.

 \begin{table}[ht]
  \begin{center}
    \begin{tabular}{|c|c|}
      \hline
      \multicolumn{1}{|c|}{\textbf{Operating System     }} &
      \multicolumn{1}{|c|}{\textbf{Time taken (ms) }}\\
      \hline
        EPOS & 45.42 \\
      \hline
 	eCos & 132.67 \\
      \hline   
    \end{tabular}
  \end{center}

  \caption{The time taken to execute the experimental application in
  EPOS and eCos.}\label{tab:sample3}

 \end{table} 

%-------------------------------------------------------------------------

\Section{Conclusions}

 In this article we conjectured about the automatic generation of
 SoC-based embedded systems. The deployment of \textsc{AOSD} in the
 context where hardware mediators were originally proposed leaded us
 to use this portability artifact to give rise to hardware
 descriptions that match, in association with the run-time support
 system, the requirements of dedicated applications. We claimed that
 to deal with the dynamism of \textsc{SoC}s and \textsc{PLD}s,
 operating systems must rely on refined software-hardware interfaces
 where each hardware component is abstracted by a single abstraction,
 in our case a hardware mediator. Furthermore, we extended to
 soft-cores the premise of only instantiating system abstractions and
 hardware mediators when they are recognized as application's
 needs. In this sense, by associating hardware mediators to the
 Leon2's IPs, we generated in a experimental case study the necessary
 run-time support system and respective system-on-a-chip for a given
 application.

 The approached strategy does not represent a complete solution to
 automate the process of generating SoC-based embedded systems,
 whereas the programmer still takes some decisions. Otherwise we
 believe that it represents an important step in this direction since
 we have promoted the generation of run-time support systems and
 \textsc{SoC} instances in the same generation flow according to a
 well-defined methodology.

\Section{Future Work}

 The presented results are quite simple and they just confirmed the
 viability of automatically generating run-time support systems and
 system-on-chip instances considering application's
 requirements. However, as exemplified in Section~\ref{codesign}, we
 are not only able to identify which devices shall be instantiated in
 a \textsc{SoC} but, in fact, to configure each component of our
 system in order to better fit the application's requirements. In this
 sense a large gamma of new experiments started to be evaluated, such
 as processor scalability, memory hierarchy exploration and power
 management. The results obtained so far are encouraging and we hope
 present them soon.

%-------------------------------------------------------------------------

\bibliographystyle{latex8}
\bibliography{fauze,guto,cods,se,os,arch}

\end{document}
