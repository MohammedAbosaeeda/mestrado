package keso.compiler.backend;

import keso.classfile.*;
import keso.classfile.constantpool.*;
import keso.classfile.datatypes.*;

import keso.compiler.*;
import keso.compiler.config.*;
import keso.compiler.imcode.*;

import keso.util.Debug;
import keso.util.Bitmap;

import java.io.*;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;


public class CoderI386Linux extends Coder {
    
    public CoderI386Linux(BuilderOptions opts, MethodTableFactory table, ClassStore store) throws CompileException {
        rules = new Vector();
        global = new StringBuffer();
        global_header = new StringBuffer();
        global_includes = new Hashtable();
        global_header_includes = new Hashtable();
        mdispatch = table;
        repository = store;
        this.opts=opts;
        ifmatrix = new InterfaceTypeMatrix(opts, this, store);
    }
    
    public void writeMainFile() throws CompileException {
        
        try {
            String mainfile = opts.getOutputPath()+"/keso_main.c";
            PrintStream out = new PrintStream(new FileOutputStream(mainfile));
            Vector tasks = opts.getSysTasks();
            
            out.println("/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */\n");
            
            /* include the headers for each task's class in global.h */
            out.print("#include \"global.h\"\n");
            for(int i=0; i<tasks.size(); i++) {
                TaskDefinition task = (TaskDefinition) tasks.elementAt(i);
                if (task instanceof NativeTask) continue;
                IMClass mainClass = repository.getClass(task.getMainClassName());
                String include = "#include \"" + mainClass.getAlias() + ".h\"\n";
                global_header_add(include);
            }
            Enumeration clinits = class_constructors.elements();
            while (clinits.hasMoreElements()) {
                IMMethod m = (IMMethod)clinits.nextElement();
                IMClass clazz = m.getIMClass();
                out.print("#include \"");
                out.print(m.getIMClass().getAlias());
                out.print(".h\"\n");
            }
            
            // includes for hooks
	    OSDefinition osek = opts.getSysDef().getOSDef();
	    if (osek!=null) {
		    Object[] allHooks = osek.getAllHooks();
		    ComplexBoolAttribute[] hooks = (ComplexBoolAttribute[]) allHooks[0];
		    String[] hookClasses = new String[hooks.length];
		    for(int i=0;i<hooks.length;i++) {
			    if (hooks[i]==null || !hooks[i].setting) continue;
			    String hc = hooks[i].getAttribute("HookClass").valueString();
			    for(int j=0; j<hookClasses.length;j++) {
				    if(hookClasses[j]==null) {
					    // this header must be included
					    hookClasses[j] = hc;
					    out.print("#include \""+
							    repository.getClass(hc).getAlias()+
							    ".h\"\n");
					    break;
				    } else if (hookClasses[j].compareTo(hc)==0) {
					    // this header has already been included
					    break;
				    }
			    }
		    }
		    out.print("\n\n");
		    // Hook routines
		    writeHookRoutines(out, tasks);

		    // ISRs
		    writeISRs(out);

		    // alarm callback functions
		    writeAlarmCallbacks(out, opts.getSysAlarms());
	    }

	    // Runtime information such as Task objects, Resource objects, etc.
	    writeRuntimeData(out, tasks);

            // Main function begin
	    out.println("#include \"domains.h\"\n");

            out.print("int main(int argc, char* argv[]) {\n");
            
	    writeCallClassConstructors(out);

            // emit code for all tasks
	    for(int i=0; i<tasks.size(); i++) {
		    TaskDefinition task = (TaskDefinition) tasks.elementAt(i);
		    if(task instanceof NativeTask) continue;

		    IMClass mainClass = repository.getClass(task.getMainClassName());
		    IMMethod mainMethod = mainClass.getMethod(task.getMainMethodName());

		    String main_obj = task.getIdentifier()+"_obj";

		    // declare extern object in global.h
		    global_header_add("extern ");
		    global_header_add(mainClass.getClassTypeString());
		    global_header_add(" ");
		    global_header_add(main_obj);
		    global_header_add(";\n");
		    // declare and init the object in global.c
		    global_add(mainClass.getClassTypeString());
		    global_add(" ");
		    global_add(main_obj);
		    global_add(" = {\n\t.gcinfo=1, .class_id=");
		    global_add(mainClass.getClassID());

		    global_add(",\n\t._domain_id=");
		    global_add( ((DomainDefinition)task.parent).domainid );
		    global_add(",\n\t._e_domain_id=");
		    global_add( ((DomainDefinition)task.parent).domainid );
		    /*
		       global_add(",\n\t._"+resClass.toLowerCase()+"_id=");
		       global_add(res.getIdentifier());
		       */
		    global_add("\n};\n");

		    out.println("\n\t/* call the main task */");
		    out.print("\t");
		    out.print(mainMethod.getIdentifier());
		    out.print("(");
		    out.print(add_accessStaticObject(mainClass, main_obj));
		    out.print(");\n");
	    }
            
            out.print("\treturn 0;\n");
            out.print("}\n");
            
            add_rule(new MakeRule(opts, "keso_main.o",
                    "keso_main.c", modul.getAlias()+".h"));
            
            out.close();
            
        } catch (IOException ex) {
            throw new CompileException(ex.toString());
        }
        
        writeInfoFile();
    }

    protected void writeRuntimeData(PrintStream out, Vector tasks) throws CompileException {

	    IMClass task_class = repository.getClass("keso/core/Task");

	    global_header_add("#include \"");
	    global_header_add(task_class.getAlias());
	    global_header_add(".h\"\n");

	    global_header_add("#define KESO_TASKCLASSTYPE ");
	    global_header_add(task_class.getClassTypeString());
	    global_header_add("\n");
	    global_header_add("#define KESO_TASKCLASSID ");
	    global_header_add(task_class.getClassID());
	    global_header_add("\n");
	    global_header_add("\n#define KESO_MAX_TASK ");
	    global_header_add(tasks.size());
	    global_header_add("\n");
	    global_header_add("\n");
	    
	    global_header_add("extern ");
	    global_header_add(task_class.getClassTypeString());
	    global_header_add("* keso_task_index[];\n");

	    global_add(task_class.getClassTypeString());
	    global_add("* keso_task_index[KESO_MAX_TASK];\n");
	    global_header_add("extern keso_stack_t* keso_stack_index[];\n");
	    global_add("keso_stack_t* keso_stack_index[KESO_MAX_TASK];\n");

	    /* global task pointer, updated by PreTaskHook */
	    global_header_add("#define KESO_CURRENT_TASK keso_curr_task\n");
	    global_header_add("#define KESO_SET_CURRENT_TASK(_x_) keso_curr_task=(_x_)\n");
	    global_header_add("extern KESO_TASKCLASSTYPE *keso_curr_task;\n");
	    global_add("KESO_TASKCLASSTYPE *keso_curr_task;\n");

	    /* keso_curr_task_fkt() will return a reference to the running
	     * task with the help of OSEK GetTaskID(). It will be used in
	     * the PreTaskHook to update the keso_curr_task variable.
	     */
	    if (!opts.hasOption("no_inline_curr_task_fkt")) {
		    global_header_add("#define keso_curr_task_fkt() (keso_task_index[OSEKOStidact])\n");
	    } else {
		    global_header_add("KESO_TASKCLASSTYPE *keso_curr_task_fkt();\n");

		    global_add("\n\n");
		    global_add("/* Returns a pointer to the currently running Task\n");
		    global_add(" * INVALID_TASK is assumed to be greater by one than\n");
		    global_add(" * the highest TaskID. This is ProOSEK specific and\n");
		    global_add(" * will likely not work on other OSEK implementations.\n");
		    global_add(" * keso_task_index is initialised with NULL, which\n");
		    global_add(" * represents the INVALID_TASK Java-Task object.\n");
		    global_add(" */\n");
		    global_add("KESO_TASKCLASSTYPE *keso_curr_task_fkt() {\n");
		    global_add("\tTaskType taskID;\n");
		    global_add("\tGetTaskID(&taskID);\n");
		    global_add("\treturn keso_task_index[taskID];\n");
		    global_add("}\n\n");
	    }
    }
    
    
    protected void writeGlobalFiles() throws CompileException {
        try {
            
            // Makefile
            String makefile = opts.getOutputPath()+"/Makefile";
            PrintStream out = new PrintStream(new FileOutputStream(makefile));
            
            writeMakefile(rules, out);
            
	    out.println("\nkesoinfo: kesoinfo.c");
	    out.print("\tgcc -I ");
	    out.print(opts.getCorePath());
	    out.println(" -O2 -ansi -Wall -o kesoinfo kesoinfo.c");

            out.println("\ntags:");
            out.println("\t$(CTAGBIN) *.h *.c");
            
            out.close();
            
            // Write global.h
            String filename = opts.getOutputPath()+"/global.h";
            PrintStream glb_out = new PrintStream(new FileOutputStream(filename));
            glb_out.println("/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */\n");
            glb_out.println("#ifndef _GLOBAL_H_");
            glb_out.println("#define _GLOBAL_H_ 1\n");
            glb_out.println("#include <keso_types.h>\n");
            glb_out.println("#include <keso_support.h>\n");
            writeIncludes(glb_out, global_header_includes);
            
            addOsekTypes(glb_out);
            
            glb_out.println(global_header);
            glb_out.println("\n#endif");
            glb_out.close();
            
            // Write global.c
            filename = opts.getOutputPath()+"/global.c";
            glb_out = new PrintStream(new FileOutputStream(filename));
            glb_out.println("/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */\n");
            glb_out.println("#include \"global.h\"");
            
            writeIncludes(glb_out, global_includes);
            glb_out.println(global);

	    global_header_includes=null;
	    global_header=null;
	    global_includes=null;
	    global=null;
            
            glb_out.close();
            
        } catch (IOException ex) {
            throw new CompileException(ex.toString());
        }
    }
    
    
    protected void initManagedResource(Vector resources, String resClass, PrintStream out) throws CompileException {
        if(resources.size()==0) return;
        
        IMClass resource_class = repository.getClass("keso/core/"+resClass);
        
        
        out.print("\t/* Initialize keso_"+resClass.toLowerCase()+"_index */\n");
        for(int i=0; i<resources.size(); i++) {
            Set res = (Set) resources.elementAt(i);
            IMClass specializedClass = resource_class;
            if ( res instanceof TaskDefinition && !(res instanceof NativeTask))
                specializedClass = repository.getClass(((TaskDefinition) res).getMainClassName());
            
            out.print("\tkeso_"+resClass.toLowerCase()+"_index[");
            out.print(res.getIdentifier());
            out.print("] = (" );
            out.print(resource_class.getClassTypeString());
            out.print("*) ");
            out.print(add_accessStaticObject(specializedClass, res.getIdentifier()+"_obj"));
            out.println(";");
            
            // the identifiers are only known on OSEK, for Linux add the
            // information to global.h
            global_header_add("#define ");
            global_header_add(res.getIdentifier());
            global_header_add(" ");
            global_header_add(i);
            global_header_add("\n");
            
        }
        
        out.print("\tkeso_");
        out.print(resClass.toLowerCase());
        out.print("_index[INVALID_");
        out.print(resClass.toUpperCase());
        out.print("] = NULL;\n\n");
    }
    
    
}


