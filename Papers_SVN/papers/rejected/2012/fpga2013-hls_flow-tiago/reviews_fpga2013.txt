============================================================================
FPGA 2013 Reviews for Submission #172
============================================================================

Title: A SoC platform supporting high-level synthesis for FPGAs

Authors: Tiago Rogério Mück and Antônio Augusto Fröhlich
============================================================================
REVIEWER #1
============================================================================


---------------------------------------------------------------------------
Reviewer's Scores
---------------------------------------------------------------------------

Technical Contribution and Quality (1-6): 5
Originality: 4
Readability: 3
Relevance: 3
Confidence: 3
Paper Topic: System-level tools
Overall: 6


---------------------------------------------------------------------------
Comments
---------------------------------------------------------------------------

This paper presents a high-level MPSoC synthesis framework with emphasis on
facilitating communication between hardware and software components in the
system. Both the hardware and software components in system under design are
described using C++ object-oriented programming using method calls for
communication. The C++ described hardware can be reduced to RTL implementation
using HLS (Catapult C). The evaluation establishes the speed and accuracy of
the modeling environment, the cost (performance and area) of the supporting
infrastructure and mechanisms. A PABX design case study is also reported.

Overall, this appears to be a solid and extensive effort. The presentation has
the problem of trying to covering too much at too high a level. I could not
walk away with a clear picture of what the system really does. A good running
design example can really help clarify how designs are specified and
implemented by the system.

What can improve the paper also is a more convincing design study that shows
the design results are competitive relative to some established baseline.

Among the several MPSoC papers I am reviewing, this paper stands out the most
as not really tied to FPGAs and reconfiguration.

============================================================================
REVIEWER #2
============================================================================


---------------------------------------------------------------------------
Reviewer's Scores
---------------------------------------------------------------------------

Technical Contribution and Quality (1-6): 3
Originality: 2
Readability: 2
Relevance: 5
Confidence: 4
Paper Topic: System-level tools
Overall: 4


---------------------------------------------------------------------------
Comments
---------------------------------------------------------------------------

This paper describes a High-Level Synthesis-based software system for large
systems on FPGAs, and a network on chip infrastructure for connecting elements
of the system. It discusses many different ways of describing large
systems,
and ways to simulate and synthesize them. It suggests many levels of
abstraction for doing so –agents proxies,

Unfortunately, at the end of the day, there is so much abstraction and
discussion at a high level, it isn’t clear what is actually achieved.

There are two implementations discussed – a first set taken from MiBench
(which are relatively small DSP kernels) and one from a PABX (an acronym never
elaborated, and it is an old one!), which at this point is a fairly small
application. To me these didn’t warrant all the high-level abstraction
discussed.

The problem is evident even in the abstract of the paper – it doesn’t
convey what the paper is about.

============================================================================
REVIEWER #3
============================================================================


---------------------------------------------------------------------------
Reviewer's Scores
---------------------------------------------------------------------------

Technical Contribution and Quality (1-6): 4
Originality: 4
Readability: 2
Relevance: 5
Confidence: 4
Paper Topic: System-level tools
Overall: 6


---------------------------------------------------------------------------
Comments
---------------------------------------------------------------------------

The paper describes an approach for mapping behavior to hw and sw on an FPGA,
using constructs to maintain communication. System level papers like this are
hard to write; the papers tend to be hard to read, and I found this paper to be
such (even though I also work on system-level issues) -- there's a lot of
abstract discussion. But ultimately, the work seems solid, and there seems to
be a lot implementation/experimentation to support the ideas.

The paper seems to jump around. The virtual platform just seems to come from
out of nowhere, wasn't in the abstract, but shows up, and then results compare
performance and accuracy with RTL. Is the SOC platform the virtual platform,
the RTL with the proxies/agents, both? The UML class diagram seemed out of
place, then the UML sequence diagram seemed like overkill. Why UML at all in
this paper? There's communication, then "metaprogramming" (hard to get one's
head around what a "meta" program is in this context), an SOC platform (I'm not
really sure what that is in your context). Boy, the paper tries to cover a lot
of ground.

What the real FPGA relevance?

I think a substantial rewrite would be helpful, trying to keep things concrete,
giving readily understandable examples, and focusing on the contribution. The
abstract should also be rewritten to be more descriptive of the actual work.

============================================================================
REVIEWER #4
============================================================================


---------------------------------------------------------------------------
Reviewer's Scores
---------------------------------------------------------------------------

Technical Contribution and Quality (1-6): 4
Originality: 4
Readability: 5
Relevance: 4
Confidence: 5
Paper Topic: System-level tools
Overall: 6


---------------------------------------------------------------------------
Comments
---------------------------------------------------------------------------

The authors propose a network-on-chip based SoC platform with a framework that
allows components to be implemented in software that runs on a CPU node or in
hardware with transaction level modeling languages. The proposed framework
abstracts the communication among hardware and/or software components allowing
the programmer to focus on functionality, and enabling software components to
be swapped with hardware and vice versa. The authors do some experiments to
determine the time and area overhead of the given approach, showing low area
overhead, but high time overhead.

The paper is divided into two parts, the platform overview and proposal
(Sections 1 through 4.1), and then some experimental results (Sections 4.2
through 5). The paper's primary strength is in the proposal section, which
provides a good, illustrative overview of the "big picture" of a flexible
network-on-chip architecture and programming model.

As a whole, the primary weakness of the paper is that it doesn't have a clear
focus. The proposal section presents ambitious project ideas covering a
range
of topics:

1) HW->SW communication implementation
2) Platform independent hardware/software switching using metaprogramming
idioms
3) 2D-mesh of stars network-on-chip topology
4) Embedded parallel operating system architecture

But topics (2,3,4) are not supported with experimental results, making the
paper seem awkward and unbalanced.

The experiments seem to focus mostly on HW->SW communication, and reducing the
overhead involved in this process. Unfortunately, few details are provided
about how this reduction in area relative to the previous work is achieved.
Since this seems to be a significant result, the authors should elaborate on
the architecture of Component Manager and other custom hardware that enable
area reduction, allowing other researchers to learn from these advances.

While the authors provide details of the platform independent metaprogramming
idioms, they don't provide much evidence of the advantages of their approach.
The authors can strengthen their case for metaprogramming by listing synthesis
tools that support this kind of code. In addition, a quantitative comparison
of a baseline software/hardware solution to the metaprogramming approach would
be useful (e.g. number of lines, number of differences between software and
hardware implementation).

Topics (3,4) are not discussed in much detail and seem to distract the reader
from the actual work that the authors did. The authors should consider
breaking up the paper, or re-thinking the scope to remove parts that aren't
(yet) relevant.

In summary, the authors cover the "big picture" of network-on-chip architecture

well, but the actual work done only supports a small part of this architecture.
I would recommend using the more illustrative parts of the paper for a short
paper.

Misc. Comments:

* Figure 1: I believe the arrow from C2 to C3 should have a diamond at the
start.
* Section 4.3 paragraph 1: Why does the benchmark process need to be run with
maximum priority? Are there other processes running of the system that can't
be stopped?
* Figure 8: If I'm reading this correctly, it looks like the DTMF and ADPCM
detectors are implemented inside the operating system kernel. Shouldn't they
be in userland (application space)? Maybe Figure 4 needs to clarify where
designer-written software components go.
* Figure 9: Why can't you synthesize/compile each component without remote call
support to get your baseline?
