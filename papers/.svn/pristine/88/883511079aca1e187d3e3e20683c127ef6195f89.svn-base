It is important to highlight their limitations to convince the need for the proposed methodology. 
Most importantly, the results need to compare with SystemC or SpecC based modeling instead of 
providing stand-alone results.

Need to explain whether the proposed method can be included in general design methodologies or 
to be used for specific application only.

Need to explain why the proposed techniques was built on ADESD methodology

Section III - What exactly is "commonality and variability analysis"?
This section should probably give a short introduction to AOP,
followed by how ADESD leverages AOP, which is only shortly mentioned in
the introduction. However, AOP is not mentioned in Section III where
ADESD is introduced in more detail.

Section IV: This section seems to provide a few examples of  unified C++ definition for readability
but also need to provide some intuition why this is universally true for all scenarios. For example,
how to describe memory management for both HW and SW.

The encapsulation of storage allocation/deallocation is already
available in the form of allocators defined by the CSTL. Using the
std::allocator interface, the custom HW allocator may even work for the
CSTL containers. Moreover, std::allocator provides a typedef for the
pointer type, which seems to correspond to the Maybe type which is
also introduced in this chapter. So I think these concepts are already
available in the CSTL.

The limitation mentioned for pointers is not broadly applicable to all high-level synthesis
approaches. Several approaches and tools can efficiently utilize pointers as implemented within 
C/C++ programs.

If the model is used during design space exploration to determine performance values (latency, throughput),
it may be inefficient if the model has to be recompiled for different configurations?
(However, it seems that the components are fed as source code and in isolation to the HW/SW
generation synthesis flow anyway). Perhaps this step could be explained slightly more detailed.

The presented overview does not provide an indication as the designer productivity of the proposed
approach. As one of the goals was to avoid having designers implement software specific and hardware
specific code independently, such an evaluation is merited. Although reporting man-hours for
development of the various systems would be ideal, at a minimum the resulting lines of code required
for the software only, hardware only, and unified implementations should be provided. Also, how much
time is saved compared to using other methodologies ?

Comparison between the proposed technique and HW/SW partitioned implementation and with SpecC/SystemC
based models would be helpful.

While the presentation and results are adequate, the contribution
in form of the AOP techniques seems marginal.
