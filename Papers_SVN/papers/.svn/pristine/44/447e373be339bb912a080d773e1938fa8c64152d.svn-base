\documentclass[conference]{IEEEtran}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{microtype}
\usepackage{balance}
\usepackage{listings}
\usepackage{float}
\usepackage{color,graphicx}
\usepackage[figuresright]{rotating}
\usepackage[tableposition=top]{caption}
\usepackage{listings}
\usepackage{color}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  showstringspaces=false,
  commentstyle=\color{gray}\upshape
}

\lstdefinelanguage{XML}
{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{black},
  identifierstyle=\color{darkblue},
  keywordstyle=\color{cyan},
  morekeywords={xmlns,version,type}% list your attributes here
}


\newcommand{\fig}[4][thb]{
  \begin{figure}[#1] {\centering{\includegraphics[#4]{fig/#2}}\par}
    \caption{#3\label{fig:#2}}
  \end{figure}
}

\begin{document}

\title{AEP - Automatic Exchange of Embedded System Software Parameters.}

\author{
	\IEEEauthorblockN{Rita de Cássia Cazu Soldi and Antônio Augusto Medeiros Fröhlich}
	\IEEEauthorblockA{Federal University of Santa Catarina (UFSC)\\
					  Laboratory for Software and Hardware Integration (LISHA)\\
					  Florianópolis, SC, Brazil\\
					  {rita, guto}@lisha.ufsc.br}
}
\maketitle

\begin{abstract}
The process of debugging  embedded system software is a nontrivial task that consumes a lot of time, once it needs a thorough inspection of the entire source code to make sure that there is no behavior beyond expectations.

Coding and testing embedded systems is even more defiant, since developers need to find out how to optimize the use of the scarce resources since the test itself will compete with the application under test by the scarce system resources. Also, both run in proper platforms, that depends on operating systems, architecture, vendors, debugging tool, etc. This makes embedded systems more susceptible to errors as well as specification failures.

This paper presents AEP, a tool to help developers in the process of debugging embedded systems. The main idea of this tool is emulating various possible system configuration to try to find errors in the application.  An XML file contains all required information to perform automated compilation, emulation and debugging , and there is no need of human interference.

The evaluation of AEP was in terms of memory consumption and time to perform debugging. The obtained results indicate that even with no previous information this tool can produce helpful answers for developers to find and fix bugs.

\end{abstract}

\section{Introduction}
An embedded system can be presented as a combination of software and hardware designed to perform a specific task.  Applications involving environmental monitoring and analysis, intelligent cities, and precision farming are only a sample of a set of possible applications.

These systems were designed to monitor and process data related to the physical environment in which they were coupled. Then, the purpose of these systems was extrapolated to interact with the actors of the modification of this environment, humans. Now, embedded systems are widely attached to numerous electronic devices, and their activities are becoming more popular and intrinsic to human’s daily life~\cite{carro2003sistemas}.

When the interaction between embedded systems and humans was not the main focus, the price for a failure in these systems was more focused on the financial loss such as loss of market share, client information, people time, etc.~\cite{tassey2002economic}. Material losses are inconvenient, but endanger human life is an unacceptable risk. With a focus on direct interaction with humans, we must make sure that the behavior of the systems is in accordance with the specification.

Software testing is the process of analyzing a software item to detect the differences between existing and required conditions (that is, bugs) and to evaluate the features of the software item~\cite{standard:ieee1008:1987}. The test area has evolved considerably, but testing is still one of the most time-consuming development process. Mainly because, it requires a thorough inspection of the source code to find out if the software specification is fully satisfied, and this is a non-trivial process~\cite{parnin2011automated}.

Since the test is not part of the software behavior, it should never interfere in the flow of activities of the software under test. In general-purpose systems, it is usually possible to achieve this premise  without much effort, but some special computer systems have some restrictions, such as low memory, low processing power, limited battery time or a deadline to perform a certain activity. In this case, the developer will still need to find strategies to the test in itself does not compete for resources application.

%Most debug tools are partially automated, and demand interaction with the developer to make decisions during testing \cite{campos2012gzoltar, tracingDiagnose}. This type of tool saves some development time, but not as much when compared to total automation tools. The automation of the entire testing process without any human intervention is still a challenge to researchers, although there are some studies that can automate part of the process with data taken directly from the application \cite{Larson:2013:MDAT,JSWjsw0803603616}.

In this paper, we propose the automatic exchange of configuration parameters (AEP) as an automation of one part of the debugging process for embedded systems' application. The AEP contains a shell script responsible for exchanging configuration parameters according to an XML specification file, without any human interaction during debug processes. This proposal also presents an introduction to the problem of setting up a stable environment for testing embedded systems. 

%In summary, we make the following contributions:
%\begin{itemize}

%\item \textbf{Automated debug an embedded system application.} In this case study developers can run a script to automatic find errors and use a report to fix the code or find better parameter values.

%\item \textbf{Environment for debugging embedded applications, fully configurable according to specific hardware/software requirements.} It is shown how to create an environment for development and test embedded applications using GDB to cross debug the code and QEMU to simulate its execution.

%\end{itemize}

\section{Related Work}
The automated testing area has a vast literature that inspired this proposal. There are several approaches for debugging general purposing systems, and both parameters exchange script and  test environment for debugging embedded systems applications were designed based on them.

Seo et al.~\cite{seo} proposes an interface technique that identify and classify interfaces between embedded system layers. They created a model based tool that generates and executes test cases to analyze these interface layers. They also proposed the emulation test technique that integrates monitoring and debugging embedded systems. Despite the similarity, since we also emulate the target board environment and monitor the behavior of environment variables, Seo et al. focus on testing interfaces and layers, while AEP proposal addresses the testing of components and their integration.

ATEMES~\cite{atemes} is a tool for automatic random tests, including coverage testing, unit testing, performance testing and race condition testing. ATEMES supports instrumentation of source code, generation of tests cases and generation of primitive input data for multi-core embedded software. This system is similar to ours since we also automatically run random tests under cross-testing environment to support embedded software testing. However, the idea of this present work is to integrate the exchange parameters directly in the operating system, so it is possible not only test the application as well as optimize the choice of the configuration parameters.

Statistical Debugging techniques~\cite{zheng2006statistical,zhang2009capturing,parsa2011statistical} are capable of isolating a bug by automatic running an application several times and using generated statistical data to analyze these executions information. This statistical analysis can reduces the bug search area by pinpointing a suspiciousness ranking. This technique could not be incorporated into an embedded system, due to the need of large data set to accomplish this statistic and the necessity to have a big data storage to keep information of all executions. However, a ranking pointing out possible errors is a breakthrough in the developer's work. Therefore, the AEP uses a debugging environment was build on a machine with more storage and processing than the embedded system.

In program slicing~\cite{sasirekha2011program, Xu:2005:BSP:1050849.1050865,artho2011iterative}, the main idea is to divide the code into different parts, then test and remove paths that do not lead to errors. This technique has two approaches for reducing the path that lead to error: static slicing and dynamic slicing. Static slicing has faster reduction of application path, since the final set of paths leading to the error are an approximation of the real set. In dynamic slicing, the initial entry has a great influence on how to slice the code, allowing a greater precision for final errors path. This technique is interesting because it needs only one error path to simplify the group of inputs to be examined. AEP proposal intends to support both types of slicing through configuration files (traits) that can address the whole system or just a  part of the application.

In capture and replay~\cite{burger2008replaying,qi2011locating,orso2005selective} the program is executed until it reaches the end and all operations performed are stored in a log. Burger and Zeller developed a JINSI tool that can capture and replay interactions between inter/intra-components. So  all relevant operations are observed and run step by step, considering all communications between two components until find the bug. Besides being the most widely used, this technique needs to perform all possible paths from one object to another, making this technique time consuming. AEP script runs in a highly configurable operating system, on which  it is possible to plug a single component with different implementations. The design of AEP absorbs the idea of debug focusing on the components that compose the application.

\section{Embedded Systems Debugging Environment}
This section presents details of the debugging process, simulation and how to integrate both in order to create a better environment for developing and testing embedded applications.

Regardless of the technique to be used, debugging can be accomplished in two ways: locally and remotely. Local debugging is when the application runs on the same machine as the debugger. As a result, the latency of application and debugger communication is lower. However, the application interferes in the debug process, e.g. if the application under test crashes, the debugger will need to halt or restart to seek the cause.

 In remote debug,  this influence does not happen since application and debugger run over separate machines. The tests are performed into an isolated box over a network connection. Despite of having some latency issues, from the debugging point of view, the rest of the process can be viewed as a local debug with two screens connected in only one system.

In order to provide the most number of possibilities for the developer, the emulator used to debug applications must provide both ways to perform this activity. Also, for a useful debug, developers must consider others concepts involved in debugging, such as, how to configure the code execution mode, to observe the application outputs, watch some environment's variables, log the tasks performed and others configurations. This requires a good ally to become possible follow program steps, analyze executing state a moment before a crash or even to specify anything that might affect its behavior.

\subsection{Debugging with QEMU and GDB}
QEMU is a generic and open source machine emulator and virtualizer. When used as a machine emulator its possible to run applications made for one machine to another via dynamic translation. The decision to use QEMU emulator was based on active community, support of Linux as the host machine, a native set of target machines and the possibility to integrate a new machine.

Thus, besides having QEMU to emulate applications, we still need to examine the state and variables of the application. Using GDB - \textit{the GNU Project Debugger} it is possible to see inside the application while it executes \cite{gdb}. One important characteristic of GDB is to enable remote debug. Therefore, it is possible to run the program on a given embedded platform while we debug it with GDB running in separated machine. In remote debugging, GDB connects to a remote system over a network and then control the execution of the program and retrieve information about its state.

The integration of both is particular for each host/target machine; thus, some steps presented here must be tailored depending on your target architecture. Figure~\ref{fig:qemu_gdb_gray} presents the activities required to perform remote debugging using IA-32 architecture. These steps and additional explanation of which techniques and tools are used in this process are listed bellow:

\fig{qemu_gdb_gray}{Steps to integrate QEMU and GDB}{scale=.3}

\begin{enumerate}
\item \textbf{Compile with debug information} is the first and the most important step. The source code is the input and the output is the compiled application that has debug information. Using GCC (\textit{GNU project C and C++ compiler}) it can be performed by using \texttt{-g} option to compile.

\item \textbf{Emulate with QEMU} is a necessary step to execute the application in the correct target architecture. To perform this step, the developer must initiate QEMU with \textit{-s -S} options. The first option enables the GDB stub, in order to open communication between QEMU and GDB. The \textit{-S} option is used to force QEMU to wait GDB to connect after the system restart, e.g., if we compile an application with debug information (\textit{app.img}), that prints information in the screen (\textit{stdio}), QEMU call should look like \\
 \texttt{qemu -fda app.img -serial stdio -s -S}

\item \textbf{Connect with GDB} starts with a GDB session, that must be initialized in an separate window. Then, to connect GDB in QEMU the developer must explicitly specify that the target to be examined is remote and inform the host address and port of the target (in this case, QEMU). When host is in the same machine as GDB, its possible inform only the port, but the complete line must be similar to: \texttt{target remote [host]:[port]}


\item \textbf{Recovery debug information} is an important step to help developers to find errors, once its possible to use autocomplete to recovery the all name contained in the symbols table. The file used to keep debug information (as the path) must be informed to GDB using the command:
\texttt{file [path\_to\_the\_file]}

\item \textbf{Finding errors} is an activity that depends on the program to be debugged. From this step, the developer can set breakpoints, watchpoints, control the execution of the program and even enable logs. More information about command set can be found in GDB's page \footnote{http://www.gnu.org/s/gdb/}.
\end{enumerate}


\section{Automatic Exchange of Embedded System Software Parameters}
The algorithm of automatic exchange of parameters is independent of the operating system and platform. However it works on the premise that the system followed an  application oriented system design (AODS) and uses generic programming techniques. It is desirable that each abstraction of the operating systems can be configured as desired using traits template parameter \cite{Stroustrup:c++}. 
\\
\\
**colocar aqui o algoritmo em "alto nível"

The current AEP implementation works on the Embedded Parallel Operating System (EPOS) \cite{Froehlich:2001} since it adds a great deal of configurability of the system, which is very suitable for evaluating an exchange configuration script. For a better understanding of the implementation of AEP will require a short explanation of the configuration of abstractions in EPOS.

\subsection{EPOS}
EPOS is a component-based framework that provides all traditional abstractions of operating systems and services like memory management, communication and time management. Furthermore,  several academic research and industrial projects uses EPOS as base\footnote{http://www.lisha.ufsc.br/pub/index.php?key=EPOS}.

This operating system is instantiated only with the basic support for its dedicated application. It is important to highlight that an individual member of a trait is a characteristic of the system and all features of a component must be set appropriately for a better performance of the system. In this context, the automated exchange of these parameters can be used both to discovery a failure in the program by wrong characterization of components, or to improve the performance for the application by selecting a better configuration.

***Explicar que cada aplicação tem o seu próprio traits e colocar um exemplo do traits do jantar dos filósofos. Aproveitar aqui para explicar o que cada um deles configura e aprovetar para não precisar explicar depois 

\subsection{Configuration file}



\bibliographystyle{abbrv}
\bibliography{references}

\end{document}