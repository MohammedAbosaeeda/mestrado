\documentclass[conference]{IEEEtran}

\usepackage[latin1]{inputenc}	% for Latin languages
\usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support
\usepackage{graphicx}

\newcommand{\fig}[4][htbp]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{#3}}
  \end{figure}
}

\newcommand{\epos}{\textsc{Epos}}

\begin{document}

\title{A Configurable Medium Access Control Protocol for IEEE 802.15.4 Networks}

\author{Rodrigo Vieira Steiner, Tiago Rogério Mück, and Antônio Augusto Fröhlich \\
  \\
  Software/Hardware Integration Lab\\
  Federal University of Santa Catarina\\
  PO Box 476, 88040-900 - Florianópolis, SC, Brazil \\
  \{rodrigo,tiago,guto\}@lisha.ufsc.br
}

\maketitle

\begin{abstract}
  This paper presents the new design of C-MAC, a highly configurable,
  low-overhead Medium Access Control protocol for Wireless Sensor Networks. This
  new design was developed within EPOSMote, a project targeted at enabling
  application-specific deployment scenarios for IEEE 802.15.4 networks. The new
  C-MAC arose from a careful decomposition of several preexisting MAC protocols
  aiming at obtaining their state machines. These individual state machines were
  subsequently merged into a generalized one and captured as a component
  framework that can be specialized to produce a large variety of
  application-specific protocols. The framework was implemented in C++ using
  static metaprogramming techniques, thus ensuring that configurability does not
  come at expense of performance or code size. The experimental results presented
  in the paper corroborate the new design with figures comparable to
  non-configurable, platform-optimized implementations.
\end{abstract}

\begin{IEEEkeywords}
 medium access control, configurability, wireless sensor networks, IEEE 802.15.4
\end{IEEEkeywords}

\IEEEoverridecommandlockouts
\IEEEpubid{978-1-4244-7286-4/10/\$26.00~\copyright2010 IEEE}
%\IEEEpubid{\makebox[\columnwidth]{\hfill 978-1-4244-7286-4/10/\$26.00 ©2010 IEEE}}
\IEEEpubidadjcol
\section{Introduction}
\label{sec:intro}

Wireless sensor networks~(WSN) are highly dependent on efficient Medium Access
Control~(MAC) protocols to make effective use of the few resources available on
traditional motes, bandwidth and energy in particular, but also memory and
processing power. This assertion is confirmed by the large number of MAC protocol
proposals available from the literature~\cite{bachir:2010}.

Most of the optimizations proposed by existing MAC protocols, however, focus on
specific segments of the design space. What is considered an optimization by one
class of applications can represent a strong limitation for others. For instance,
a protocol optimized for massive data dissemination during a firmware update
operation (i.e. short, reliable, low-latency multicast) is certainly not the best
choice for sporadic environment monitoring (i.e. long-lasting, sporadic
unicasts). A MAC protocol aiming at covering a large fraction of the application
universe for sensor networks must feature configuration or adaptation mechanisms
directly controlled by applications. Fully automated decision making at system
level will never be able to match the knowledge programmers have about their
applications.

In this article, we implemented and evaluated EPOS C-MAC in the scope of the
EPOSMote project. C-MAC is a highly configurable MAC protocol realized as a
framework of medium access control strategies that can be combined to produce
application-specific protocols. By selecting the proper strategies and
configuring their parameters, programmers can instantiate MAC protocols that
closely match their applications' requirements. C-MAC relies on static
metaprogramming techniques to achieve high configurability without compromising
size and performance. Indeed, a previous implementation of C-MAC for the Mica2
mote produced B-MAC-like instances that are smaller, faster, and make better use
of the network than the original \textsc{TinyOS} B-MAC~\cite{wanner:2007}. The
EPOSMote devices used in this work feature an IEEE 802.15.4 compliant radio. This
motivated us to evaluate additional configuration parameters, including
synchronization (e.g. beacon-based), contention, and data handling (e.g. error
detection). As a result, C-MAC has undergone a major redesign and now features a
framework whose elements are more fine-grained and thus can be reused in a larger
variety of scenarios.
% reescrever está última frase (ou as duas últimas)

In Section~\ref{sec:macs} we discuss MAC protocols for wireless sensor networks.
In Section~\ref{sec:cmac} we describe the redesign of C-MAC in details. In
Section~\ref{sec:emote} we briefly describe the EPOSMote project, within which
this research was carried out. In Section~\ref{sec:results} we present an
evaluation of the new C-MAC, followed by our conclusions in
Section~\ref{sec:conclusions}.

\section{MAC Protocols for WSN}
\label{sec:macs}
\IEEEpubidadjcol
A Medium Access Control (MAC) protocol decides when a network node may access the
medium, trying to ensure that different nodes do not interfere with each other's
transmissions. In the context of wireless sensor networks, MAC protocols get the
additional duty of ensuring an efficient usage of the radio, often the most
critical component in terms of power consumption. A MAC in this scenario usually
places latency, throughput, and reliability after energy efficiency. Therefore,
the main sources of power overhead in radio-based communication (i.e. idle
listening, collisions, overhearing, and traffic
fluctuations) define guidelines that are followed by
virtually all MACs in this realm~\cite{langendoen:2005}.

% what it does
% what is good
% what is bad. Dont believe what they say, there is always something bad...
B-MAC is a carrier sense MAC protocol for WSN~\cite{polastre:2004}. It provides an interface which enables on-the-fly reconfiguration, allowing network services to adjust their mechanisms. Aspects such enabling and disabling the use of clear channel assessment (CCA) or acknowledgments, setting preamble length and listening intervals. One limitation of B-MAC is that a receiver have to wait until the entire preamble is sent in order to exchange data, even if it was awake at the start of the transmission. This add to the overhearing problem, where receivers stay awake until the end of the preamble and find out that the packet was not addressed to them. Both these limitations are solved by X-MAC, which uses a short preamble and piggybacks the receiver address into it~\cite{buettner:2006}. Since a receiver can detect if the packet is destined to itself before actually receiving it, it can either turn off the radio  or send an acknowledgment to the sender. In advance in the latter case the sender stops sending the preamble and starts to send the data. As both these protocols are CSMA-based, they suffer from the hidden terminal problem.

S-MAC is a MAC protocol for WSN based on time slots~\cite{ye:2002}. It is also a CSMA-based protocol, but it uses the RTS/CTS mechanism to avoid the hidden terminal problem. Neighboring nodes trade synchronization information in order to wake up simultaneously to communicate. A major limitation with S-MAC is that it does not allows any kind of configuration, neither static nor dynamic, and thus have a fixed duty cycle which can lead to waste of energy (idle listening). T-MAC, which is an improvement of S-MAC, addresses this problem and dynamically adapts its duty cycle through fine-grained timeouts~\cite{vandam:2003}. Although the RTS/CTS mechanism solves the hidden terminal problem, it introduces the external terminal problem, to which both these protocols are exposed. Also the information needed to keep neighboring nodes synchronized produces a certain ammount of overhead.

Z-MAC is a hybrid MAC protocol, which combines TDMA and CSMA~\cite{rhee:2008}. It uses a TDMA schedule, but allows nodes to contend for other nodes slots using CSMA. Slots owner are given chances to transmit earlier, so a node can only steal slots from nodes that would not use them. Z-MAC calculates the slot assignements at the time of deployment, which introduces a high overhead.

The IEEE 802.15.4 MAC layer controls the access to the physical layer in two different ways~\cite{ieee:2006}. A basic operating mode, uses CSMA-CA and acknowledgement packets to handle collisions. Another mode, known as beacon-enabled network, uses frame beacons to synchronize devices. These beacons may define an active and an incactive period. The active period is formed by time slots which can be divided in two portions: contention access period (CAP) and contention free period (CFP). During the CAP nodes compete with each others using CSMA-CA. The CFP is formed by guaranteed time slots (GTSs) which are slots allocated to specific nodes, thus no competition for the channel is done during this period. The use of beacon frames allows for a better synchronization between devices thus reducing energy consumption, but it comes at a price of lower throughput.

\section{C-MAC framework}
\label{sec:cmac}

C-MAC is a highly configurable MAC protocol for WSN realized as a framework of
medium access control strategies that can be combined to produce
application-specific protocols~\cite{wanner:2007}. It enables application
programmers to configure several communication parameters (e.g.  synchronization,
contention, error detection, acknowledgment, packing, etc) to adjust the protocol
to the specific needs of their applications. Although highly configurable, C-MAC
instances configured to mimic B-MAC produced better instances than the original
implementation in terms of footprint, performance, and network usage efficiency.
This is due to the static metaprogramming techniques used for the
implementation of C-MAC in C++, which enable aggressive compiler optimizations.

Nonetheless, the original C-MAC defined configurable protocol elements that were
relatively coarse-grained. For instance, synchronization was taken as a single
large component that had to be reimplemented for any new protocol, even if aspects
such as preamble generation and timer synchronization are common to
virtually any protocol. The redesign presented here aimed at making C-MAC more
fine-grained, thus enabling the reuse of microcomponents in a larger variety of
application-specific protocols. The starting point for this new design was a
decomposition of traditional protocols to obtain a generalized
state machine for each of the three major categories~\cite{klues:2007}: channel
polling, scheduled contention, and time division multiple access.

\subsection{Tradicional Protocols Decomposition}

Protocols based on \emph{channel polling} follow a state machine similar to the one presented in Figure~\ref{channel_polling}. They periodically turn on the radio to check for channel activity~(\texttt{LISTEN}). If activity is detected, the the radio is kept on to receive a packet, otherwise it is immediately turned off~(\texttt{OFF}). In order to send a packet, the sender node first waits for the channel to be free~(\texttt{BACKOFF, LISTEN}) and then starts transmitting a synchronization preamble~(\texttt{TX PREAMBLE}). Receivers listening to the channel detect the activity and use the preamble~(\texttt{RX PREAMBLE}) to synchronize themselves with the sender before receiving the packet's payload~(\texttt{RX DATA}). Note that some transitions only take place depending on the protocol. For example, once a receiver has listened the preamble in X-MAC, and it was destined to itself then it sends an acknowledgement to the sender~(\texttt{TX ACK PREAMBLE}) and only then keep listening to receive the data, otherwise it goes into sleep mode. However in B-MAC after receiving the preamble the node has no other option than keep listening to receive the data. Furthermore, even the way the protocol is configured affects the transitions that can be taken. For example B-MAC can enable or disable the use of acknowledgements, backoffs and even CCA.

\fig{.49}{channel_polling}{State machine of protocols based on channel polling.}

\emph{Scheduled contention} protocols program the time in which neighboring nodes must 
wake up to check for channel activity. S-MAC and T-MAC (see section~\ref{sec:macs}) are 
examples of scheduled contention-based protocols. They are generalized by the state 
machine in Figure~\ref{scheduled_contention}. At the beginning of each active period,
neighboring nodes trade additional information to keep themselves synchronized, like the
reception~(\texttt{RX SYNC PKT}) and/or transmission~(\texttt{TX SYNC PKT}) of schedules
in S-MAC. After that, nodes go to the \texttt{ACTIVE} state and are ready to 
transmit or receive data. Nodes willing to transmit data can contend for the channel using
a carrier sense mechanism~(\texttt{CCA}) along with RTS/CTS~(\texttt{RX RTS, TX RTS, RX CTS, TX CTS}). 
After these steps they are ready to transmit/receive with the possibility of using acknowledgment 
packets~(\texttt{ACK TX, ACK RX}).

\fig{.49}{scheduled_contention}{State machine of protocols based on scheduled contention.}

Time Division Multiple Access~(TDMA) protocols also program the time in which a
node must wake up to listen to the channel. The difference to scheduled contention
lays in the fact that each node (instead of a group of nodes) has a specific time
slot to transmit. This way, nodes do not contend for the channel and there are no
collisions. However, getting rid of collisions come at the price of lower
throughput. Since a node can only transmit during its own time slot, it must
remain silent even if other nodes are not transmitting during their slots.
Furthermore, this kind of protocol is sensitive to topology changes, requiring a
reallocation of time slots whenever it happens. Figure~\ref{tdma} depicts the 
generalized state machine for TDMA-based protocols. This state machine is rather similar
to the one of scheduled contention, however the synchronization steps are different if a
node is a master (i.e. the coordinator of the network, responsible for time slots allocation) 
or slave, which is a common configuration for this kind of protocol.

\fig{.49}{tdma}{State machine of TDMA-based protocols.}

\subsection{New C-MAC Design}

A careful analysis of the state machines of the main classes of MAC protocols led us to the
new C-MAC state machine presented in Figure~\ref{cmac}. Each state represents a microcomponent
which can have different implementations. These microcomponents alongside with states
transitions can be combined to produce application-specific protocols. By using static
metaprogramming techniques, microcomponents representing states that do not make sense
for a certain protocol can be completely removed. When a state is removed, its input transitions
are forwarded to the state targeted by its output transitions, still maintaining the original 
transitions semantics. Besides being able to accommodate representative protocols in any of the
three categories, C-MAC state machine also supports hybrid protocols such as Z-MAC and IEEE 802.15.4,
thus covering all the protocols discussed in section~\ref{sec:macs}. 

\fig{.55}{cmac}{C-MAC state machine.}

C-MAC state machine can be triggered either by send/receive events (i.e. when 
the target protocol has a full duty cycle) or periodically by time events 
(i.e. when a sleep/active duty cycle is required). The protocol remains in the 
\texttt{OFF} state, with the radio turned off, until one of the previous events triggers
the transition to the \texttt{SYNCHRONOUS SYNC} state. The dashed states, in Figure~\ref{cmac}, 
represents sets of states related to macro-operations which were encapsulated into a single 
macro-state for better visualization. The states which compose the \texttt{SYNCHRONOUS SYNC} 
macro-state are shown in Figure~\ref{synchronous_sync}. These states are related to operations
used to synchronize duty cycle and were obtained by merging the synchronization steps
shown in the generalized state machines for scheduled contention and TDMA described previously (Figures~\ref{scheduled_contention} and~\ref{tdma}).
A node can start the synchronization by broadcasting~(\texttt{BROADCAST SYNC PKT}) a 
synchronization packet containing synchronization information (e.g. its schedule in a scheduled
contention protocol) which is then followed by the reception of other nodes information~(\texttt{RX SYNC PKT})
like time slots allocation requests in a TDMA-based protocol. At this point, a node can either end
its synchronization (states in bold belong to C-MAC top view state machine) or perform additional
information exchange~(\texttt{TX SYNC PKT, RX SYNC RESP}) with the possibility of using a 
contention mechanism to avoid collisions in this process~(\texttt{CCA}). Note that in the same 
protocol each state can be enabled, disabled, or perform different operations depending on the
node configuration (e.g. the node can be the master, slave, or both in a TDMA-based protocol).
After the node has been properly sinchronized, it goes to the \texttt{ACTIVE} state. If there 
is any transmit/receive request pending, it goes to the related states, otherwise it goes
to the \texttt{OFF} at the end of its active cycle.

\fig{.55}{synchronous_sync}{\texttt{SYNCHRONOUS SYNC} macro-state state machine.}

The \texttt{ASYNCHRONOUS SYNC} macro-state, illustrated in Figure~\ref{asynchronous_sync}, is present for protocols that do not require nodes to have a synchronized duty cycle, and thus does not exchange synchronization data in order to communicate (e.g. B-MAC, X-MAC). This is done through the transmission of a large preamble, or a sequence of short preambles. The result is a subset of the states present in the channel polling state machine (Figure~\ref{channel_polling}), as this mechanism is a part of this kind of protocol.

\fig{.55}{asynchronous_sync}{Asynchronous Sync state machine.}

When the nodes are ready to transmit or receive, they may go through contention mechanisms 
before performing these operations in order to  avoid collisions. These contention mechanisms are
defined by the \texttt{RX CONTENTION} and \texttt{TX CONTENTION} macro-states whose states machines 
are shown in Figures~\ref{cmac_rx_contention} and~\ref{cmac_tx_contention}, respectively.
The states were designed in order to support a carrier sense mechanism~(\texttt{CCA}), 
RTS/CTS~(\texttt{RX RTS, TX RTS, RX CTS, TX CTS}), or both.

\fig{.55}{cmac_rx_contention}{RX Contention state machine.}
\fig{.55}{cmac_tx_contention}{TX Contention state machine.}

After going through the contention mechanisms the nodes are ready to transmit or receive data. 
When the data is received~(\texttt{RX DATA}), it goes through the error handling and 
security mechanism~(\texttt{UNPACK}) and an acknowledgement packet can be transmitted~(\texttt{ACK TX} state). On the transmit side, error handling and security are appended to the data on the~\texttt{PACK} state before transmission~(\texttt{TX DATA}). The~\texttt{ACK RX} state implements acknowledgement packets reception. Some protocols allows the transmission of bursts of data packets (e.g. X-MAC and S-MAC) without contenting for the medium again, which required the \texttt{Keep alive} transitions.

Through these new state machines we were able to expand C-MAC and provide a larger range of configurable points, while achieving a higher level of reuse. The main C-MAC configuration points now include:

\textbf{Physical layer configuration:} These are the configuration points defined
by the underlying transceiver (e.g. frequency, transmit power, date rate).

\textbf{Synchronization and organization:} Provides mechanisms to send or receive
synchronization data to organize the network and synchronize the nodes duty
cycle.

\textbf{Collision-avoidance mechanism:} Defines the contention mechanisms used to
avoid collisions. May be comprised of a carrier sense algorithm (e.g. CSMA-CA),
the exchange of contention packets (\emph{Request to Send} and \emph{Clear to
Send}), or a combination of both.

\textbf{Acknowledgment mechanism:} The exchange of \emph{ack} packets to
determine if the transmission was successful, including preamble acknowledgements.

\textbf{Error handling and security:} Determine which mechanisms will be used to
ensure the consistency of data (e.g. CRC check) and the data security.

\section{The EPOSMote}
\label{sec:emote}

The goal of the EPOSMote project is to develop an \epos-based WSN node focused on 
environmental monitoring~\cite{eposProject}. The nodes have the following main requirements:

\textbf{Low energy consumption:} Usually it is not practicable to often send teams
to the field to replace the nodes batteries, or the nodes may become inaccessible for
long time periods (e.g. nodes inside bags of coffee monitoring its storage conditions).

\textbf{Environmental monitoring features:} The nodes must feature sensors to measure
the environmental conditions, such as temperature, humidity, etc.

\textbf{Environmental integration:} The environment should not be affected by the
nodes presence and vice-versa, so the nodes must be as small, salubrious and strong as possible.

Figure \ref{eposmote_block_diagram} shows an overview of the EPOSMote architecture.
Its hardware is designed as a layer architecture composed by a main module,
a sensoring module, and a power module. The main module is responsible for processing
and communication. It is based on the ATmega1281~\cite{atmel:ATMEGA1281} microcontroller 
and the AT86RF230~\cite{atmel:AT86RF230} radio from Atmel. We have developed a sensoring module 
based on the SHT11 sensor, which is used to measure the environment temperature and humidity. 
Yet expensive, we chose this sensor due to its very small size. Figure \ref{eposmote_pound}
shows the final hardware. The EPOSMote is littler than a £2 coin.

\fig{.45}{eposmote_block_diagram}{Architectural overview of EPOSMote.}

\fig{.13}{eposmote_pound}{EPOSMote side-by-side with a £2 coin.}

\section{Experimental results}
\label{sec:results}

In order to evaluate C-MAC we have implemented a configurable IEEE 802.15.4 MAC on the EPOSMote.
C-MAC was evaluated by varying the following parameters available on IEEE 802.15.4:

\begin{itemize}
 \item Beacon-enabled IEEE 802.15.4.
 \item Non-beacon IEEE 802.15.4.
 \item Non-beacon IEEE 802.15.4 without CSMA-CA.
 \item Non-beacon IEEE 802.15.4 without ACK.
 \item Non-beacon IEEE 802.15.4 without both CSMA-CA and ACK.
\end{itemize}

We have used the network topology shown in Figure~\ref{results_net_topology}. One node is defined 
as the coordinator and other nodes are
placed around the coordinator in a way in which each node is within range of other nodes. 
With this topology each node may potentially interfere in the communications of every other node. 
The topology were configured to simulate a typical environmental monitoring application, where the
coordinator receives data transmitted periodically by other nodes monitoring the environment. 
Other important parameters used in the experiments setup are shown in Table \ref{results_table_params}. 
The \emph{beacon order} and \emph{superframe order} parameters are used only on the beacon-enabled 
configuration to control the nodes duty cycle as specified in the IEEE 802.15.4 standard~\cite{ieee:2006}.

\fig{.5}{results_net_topology}{Network topology used on the evaluation.}

\begin{table}[h]
\caption{Configuration parameters used on the experiments.}
\label{results_table_params}
\centering
\begin{tabular}{ll}
\hline\noalign{\smallskip}
Parameter & Value \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
Compiler & GCC 4.0.2 \\
Microcontroller clock & 1 MHz \\
Packet size & 64 bytes \\
TX power & 3 dBm \\
Beacon order & 7 \\ 
Superframe order & 4 \\ 
Duty cycle & 12\% \\ 
\hline
\end{tabular}
\end{table}

\subsection{Results}

In order to analyze memory footprint we used the avr-size tool, from GNU Binutils version 2.19. 
The results for each configuration are shown in Table \ref{results_table_mem}. As expected, 
the more complex the configuration, the larger the footprint. Thus, the configuration with no beacons,
CSMA, and ACK yielded the smallest footprint, while the full IEEE 802.15.4 configuration yielded the 
largest one. Nevertheless, C-MAC's meta-programmed implementation, along with EPOS's component architecture 
also delivered equivalent functionality with smaller footprint than other known MAC protocols for 
WSN~\cite{polastre:2004}\cite{buettner:2006}\cite{ye:2002}\cite{vandam:2003}.
% As for the data area, which is equal for all configurations, this is due to a implementation issue, but it can be even improved, which is already in our future work list.
%In order to evaluate the memory used by local variable, consider measuring the max stack size or something like that

%\fig{.6}{results_plot_mem}{Memory footprint}
\begin{table}[h]
\caption{Memory footprint of C-MAC on EPOS.}
\label{results_table_mem}
\centering
\begin{tabular}{lcc}
\hline\noalign{\smallskip}
Configuration & Code (bytes) & Data (bytes) \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
No CSMA-CA / ACK & 3248 & 185 \\
No ACK & 3572 & 185 \\ 
No CSMA-CA & 3768 & 202 \\ 
CSMA-CA / ACK enabled & 4092 & 202 \\ 
CSMA-CA / ACK  beacons enabled & 5344 & 215 \\
\hline
\end{tabular}
\end{table}

To evaluate latency, we have measured the round-trip time of a packet between two, three, and four nodes, as show in Figure~\ref{3hop}. 
The results in Figure~\ref{results_plot_latency} show that the latency increases as more features
of the protocol are enabled. On a beacon enabled network, the beacon order and superframe order 
parameters shown in Table \ref{results_table_params} results in a duty cycle of 12\% with a sleep 
period of about 2 seconds, which is the dominating factor when this configuration is used. However, 
the time spent with idle listening is reduced, thus reducing the energy consumption as shown in 
Figure~\ref{results_plot_energy}.

\fig{.6}{3hop}{Configurations used for the round-trip time tests.}
\fig{.39}{results_plot_latency}{Round-trip time of a packet between two, three, and four nodes.}
%\begin{table}[h]
%\caption{Round-trip time of a packet between two nodes}
%\label{results_table_latency}
%\centering
%\begin{tabular}{lc}
%\hline\noalign{\smallskip}
%Configuration & RTT (ms)\\
%\noalign{\smallskip}
%\hline
%\noalign{\smallskip}
%No CSMA-CA / ACK & 60 \\
%No ACK & 68 \\ 
%No CSMA-CA & 71 \\ 
%CSMA-CA / ACK enabled & 79 \\ 
%CSMA-CA / ACK  beacons enabled & 1882 \\
%\hline
%\end{tabular}
%\end{table}

Figure \ref{results_plot_throu} shows the variations of the average throughput as the number of nodes
on the network increases. The overall throughput improves as the features of the protocol are removed 
and presents small variations as the number of nodes increase, this is due to the low network traffic 
and the non-coincidence of the period of transmission of the nodes. The exception is when we enable the 
use of ACK packets and disable CSMA-CA. With this configuration there is a high packet loss due to collisions
and the retransmissions ends up reducing the protocol's performance. 

\fig{.5}{results_plot_throu}{Average network throughput (logarithmic scale).}

The low duty cycle used on the \emph{CSMA-CA / ACK  beacons enabled} configuration yielded the worse throughput.
This configuration also yielded the biggest performance deterioration with the increase in the number of nodes.
This is due to the fact that all nodes try to communicate at the same small period, increasing the chance of 
collisions and packet loss rate, as shown in Figure \ref{results_plot_pkt_loss}. For configurations without beacon
synchronization, the packet loss rate varies similar to the throughput.

\fig{.5}{results_plot_pkt_loss}{Average packet loss rate.}

C-MAC's energy efficiency was evaluated by measuring the energy consumed per byte received at the coordinator, and per byte sent at the leaf nodes. 
Figure \ref{results_plot_energy} shows the results for the coordinator. As expected, the configurations with beacon synchronization
yielded the best results. Except for the beacon-enabled configuration, the energy per byte decreases as the number
of nodes increases. This happens because the main source of energy consumption is idle listening. As the network
traffic increases, the average energy consumed per byte decreases. This is not the case on the beacon-enabled configuration,
showing that it successfully treated the idle listening problem. Figure \ref{results_plot_energy_nodes} shows that, for the leaf
nodes, beacon synchronization incurred an additional energy overhead since they do not suffer from idle listening and all  nodes
transmit on the same small time period, thus increasing the chance of collisions.

\fig{.5}{results_plot_energy}{Energy consumed per byte received on the coordinator.}
\fig{.5}{results_plot_energy_nodes}{Energy consumed per byte sent on the leaf nodes.}

\subsection{Discussion}

With C-MAC, it is possible to configure the protocol according to the application's requirements. The results 
showed that we can easily control the trade-offs among memory footprint, latency, throughput, 
reliability and energy consumption, by using different configurations of IEEE 802.15.4. For example, 
on environments which there are a big number of nodes transmitting very often, but there is no need 
to guarantee the delivery of messages, an implementation without acknowledgment packets can be used to 
increase the network throughput. On environments that contains a big number of nodes that transmit as little 
as possible to save energy, a configuration with CSMA-CA and acknowledgment packets can be used to guarantee the 
message exchange. On applications with more tolerant energy consumption requirements, the beacons can be disabled to
obtain higher throughput and lower latency.

Table~\ref{results_table_cmac_meshnetics} shows the memory footprint and latency of the IEEE 802.15.4 MAC 
provided by Meshnetics ZigBeeNet~\cite{ZigBeeNet} for the ATMega1281/AT86RF230, along with the results obtained from 
the C-MAC evaluation.  C-MAC achieved smaller memory footprint, and performance comparable to a non-configurable, 
platform-optimized implementation. This shows that C-MAC configurability does not come at expense of performance or 
code size.

\begin{table}[h]
\caption{Memory footprint and latency of C-MAC IEEE 802.15.4 and ZigBeeNet IEEE 802.15.4. The latency is the round-trip time
between two nodes. Beacons are disabled on both protocols.}
\label{results_table_cmac_meshnetics}
\centering
\begin{tabular}{lccc}
\hline\noalign{\smallskip}
Configuration & Code (bytes) & Data (bytes) & RTT (ms)\\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
C-MAC IEEE 802.15.4 & 4092 & 202 & 79 \\ 
ZigBeeNet IEEE 802.15.4 & 26776 & 289 & 62 \\
\hline
\end{tabular}
\end{table}


\section{Conclusion}
\label{sec:conclusions}
This paper presented the new design of C-MAC, a highly configurable, low-overhead
Medium Access Control protocol for Wireless Sensor Networks. This new design was
developed within EPOSMote, a project targeted at enabling application-specific
deployment scenarios for IEEE 802.15.4 networks. The new C-MAC arose from a
careful decomposition of several preexisting MAC protocols aiming at obtaining
their state machines. These individual state machines were subsequently merged
into a generalized one and captured as a component framework that can be
specialized to produce a large variety of application-specific protocols. The
framework was implemented in C++ using static metaprogramming techniques (e.g.
templates, inline functions, and inline assembly), thus ensuring that
configurability does not come at expense of performance or code size. 

We experimentaly evaluated C-MAC in terms of memory footprint, latency,
throughput, packet loss rate, and energy consumption by varying IEEE 802.15.4
main configuration aspects. The results corroborate the new design with figures
comparable to the non-configurable, platform-optimized implementation provided by
Meshnetics. %%%%%% VERIFICAR!
Applications using EPOSMote can now easily configure a MAC
protocol to closely match their requirements.
   
\bibliographystyle{IEEEtran}
\bibliography{references.bib}

\end{document}
