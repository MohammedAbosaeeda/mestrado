\documentclass[11pt]{article}

\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.0in}
\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\setlength\parindent{0.25in}
\setlength\parskip{0.0in}

\usepackage{graphicx,url}
\usepackage[latin1]{inputenc}

\let\algorithm\relax
\let\endalgorithm\relax
\usepackage[figure,linesnumbered]{algorithm2e}

\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true,showstringspaces=false,breaklines=true, frame=single,numbers=left}   
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinestyle{prg} {basicstyle=\tiny, lineskip=-0.2ex, showspaces=false}

\newcommand{\prg}[3][tbp]{
\begin{figure}[#1]
    \lstinputlisting[language=C++,style=prg]{fig/#2.cc}
  \caption{#3\label{prg:#2}}
\end{figure}
}

\newcommand{\fig}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}
\sloppy

\title{On the design of flexible real-time schedulers for embedded systems}


\author{Hugo Marcondes$^1$, Rafael Cancian$^2$, Marcelo Stemmer$^2$, Antônio Augusto Fröhlich$^1$ \\ 
	\small{hugom@lisha.ufsc.br, cancian@das.ufsc.br, marcelo@das.ufsc.br, guto@lisha.ufsc.br}  \\ \\ 
 	$^1$ Laboratory for Hardware and Software Integration\\	
	$^2$ System and Automation Department\\
         Federal University of Santa Catarina\\
	PO Box 476 - Florianópolis - Brazil\\
	88040-900\\
	}

\date{}

\begin{document}

\maketitle

\begin{abstract}
Embedded systems frequently impose an integrated hardware/software design within real-time constrains. The essence of real-time is the management of the tasks that realize the system, and with the achievement of the real-time constrains of those tasks, which is usually done by the adequate selection of a scheduling policy. This work proposes a design and implementation of real-time schedulers for embedded systems, within the context of Application Oriented System Design (AOSD). The use of this approach enabled the development of schedulers where the policy is detached from the scheduling mechanism, fostering a better reusability of the scheduling components. The results show that such implementation could scale from 8 bits microcontrollers, 32 bits architectures and to specific hardware implemented design.
\end{abstract}

\section{Introduction}

In contrast with general propose operating systems, Embedded Operating Systems (EOS) should be adapted to provide only the necessary support for a well-defined target-application. Factoring the operating system into selectable and configurable components is a good way to model and to design embedded operating systems. However, dedicated systems often induce an integrated design of software and hardware, needing to deal with a huge diversity of hardware architectures, from 8 bits microcontrollers to dedicated chips (ASIC), making difficult the task of modeling and implementing components that can be effectively reused in several architectures.

The adaptations needed to Embedded Operating Systems (EOS) meet the requirements of the target-applications usually require modifications on many components of the system. As an example, depending on the application, the EOS may need to support mono task, cooperative tasks, or concurrently tasks. Only in the later case a task scheduler is needed, and it may be implemented by very distinct algorithms, may be separated in policies and mechanisms, may have fixed or dynamic priority, may be able to preempt or not, and so on. Besides that, schedules depend on time managers like alarms, and alarms depend on timer counters. Schedules also need to know specific information that belong to the tasks that they will schedule (such as priority, arrival time, deadline, and period). The concurrent tasks also depend on synchronization mechanisms, such as semaphores and mutexes, which in turn need the schedules; if they are real-time synchronization mechanisms, then they will depend on timers as well (to timeout P operations in a semaphore, for example). This example shows that to efficiently adapt an EOS demands good design engineering.

Even in a single family, the adaptation of components to different execution scenarios may not be easy. Task schedules, for instance, have a myriad of algorithms and features, including relatively complex and highly specialized real-time schedules. To allow an EOS to support any scheduling algorithm (real-time or not), independently of its features and without requiring adaptations on the rest of the system, is still a big challenge.

The integrated design of software and hardware on embedded systems allows features typically found on operating systems to be implemented in hardware, using programmable logic devices or even designing ASICs. Nowadays is not rare implementing task schedules on hardware, because this is a very often used component and it is source of considerable overhead. Indeed, an application oriented operating system has to allow their components to be implemented on both the domains (software and hardware) in an efficiently way.

All these problems can not be solved only with careful implementation. They need an appropriated and ingenious system design. In this paper, we focus on the description of the analysis and modeling of the components related to task schedulers and advanced implementation aspects that, only together, allow the appropriated solution for the presented problems. We used domain engineering and a method that aggregates a set of programming paradigms and guide the design of systems adapted to the application. Our contributions includes an efficient model and the correspondent implementation to adapt schedulers on application oriented embedded operating systems, also allowing its execution on different architectures, including small 8 bits microcontrollers.

% Estrutura
This paper is organized in this way: section 2 presents concepts and the description of some schedulers, as well the description of the main techniques used in this work. The sections 3 and 4 present the development held and the results obtained, including the theoretical model and aspects of the proposed implementation. Finally, the section 5 presents some conclusions and final considerations.

\section{Related Work}

The tasks scheduling is considered the heart of a system and dozens of distinct algorithms have been proposed, and the most ones are real-time schedulers for specific applications classes. Many schedulers can be reduced into a simple sort of a ready tasks queue, according to a specific criterion. Indeed, this includes the most known schedulers, such as FIFO, round robin, priority, SPF (\textit{Shortest Process First}), RM (\textit{Rate Monotonic}), and EDF (\textit{Earliest Deadline First}) \cite{Deitel:2005}. However, several other algorithms are much more complex than that. Algorithms such as DSS (\textit{dynamic sporadic server}) and \textit{dynamic priority exchange server} \cite{buttazzo:97} need separated queues for periodic and aperiodic tasks, and at least one special periodic task to deal with the aperiodic tasks with specific timing rules, consumption, and budgets grant. Algorithms such as \textit{Elastic Task Model} \cite{buttazzo:98} allow changes on tasks parameters, such as its period, in order to adapt their self to the current system load, and several other examples could illustrate the major differences between the dozens of task schedulers proposed in the literature. Therefore, to support them in a transparent and efficient way for embedded systems is far from be a simple task.

Several embedded operating systems already allow the adaptation of their schedulers, even dynamically. However, this adaptation is always restricted to a few and simple specific algorithms, such as FIFO, round robin, priority, EDF, and RM. Besides that, many real-time operating systems use scheduler algorithms that do not considerate the tasks' deadline, i.e. they use non real-time schedulers to schedule real-time tasks. Finally, in addition to require guarantees of meeting the tasks' deadline, many embedded real-time applications require further more of the schedulers. Among several possible examples, we can cite the multimedia applications, that require the execution rate of audio and video tasks to be constant (minimizing the jitter). To deal with this kind of requirement is necessary the use of specific algorithms, such as CBS (\textit{Constant Bandwidth Server}) \cite{buttazzo:98}, just because  usual algorithms do not take the jitter into account. From this we can conclude that there is no adequate support to this kind of application when the EOS does not provide specific schedulers, and this is the case of many EOS, including the real-time ones.

% há várias alternativas de SOE e SOTR, mas muitas possuem grandes limitações  
% TIREI O PARÁGRAFO ABAIXO...
%Most real-time operating systems available today, such as Embedded RT Linux, QNX, and VxWorks, have their practical use on deeply embedded platforms limited because of the generated code size and the difficulty of portability. Besides that, most real-time operating systems not take in to consideration software and hardware co-design and then, ignore the possibilities of hardware configuration. So, though exist many supposedly available choices of real-time operating systems for embedded systems, only a few of then are really applicable on several architectures (mainly the ones with bigger resource constrains) and adaptable to the needs of the target applications.

Several researches on hardware/software co-design for real-time systems have been proposed in this and in last decades. Hardware support for task schedulers was proposed, among others, by \cite{mooney:2000}, that had implemented a cyclical schedule, and by \cite{kuacharoen:2003}, that had implemented the RM and EDF priority algorithms. Beyond the support for tasks scheduling, \cite{kohout:2003} had developed hardware support for time and events management, because these activities are very often on the real-time systems and have a high intrinsic parallelism. However, this support is limited to fixed priority schedules. The \emph{HThread} project \cite{Anderson:2006} proposes a programming model that allows tasks implemented on hardware interact with tasks at software, by the implementation of schedulers and synchronization devices on both the domains (hardware and software). Others kinds of support had also been proposed, like memory management \cite{shalan:2000} and resource access protocols \cite{akgul:2003}, that had implemented the priority inheritance protocol to prevents deadlocks and unlimited task blocking. Supports that are more complete include, beyond the scheduling, inter process communication, interrupts management, resources management, synchronization and time management. This support on hardware is usually called real-time Unit (RTU).

% *******************************
%  Verificar como fica os dois proximos paragrafos com o blind review !
% *******************************

%  ACHO QUE O TEXTO CONTINUA, MAS PODEMOS MUDAR O BIB PARA ESCONDER OS AUTORES

%Check Blind review ???
In this scenario, the EPOS (\textit{Embedded Parallel Operating System}) raises up as one viable choice of multiplatform real-time operating system for embedded systems. The EPOS includes frameworks and tools for operating system generation, and it is a result of the \textit{Application-Oriented System Design} (AOSD)~\cite{frohlich:2001}, that combines several design paradigms that aims guide the development of high adaptable e reusable software components. The AOSD brings innovations as scenario adapters \cite{frohlich:2000} e hardware mediators \cite{polpeta:2004} that allow high efficiency on automatic generation of application dedicated operating systems.

%Check blind review ???
Subsequently the EPOS was extended to automatically generate not only the software support, but also the support for hardware blocks (IPs - \textit{Intellectual Properties}) necessary and sufficient to the application, i.e., the application oriented and automatic generation of SoCs (\textit{Systems-on-a-chip}). The extensions on EPOS to SoCs generation are based on the abstraction concepts, hardware mediators and IPs, associating one IP for each mediator \cite{polpeta:2005}. The software engineering really efficiently used for the EPOS design and its expansion for SoCs generation provides a base to it also be a multiplatform real-time operating system. Currently the EPOS has functional support for several architectures such as IA32, PPC, SparcV8, MIPS, and AVR.

\section{Analysis and Design}

% Realizado a engenharia de domínio de forma a identificar
The analysis and design process begin with domain engineering, following the guidelines of the AOSD methodology, which enables the identification of the main commonalities and differences between the concepts that compose the domain. Using this strategy the main entities related to real-time scheduling were identified. The figure~\ref{fig:sch_classmodel} presents the design of such entities.

\fig{0.8}{sch_classmodel}{Proposed task scheduling design}

In this design, the task is represented by the class \texttt{Thread} and defines the execution flow of the task, implementing the traditional functionality of such kind of abstraction, as described in the literature. This class models only aperiodic tasks. Periodic tasks, a common abstraction of real-time systems, are in fact a specialization of the \texttt{Thread} class which aggregate the mechanisms related to the re-execution of the task periodically, using the \texttt{Alarm} abstraction, responsible for reactivating the task when a new period expires. The \texttt{Alarm} abstraction uses the \texttt{Timer} hardware responsible to manage the timing duties of the system.

%
The classes \texttt{Scheduler} and \texttt{SchedulingCriteria} define the structure that realizes the task scheduling. Traditional design and implementations of scheduling algorithms are usually done by a hierarchy of specialized classes of an abstract \texttt{Scheduler} class, which can be further specialized to bring new scheduling policies to the system. In order to reduce the complexity of maintenance of the code (generally present in such hierarchy of specialized classes), as well as to promote its reuse, our design detaches the scheduling policy (criteria) from it's mechanisms (lists implementations) and also detaches the scheduling criteria from the thread it represents. Such division of responsibilities is yield from the domain engineering process.

%
Such separation of the mechanism from the scheduling policy was fundamental for the construction of the scheduler in hardware. In fact, the hardware \texttt{Scheduler} component implements only the mechanisms that realize the ordering of the tasks, based on the selected policy. In this sense, the same hardware component can realize distinct policies, without any hardware reconfiguration, as the definition of the policy is confined in the \texttt{SchedulingCriteria} component. This is achieved by the isolation of the comparison algorithm between the elements of the scheduler queue in the criteria, analogous to the separation of algorithm and the elements of data structures defined in the \textsc{Stl} library.

%
% Config Features - Elastic Scheduling / Preemption / EnergyAware / AdmissionControl
Additionally to the analysis and domain engineering process, several characteristics were identified as configurable features of those components. In fact, such characteristics represent fine variations within an entity of the domain, which can be set in order to change slightly the behavior of the component. Among such configurable features, preemption, admission control of tasks, energy consumption and  changes in tasks'  information were identified as slightly variations of the scheduler.  Preemption allows the scheduler to take a thread out of the CPU when a higher priority thread is ready. Admission control of tasks (i.e. based on CPU utilization of the current set of tasks), as well as the consideration of energy consumption of energy could be evaluated as configurable features responsible by the implementation of quality of service policies (QoS). The capability that a scheduler have to change the properties of tasks that are been used is useful for several more complex algorithms.  As seen on section 2, elastic scheduling algorithms (as the \textit{elastic task model}), assume that the period of a task could be changed, as the CPU utilization rate are getting higher or lower. Others schedulers, as the CBS and DSS (section 2) have analogous behavior. Such characteristic is designed as a configurable features that are applied to the \texttt{SchedulingCriteria} related to periodic tasks, as well as the \texttt{PeriodicThread}, enabling the functions to change the period of one task, once the scheduler requests. In this sense, algorithms that are more complex could be supported and adapted without incurring new specialization of classes.

\fig{0.6}{sch_seq_reschedule}{Task rescheduling sequence diagram}


In order to illustrate the interactions between the components of the proposed design, the figure~\ref{fig:sch_seq_reschedule} presents the interactions of the components during the rescheduling, occurred when the time slice of the current task expires. In this context, the \texttt{Timer} is responsible for generating periodic interruptions, which are counted by the \texttt{Alarm}. When the CPU time slice (quantum) given to the current running thread is expired, the \texttt{Alarm} invokes the \texttt{Thread} method responsible for rescheduling the tasks. Then, the rescheduling method verifies which is the actual running thread, as well as to verify which one should be the next to run, invoking the \emph{choose()} method from the \texttt{Scheduler}. This method returns a pointer to the thread that should be running. The actual running thread pointer is compared with the pointer returned by the \emph{choose()} method, in order to verify if a switch context of the CPU is necessary. If a switch context is necessary, the threads states are updated and the corresponding method for actually switch the context of the involved threads.

\section{Implementation and Results}

%RASCUNHO: Descrição da implementação dos componentes
This section presents the implementation details of the main components of the proposed scheduler schema, specially the implementation of the scheduling mechanism in the software and hardware domain. The main scheduling policies implemented through the \texttt{SchedulingCriteria} are also presented.

\subsection{Software Scheduler}
%\subsection{Escalonador em software}

The implementation of the software scheduler follows the traditional design of lists. Such list implementation its realized as a conventional ordering list of its elements, as well as a relative list, where each element stores its ordering parameter relative with its predecessor. In this sense each element will hold the difference of its ordering parameter from the previous element, and so on. Such kind of implementation is necessary when the scheduling policy has dynamic priority that increases over time, as the very known EDF policy, as an example. In such policy, as the absolute deadline is always a crescent value, the use of a conventional ordering, using the absolute deadline will lead to an overflow of the variable (which can occur in a few hours on 8 bits microcontrollers). Instead of, the use of a relative queue insures that the deadline is always stored relatively to the current time, and in this way, the variable will never overflow. To better illustrate this question, consider the figure ~\ref{fig:relative_scheduling}. This figure shows the behavior of the relative scheduling queue, after the occurrence of some events, as explained above.

\fig{0.9}{relative_scheduling}{Relative scheduling queue behavior.}

Consider the EDF scheduling, and the following tasks with its respective deadlines: T1 - 10 tu, T2 - 15 tu and T3 - 23 tu, where \emph{tu} is the abbreviation for time unit. The figure ~\ref{fig:relative_scheduling}(a) shows the scheduling queue just after the T3 was activated. In this situation, the queue head stores T3 current deadline, while the other elements store their deadline relative to the previous element. In this way, to calculate the actual deadline of an element, it's necessary to sum its value, with the value of all its antecessors. At each occurrence of one time unit, the deadline of all tasks are decreased. As the queue is implemented relatively, however, only the value of the head element should be decreased, and in this way, all the others are updated implicitly. The figure~\ref{fig:relative_scheduling}(b) illustrate the queue after the occurrence of one time unit.

When the task finishes, it is removed from the scheduler and the remaining deadline is added to the next element, in order to maintain the coherence of the queue. The figure ~\ref{fig:relative_scheduling}(c) presents the scheduler queue when the Task T1 finishes its execution, after 8 time units, and the remaining value of the deadline is added to the next element. In such scheme, deadline misses could be signalized by the turning to negative value of the head element of the queue. The figure~\ref{fig:relative_scheduling}(d), shows the scheduling queue when the task T1 is re-activated. Note that in this moment the task T2 has a deadline of 6 time units, thus has higher priority than T1, by the EDF scheduling policy. In this way, the task T1 is inserted between the tasks T2 and T3, adjusting the values of these components to maintain the coherence of the queue.

Independently of the use of relative queues or conventional one, the criterion used by the ordering algorithm of the queue is realized by the \texttt{SchedulingCriteria}. In general, this component can be visualized as a specialization of the integer type, which defines the ordering of the queue. Policies that are more complex can be established by overloading its arithmetical operators. As example, in the case of multi-queues algorithms, a \texttt{SchedulingCriteria} can encapsulate two parameters for ordering: the identification of the queue, and the priority of the element inside that queue, as well as overload the comparison operator less-equal ($\leq$) in order to evaluate both parameters when the elements are compared to establish its position inside the queue implemented on the \texttt{Scheduler} component. This approach allows the efficient implementation of more complex scheduling algorithms.


\subsection{Hardware Scheduler}

The component \texttt{Scheduler} was also implemented in the hardware domain. The figure~\ref{fig:scheduler_hw} illustrates the organization of the logical blocks of this component.

\fig{0.8}{scheduler_hw}{Block diagram of the proposed component in hardware.}

The implementation of the scheduler in hardware follows a well-defined structure. It has an internal memory that implements an ordered list. One module (\texttt{Controller}) is responsible for interpreting all the data received by the interface of the component in hardware and then to activate the process responsible for implementing the functionality requested by the user (through the \texttt{command} interface register). This implementation, as the software counterpart, realizes the insertion of its elements already in order, that is, the queue is always maintained ordered, following the information that the \texttt{SchedulingCriteria} provides. In the memory of the component, a double-linked list is implemented.

It worth's highlight two aspects of the implementation of this component regarding its implementation on hardware, especially for programmable logic devices. Both of these aspects are related to the constraints in terms of resources of such devices. Ideally, a hardware scheduler should exploit as most the inherent parallelism of the hardware resources. However, such resources are very expensive, especially when the internal resources are used to implement several parallel bit comparators in order to search elements on the queue, as well as to find the insertion position of an element in queue.

%
Moreover, the use of 32 bits pointers to reference the elements stored on the list (in this case \texttt{Threads}) becomes extremely costly for implementing the comparators to search such elements. On the other side, the maximum number of tasks in an embedded system is usually known at design time, and for that reason, the resources usage of this component could be optimized by implementing a mapping between the system pointer (32 bits) and an internal representation that uses only the necessary number of bits, taking into account the maximum number of tasks running on the system. 
 
%
Another aspect is related to the search of the position of insertion of the element on the queue. Ideally, such searching could be implemented through a parallel comparison between all elements on the queue, in order to find the insertion point in only one clock cycle. However, such approach, besides increasing the consumption of the resources, as the number of tasks increase it could lead to a very high critical path delay on the synthesized circuit, and thus, to reduce the operating frequency of the component.  %--- FRASE CONFUSA 

By this reason, the insertion of elements was implemented doing a sequential search of the insertion position of the element, which will take N cycles in the worst-case. Besides in this approach, the insertion time could the variable, such variation is hidden by the effect that the insertion could be realized in parallel to the software running on the CPU.

\subsection{Evaluation}

\begin{figure*}[ht]
\center{
	\hspace{0.5cm}
	\begin{minipage}[b]{0.35\linewidth}
		\lstinputlisting[language=C++,style=prg]{fig/thread.cc}
		\vspace{-0.3cm}
		\center{(a)}
	\end{minipage}
	\hspace{0.7cm}
	\begin{minipage}[b]{0.5\linewidth}
		\lstinputlisting[language=C++,style=prg]{fig/main.cc}
		\vspace{-0.3cm}
		\center{(b)}
	\end{minipage}
}
	\caption{Test application: (a) task code and (b) task creation}
	\label{prg:app_test}
\end{figure*}

The evaluation of the proposed scheduler was realized implementing a synthetic real-time application, where a set of periodic tasks was defined. The implemented components were configured using the appropriate tools, which generate a set of configuration parameters binding the interface of the component with its implementation (that could be realized as software or as hardware, through the binding of the interface with its mediator). The figure \ref{prg:app_test}  shows the code of the test application. The figure \ref{prg:app_test}(a) presents the implementation of each task, that simulates the task execution consuming the CPU cycles. The figure \ref{prg:app_test}(b) presents the main application which is responsible for create and activate the tasks that will execute on the system (lines 5-10), defining the scheduling criteria, accordingly to the policy selected on the system. In this example, the \textsc{Edf} scheduling policy is used, defining the period of the task, the deadline, and the number of activations.

The application was compiled for the PowerPC (32 bits) and AVR (8 bits) architecture, using the \textsc{Edf}, \textsc{Rate Monotonic} e \textsc{Priority}. The table~\ref{tab:results_sw} present the footprint of the application for each selected policy and architecture. The tests also validated the implementation of each scheduling policy.

\begin{table}[htb]
\begin{center}
\begin{tabular}{ l | c | c | c | c |}
	& \multicolumn{2}{|c|}{\textsc{Ppc32}} & \multicolumn{2}{|c|}{\textsc{Avr8}} \\
\hline
	& .text  & .data & .text  & .data \\
\hline
EDF & 51052 & 300 & 49246 & 853 \\
\hline
Rate Monotonic & 47908 & 272 & 36800 & 1003 \\
\hline
Priority & 47864 & 272 & 36790 & 1003 \\
\hline
\end{tabular}
\caption{Test application footprint}
\label{tab:results_sw}
\end{center}
\end{table}

The tests were realized also using the scheduler in hardware. In this case, the experimentation platform was a \textsc{Virtex4} FPGA, which combines on PowerPC 405 processor and logic cells, enabling the rapid prototyping of dedicated hardware accelerators.

\begin{table}[htb]
\begin{center}
\begin{tabular}{| c | c | c | c | c |}
\hline
\# Máx. Tasks & Logic Usage & Slices & Máx. Freq. \\
\hline
2	&5\%	&326	&214.6 Mhz\\
\hline
4	&10\%	&551	&161.5 Mhz\\
\hline
8	&19\%	&1078	&138.8 Mhz\\
\hline
16	&36\%	&2015	&123.4 Mhz\\
\hline
24	&51\%	&2833	&114.6 Mhz\\
\hline
32	&73\%	&3997	&113.4 Mhz\\
\hline
48	&103\%	&5665	&82.0 Mhz\\
\hline
\end{tabular}
\caption{FPGA resource utilization of the \texttt{Scheduler} component}
\label{tab:scheduler-hwsize}
\end{center}
\end{table}

The FPGA used on the experimentation platform (ML403) was the \texttt{XC4VFX12} that provides 5,412 slices of logic blocks for the implementation of the accelerators. The table~\ref{tab:scheduler-hwsize} shows the consumed area in this FPGA, accordingly with the configured number of maximum task instantiation.

\section{Conclusions}

This paper presented a design of a flexible real-time scheduler. The use of refined techniques as domain engineering enabled the isolation of the differences of several scheduling policies, enabling a better reuse of the design artifacts (as scheduling policies and scheduling mechanisms), as well as providing a platform not only to design real systems, but also to do experimentation of new real-time scheduling algorithms. The tests show that the proposed system could scale from 32 bits architectures to very deeply embedded system running on 8 bit microcontrollers.

\bibliographystyle{plain}
\bibliography{library}

\end{document}
