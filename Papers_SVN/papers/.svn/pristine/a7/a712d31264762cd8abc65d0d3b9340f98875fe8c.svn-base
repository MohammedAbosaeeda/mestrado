\section{Related Work}
\label{sec:relatedWork}

Statistical Debugging techniques \cite{zhang2009capturing,zheng2003statistical,zheng2006statistical,parsa2011statistical} focus on reduce the search space with features statistically related to failure to reduce the set of solutions that must be checked by the developer. It needs a large data set to accomplish this statistic and its necessary to have a big data storage to keep information of all execution of the code. Despite the minimized search space, the suspiciousness ranking can be complex and some of these techniques can return locations spread in the code, which does not facilitate the developer's work.

%\subsection{Program Slicing}
%\rascunho{(1)explain 2 related work and (2) say why not use}{Show works in statical debug and say why is not a good choice}{(2)The interesting thing is technique is that it needs only one error path. The main idea is to divides the code into different parts, until you can remove most of the paths that do not lead to the set of error checking. There is an advantage: even with this reduction, the final set can still be many paths that do not lead to error, so programmer must check all of then}
In program slicing \cite{sasirekha2011program, Xu:2005:BSP:1050849.1050865} the main idea is to divide the code into different parts, until you can remove most of the paths that do not lead to the set of error checking . This technique is interesting because it needs only one error path to simplify the set of inputs to be studied. However, even with this reduction, the final set can still contain many paths that do not lead to the error, so programmer must check all of them.

%\subsection{Delta Debugging}
%\rascunho{(1)explain 2 related work and (2) say why not use}{Show works in statical debug and say why is not a good choice}{(2)delta debug can reduce the search space for a failure trace and make debug easier, but still need a original trace to compare}
Delta debug and static slicing were combined for speed up the minimization of path leading to the error \cite{lei2005minimization,artho2011iterative}. The main idea is to isolate all changes that cause the failure and simplify the input until get only paths that delivery to the error. Static slices reduce the speed of convergence to this simplified input by reducing the search space for a failure trace and, consequentially, make debug easier. One problem with this technique is the necessity of a original trace to identify the error, because is not always possible to have a bug-free trace.

%\subsection{Capture/Replay}
%\rascunho{(1)explain 2 related work and (2) say why not use}{Show works in statical debug and say why is not a good choice}{(2)In capture and replay the the program must be executed until the end ans all operations are stored in a log. So all operations are run step by step, considering all communications between two components. Besides being the most widely used, it is necessary to perform all possible paths from one object to another, making this technique time consuming.}
In capture and replay \cite{burger2008replaying,qi2011locating,orso2005selective} the program must be executed until the end and all operations are stored in a log. Burger and Zeller developed a Jinsi tool that can capture and replay interactions between inter/intra-components. So all relevant operations are observed and run step by step, considering all communications between two components, until find the bug. Besides being the most widely used, this kind of technique need to perform all possible paths from one object to another, making this technique time consuming.
