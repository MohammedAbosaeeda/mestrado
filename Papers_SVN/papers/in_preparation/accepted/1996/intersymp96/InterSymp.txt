%-------------------------------------------------------------------------------
% PROCESS MANAGEMENT IN NÓ// para InterSymp'96
%-------------------------------------------------------------------------------
\documentstyle[a4,times,12pt,psfig]{article}

%-------------------------------------------------------------------------------
% NOVOS COMANDOS
%-------------------------------------------------------------------------------
\newcommand {\putpict} [5] {
  \begin {figure} [htb]
  \centerline {
    \psfig{figure={#1},width=#2cm,height=#3cm}
  }
  \caption{#4}
  \label{#5}
  \end{figure}
}

%-------------------------------------------------------------------------------
% DEFINIÇÃO DAS PÁGINAS
%-------------------------------------------------------------------------------
% Papel tamanho A4
% Margem superior de 1in sem cabeçalho
% Margens laterais de 1in
% Margem inferior de 1.25in com numeração no meio
% Meia linha entre parágrafos e identação de 
\settopmargin		{1in}
\setbottommargin	{1.25in}
\setleftmargin		{1in}
\setrightmargin		{1in}
\setlength{\headheight}	{0cm}
\setlength{\headsep}	{0cm}
\setlength{\footskip}	{0.45in}
\setlength{\parindent}	{0in}
\setlength{\parskip}	{0.5em}

%-------------------------------------------------------------------------------
% CAPA
%-------------------------------------------------------------------------------
\begin{document}

\title{\bf Process Management in Nó//}

\author{Antônio A. Frölich, João P. de Oliveira \& Jorge R. de Oliveira}

\date{}

\maketitle

\vspace{-3em}
\begin{center}
  Universidade Federal de Santa Catarina \\
  Departamento de Informática e de Estatística \\
  88.049.970 - Florianópolis - SC - BRASIL \\
  Tel.: +55 48 231-9498 ~~~ Fax: +55 48 231-9770\\
  E-mail: \{guto,paulo,jorger\}@inf.ufsc.br
\end{center}

%-------------------------------------------------------------------------------
% RESUMO
%-------------------------------------------------------------------------------
\vspace{2em}
\begin{center}
{\large\bf Abstract}
\end{center}
\vspace{0.5em}

	This paper presents the process management strategies for the NÓ// (reads parallel node) project, which aims to develop a high performance, low cost, multicomputer and a concurrent programming environment for it.

	Nó// operating system has been conceived under a client/server philosophy, so the nucleus functionality restrains to support client and server processes. The other parts of the operating system, like file systems, object management and interface are up to server process. In this context, Nó// process management strategies are described, including the way process are carried out, from its creation to its termination,  scheduled and synchronized.

	The text first gives an overview of the whole project (many parts of the project have already been presented to international community). Then the process concept is depicted to demonstrate how combination of threads and tasks can be used to achieve high performance computation. After that, process manager implementation is presented. Finally, it is presented a perspective  analysis of process manager evolution through distributed and real time environment.

\vspace{1em}
{\bf Keywords:} process management, parallel computing, operating system, client/server architecture.


%-------------------------------------------------------------------------------
% INTRODUCTION
%-------------------------------------------------------------------------------
\section{Introduction}

	The Nó// project (Corso 1993) aims to develop a comprehensive environment for parallel programming, including the conception of a multicomputer (Lücke et al, 1994). Project's basic motivation is the possibility to adopt such a kind of architecture as a natural way to express parallel algorithms, which can be achieved as processes networks that interact among themselves through message exchange. Project goals include, besides the multicomputer, the development of communication mechanisms, an experimental operating system, a parallel programming language and several applications like parallel file systems and compilers. 

	The project gathers several research groups in Brazil. At present, groups at Federal University of Santa Catarina, Federal University of Rio Grande do Sul and University of São Paulo are working cooperatively in areas like computer architecture, operating systems and programming languages.

	To make use of all machine potentiality, it is proposed a new operating system, specially developed for NÓ//. This operating system is conceived as a collection of servers supported by a micro-kernel, which runs in each of the multicomputer nodes. This micro-kernel is responsible solely for the basis of  memory management, processes, communication and synchronization. Other services, like file system, virtual memory and graphic interface can be handled at user level by servers. In order to allow high performance, reliability, adaptability and flexibility the micro-kernel eliminates all machine dependencies with little overhead. Moreover, it is free from most operating system abstractions, like process hierarchy, the user concept and device drivers.

	This paper focuses in the process management strategies for Nó// project, describing the supported process concept, scheduling strategies and synchronization mechanism. After that, it is described some implementation details and personal conclusions. 

%-------------------------------------------------------------------------------
% PROCESSES
%-------------------------------------------------------------------------------
\section{Processes}

	Conceptually, a process is a program in execution. The proposed micro-kernel supports concurrent processes by means of combinations of task and threads, where tasks are passive entities consisting of protected memory segments for code and global data; and threads are active entities that eventually are scheduled to execute some task's code and manipulate its data. Each thread is an independent execution flow, with its own context and stack. Figure \ref{process} shows this model of process.

\putpict{process.ps}{9}{3}{The process model.}{process}

	Although objects are manipulated by threads, their control information are kept by tasks, i. e., when a thread commands the creation of an object (file, mail box, semaphore, etc.) it becomes available to all task's threads.

	Other important observation is that the micro-kernel does not support many of usual systems abstractions, like hierarchy, grouping and ownership (Engler et al, 1994).  Doing so, the micro-kernel implementation is strongly simplified and user level software can choose the best way to handle abstraction to its clients. The lack of process hierarchy leads to a view of tasks and threads as ordinary objects that have their access rights controlled by capabilities (Tanembaum, 1992). 

	The multithreading concept can be used to facilitate the creation of client/server applications. In this context, a server can implemented as a combination of a master thread that receives services requisitions and slave threads that are created to execute each required service. Besides supporting multithreading, the micro-kernel also supports multitasking and task replication as a manner to increase performance and fault tolerance.

%-------------------------------------------------------------------------------
% PROCESS SCHEDULING
%-------------------------------------------------------------------------------
\section{Process Scheduling}

	Process scheduling in Nó// was conceived in a very flexible way, allowing good performance for ordinary time-sharing application, but also providing control mechanisms so external servers can give priority to time constrained activities.

	The micro-kernel schedules threads independently to which task they belong to, i. e., threads of a single task concurs for CPU time in equality with threads of other tasks. The scheduling policy is, theoretically, dynamic priority, nevertheless, some ways to influence scheduling are provided. When a thread is created, its creator thread can define a range of priorities. When a thread is scheduled, the micro-kernel sets a timer to restrict its execution to a certain limit. When the thread leaves the CPU, its priority is re-computed based on the portion of the time-slice it has used, and then adjusted to the interval defined for it.

	This policy is similar to the one adopted in Unix operating system (Bach, 1987). Such a policy has been proved, along the years, to be efficient for interactive systems, as long as it benefits I/O bound process. The main difference is the existence of a priority interval, which yields to other specific policies, once the creator thread can redefine it at anytime. By doing so, the micro-kernel supports the implementation of  a user level scheduler.

%-------------------------------------------------------------------------------
% PROCESS SYNCHRONIZATION
%-------------------------------------------------------------------------------
\section{Process Synchronization}

	In order to support cooperative processing, mechanism for process communication and synchronization are necessary. Process communication is beyond the scope of this paper, however, it can be said that threads of a single task do not need special mechanisms to communicate, since they share the global data segment. Process communication in Nó// is described in (Fröhlich and Zeferino, 1996) .

	Process synchronization is handled by the process manager through the use of semaphores, that can synchronize threads of a single task or can be shared among tasks to synchronize their threads. Semaphore implementation in Nó// conforms to Dijkstra definitions (Andrews, 1990), so the only and atomic ways to alter a semaphore value is through P and V.


%-------------------------------------------------------------------------------
% SYSTEM CALLS
%-------------------------------------------------------------------------------
\section{System Calls}

	Nó// process management strategies are implemented as micro-kernel services and made available to user processes through system calls. There are services for process creation, destruction, scheduling and synchronization, as shown in the following tables.

\begin{table}[htbp] 
\sf 
\begin{center} 
\begin{tabular}{|l|l|} 
\hline 
{\bf System Call} & {\bf Description} \\
\hline 
task\_create	& Creates a new task \\
task\_destroy	& Destroys the specified task \\
task\_wait	& Waits for the destruction of a task \\
\hline 
\end{tabular} 
\end{center} 
\vspace{-1em}
\caption{Tasks manipulation system calls.} 
\label{task} 
\end{table} 

\begin{table}[htbp] 
\sf 
\begin{center} \begin{tabular}{|l|l|} 
\hline 
{\bf System Call} & {\bf Description} \\
\hline 
thread\_create		& Creates a new thread \\
thread\_destroy	& Destroys the specified thread \\
thread\_priority	& Changes the specified thread priority \\
thread\_wait		& Waits for the termination of a specific thread \\
thread\_yeald		& Leaves the CPU in favor of other thread \\
thread\_suspend	& Suspends the specified thread \\
thread\_sleep		& Suspends the specified thread for a certain time \\
thread\_resume	& Makes a thread eligible for execution \\
\hline 
\end{tabular} 
\end{center} 
\vspace{-1em}
\caption{Thread manipulation system calls.} 
\label{thread} 
\end{table} 

\begin{table}[htbp] 
\sf 
\begin{center} \begin{tabular}{|l|l|} 
\hline 
{\bf System Call} & {\bf Description} \\
\hline 
semaphore\_create	& Creates a new semaphore \\
semaphore\_destroy	& Destroys the specified semaphore \\
semaphore\_share	& Shares the sempaphore with the specified task \\
P			& Dijkstra P operation \\
V			& Dijkstra V operation \\
\hline 
\end{tabular} 
\end{center} 
\vspace{-1em}
\caption{Semaphore manipulation system calls.} 
\label{semaphore} 
\end{table} 

	To create a process, its necessary first to create a task and then to create the task's threads. Once created, a thread is eligible to be scheduled, after what it can be suspended for posterior resumption. A process can terminate in two ways: terminating all of its threads or explicitly invoking a system call. Threads can synchronize by waiting for a task or a thread termination, or through the use of semaphores.

	This implementation strategy, that disjoin tasks and threads creation, is specially useful for client/server application design. In this context, one could easily implement a multitask server where one task could be responsible for receiving, organizing and dispatching service requests to other task's threads, responsible for caring out the service. It is certainly possible, since a thread can create threads in another task.

	
%-------------------------------------------------------------------------------
% CONCLUSION
%-------------------------------------------------------------------------------
\section{Conclusion}

The Nó// operating system has advantages if compared to most actual operating system implementations. Operating system like MS-DOS and Windows does not use processor features, like paging, protection and task switch. This is one of the reasons for system crashes and lack of security. It also has advantages if compared to UNIX. Most implementations of UNIX are monolithic and do  not support multithreading. Nevertheless, one goal of Nó// project is to build a POSIX library, so applications developed for UNIX-like operating system can be recompiled.

Some multimedia and industrial automation applications need real time support. Further Nó// operating system implementation shall look upon this theme. An one-processor version of the micro-kernel is being developed to be used in automation. The goal is to have a concurrent programming environment in a 64Kbytes EPROM, so it could be embedded in some electronic products. For while, the Nó// micro-kernel is being used in academia for teaching and research.

%-------------------------------------------------------------------------------
% REFERENCES
%-------------------------------------------------------------------------------
{\vspace{2em}\Large{\bf References}\vspace{0.5em}}

Andrews, G. (1990); Concurrent Programming; Benjamin Cummings.

Bach, M. (1987); The Design of the UNIX Operating System; Prentice-Hall.

Corso, T. (1993);  Ambiente para Porgramação Paralela em Multicomputador; UFSC/CTC/INE.

Engler, D., Kaashoek, M. \& O'Toole, J. (1994); The Operating System Kernel as Secure Programable Machine; Proc. 6th SIGOPS European Workshop.

Frölich, A. \& Corso, T. (1994); SDFS: Simple Distributed File System; Proc. 20th Latin-American Conference on Informatics, México City (pp. 367-376).

Frölich, A. \& Zeferino, C. (1996); Process Communication in Nó//; Proc. International Conference on Information, Systems, Analysis and Systhesis, Orlando (to be published).

Lücke, H., Zeferino, C. \& Silva, V. (1995); Um Multicomputador com Sistema Experimental de Comunicação; Proc. 7th Brazilian Symposium on Computer Architectures and High Performance Processing, Canela (pp. 137-150).

Tanembaum, A. (1992); Using Sparse Capabilities in a Distributed Operating System; Vrije Universiteit zu Amsterdam (technical report).

\end{document}
