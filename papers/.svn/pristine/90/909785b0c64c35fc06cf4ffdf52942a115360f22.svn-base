As requested, the paper went through a major revision guided by the referee's comments. Specific replies follow.

* Reply to Referee 1

The main difference between the proposed API and previously existing ones is the level at which operations are issued. As stated in the requirement list presented in the introduction of the paper (page 2) and illustrated by the example application throughout the paper and also more specifically by figure 9 (page 11), power management operations are meant to be issued at high-level components, such as threads, communicators (i.e. sockets), files, etc. This enables application programmers to specify power management actions without having to directly manipulate hardware devices. Therefore, the strategy promotes portability and reusability across platforms. uCLinux and other related systems require the application to directly interact with device drivers that sometimes are specific to a given platform. It also requires the programmer to track its high-level abstractions down to the underlying hardware, something straightforward for simple applications, but that can reach reasonable complexity in multithreaded applications with concurrent access to devices.

The sections about the implementation of the proposed PM infrastructure with AOP techniques (3.1) and Petry Nets (3.2) were fully rewritten. Besides explaining how scenario adapters are used to apply PM aspect programs to preexisting components, two aspect programs were depicted: accounting and auto-resume. The link between AOP and the Petry Net model was also made clear: traces from the Petry Net simulation yield component-specific rules for the aspect programs that implement the PM infrastructure. The model is first checked for deadlocks and unreachable states, but the main motivation to combine both tools was to avoid the manual implementation of power() methods for non-hardware components, thus  preventing a error-prone, large-scale adaptation of components for the sake of PM. I believe the new version expresses these goals far more adequately than the original one.

Harada's work on energy-aware real-time scheduling bears a scheduling policy that could be easily implemented with the mechanisms described in this paper, but while Harada focused on a QoS analysis of the pertaining issues, this paper focuses on their design and implementation without favoring a particular policy. The integration of concepts such as DVS, budget, and hungry into the proposed strategy is straightforward, since it does not dictates how tasks on each group (i.e. hard real-time and best-effort) should be ordered. It simply splits the task set in two, preventing best-effort execution whenever this would compromise the stipulated lifetime for the hard real-time part. If there is enough energy to run best-effort tasks, then the original system scheduling policy applies, whatever it is.

Section 5, which is about implementation and experiments, was fully rewritten to support a better discussion of the proposed mechanisms. The question about the role of the additional "calibrator" and "display" threads is now clearly stated in section 5.3.


* Reply to Referee 2

It is correct to assume that the goal behind this paper is the proposal of a systematical way to design and implement energy-constrained, real-time embedded systems. No emphasis was given to specific algorithms or heuristics, which are the goals of a large number of papers in the field (including many from my own group). Nonetheless, the paper, in my opinion, bears an important contribution as it proposes a comprehensive strategy to deal with PM matters that does not conflict with most of the work in the field. Algorithms and heuristics proposed by others can be readily incorporated in a system designed according with the strategy proposed here. In this context, section 4.2 does not feature a single, direct algorithm, but defines conditions for the deployment of preexisting algorithms in the context of real-time embedded systems. It also defines links between possible implementations and the infrastructure proposed earlier.

The portability and reusability of application code arises from the fact that applications do not need to interact with hardware components directly, but yet can drive PM actions through simple primitives applied to high-level components. These primitives, along with the proposed autonomous power manager, can define sophisticated PM policies that are essentially platform-independent (the implementation of power() methods for hardware components will always be a point of policy interference, since same-purpose devices might present different transition costs across platforms). These issues have been addressed in the new version of section 3.

As explained in the reply to referee 1, power efficiency does not come exclusively from the proposed strategy, which is focused more on lifetime and real-time correctness. However, concepts targeted at efficiency such as DVS and minimal budget allocation can be promptly incorporated into the proposed strategy. The opposite, that is, applying scheduling strategies that have been isolatedly evaluated to real embedded systems, is likely to demand large efforts, specially due to the lack of proper design guidelines and implementation infrastructure.

The implementation of light and standby modes is now explicitly discussed in section 3.2.


Reply to referee  3

Some of the pointed issues have been addressed in the reply to the other two referees, specially regarding section 5 (experiments). Please, refer to them. Many references have been updated.

The questions about the exotic (if not wrong) use of the English language are certainly bound to the fact that I'm not a native speaker and seems to be a challenge even for professional native reviewers that master the language but then miss the technicalities of the text. Nonetheless, a second professional proofreading was done.
