% ------------------------------------------------------------------------------
\section{Aplicação real}
\label{sec:case_study}
% Distributed Motion Estimation for H.264 encoding.
% 
% - Tells about the role of ME in H.264 
% -  Shows our model of distributed ME component 
% Wrapper do Coordenador
% Wrapper do Worker
% Wrapper do Cronometro
% //- Used mediators/components: DMA mediator (used to exchange data)
% //Barrier mediator/abstraction (used for synchronization between Coordinator and Workers threads)
% 
% // + Evaluation
% 
% Avaliações específicas do encoder ME na seção de estudo de caso mesmo.
% - More general: How many frames per second our component process? 
% (comparation with JM encoder)
% 
% - More specific: Time overhead of wrappers 
% (comparation with JNI, and others)
%
Como forma de avaliar nossa proposta em uma aplicação real, nós desenvolvemos
um componente Java o qual computa estimativa de movimento 
(ME - \emph{Motion Estimation}) para codificação de vídeo H.264.
ME é utilizada para explorar a similaridade entre imagens
vizinhas em uma sequencia de vídeo, permitindo que elas sejam codificadas 
diferencialmente, aumentando a taxa de compressão do 
\emph{bitstream} gerado. % \cite{citeulike:1269699}.
ME é um estágio significante da codificação H.264, pois ele consome 
aproximadamente 90\% do tempo total do processo de 
codificação \cite{XiangLi:2004}.

Visando aumentar o desempenho da ME, nosso componente utiliza uma estratégia de
particionamento de dados, aonde a estimativa de movimento de cada partição da
imagem é realizada em paralelo pelo módulo \emph{Worker}, o qual executa em
uma unidade funcional específica, como por exemplo um núcleo de um processador
multinúcleo.
Existe também o módulo \emph{Coordinator}, o qual é responsável por definir a
partição de imagem para cada instância do módulo \emph{Worker} e por prover a
eles as imagens a serem processadas.
O \emph{Coordinator} é também responsável por agrupar os resultados gerados pelos
módulos \emph{Worker} (i.e. custos de movimento e vetores de movimento) e por
entregar estes resultados de volta para o codificador. 
A figura \ref{fig:threads} ilustra a interação entre os módulos 
\emph{Coordinator} e \emph{Worker}.

\figtwocolumn{.25}{threads}{Interação entre \emph{Coordinator} e \emph{Workers}}

Nosso componente é chamado de \emph{Distributed Motion Estimation Component} - 
DMEC (Componente de Estimativa de Movimento Distribuída), uma vez que o 
cálculo da ME é realizado de forma paralela pelos módulos \emph{Worker}.
Entretanto, esta complexidade é ocultada da aplicação Java 
(e.g. codificador H.264), o qual enxerga apenas um componente para calculo de ME,
realizada pelo método \emph{match}.
O DMEC é implementado como um componente em C++ e é exportado para Java utilizando
a estratégia apresentada na seção \ref{sec:proposal}, aonde é desenvolvido um 
adaptador de código nativo para cada objeto sendo abstraído.

Atualmente o DMEC é implementado por componentes de software, aonde os módulos
\emph{Coordinator} e \emph{Workers} são threads executando em núcleos distintos
de um processador multinúcleo.
Apesar disso o DMEC pode ser implementado por componentes de hardware 
preservando as mesmas interfaces disponíveis na versão em software.
Isso pode ser obtido por meio o uso do conceito de \emph{componentes híbridos}
do EPOS. 
%\cite{Marcondes:IESS:2009}.
Neste caso, nossos adaptadores de código nativo também permanecem os mesmos.
Em um cenário de implementação em hardware \emph{Coordinator} e \emph{Worker}
são IPs (\emph{Intelectual Properties}) de um multiprocessador em chip
(MPSoC - \emph{Multiprocessor System-on-Chip}) e a comunicação entre eles é realizada
por um sistema de interconexão em chip, como por exemplo os descritos por 
\cite{Javaid:2010:OSL:1878961.1878978} e \cite{Popovici:2009:FAC:1509633.1509681}.

% + Dizer que foi feita uma aplicação em Java que realiza um unit test do 
% DMEC, simulando um encoder H.264
Nós escrevemos uma aplicação 100\% Java para utilizar nosso componente DMEC.
Do ponto de vista da ME, a aplicação desenvolvida atua como um codificador
H.264: ela provê ao DMEC imagens para serem processadas e utiliza os resultados
entregues pelo componente verificando se eles estão corretos.
O programa da figura \ref{prgjava:app} mostra o principal método da aplicação.
O DMEC é utilizado como um objeto Java usual.
% NOTA: dizer mais coisa aqui, falar do Wrapper, fazer propaganda.

\prgjava{app}{Aplicação Java DMEC}

% Dizer os resultados
% // + Evaluation
% 
% Avaliações específicas do encoder ME na seção de estudo de caso mesmo.
% - More general: How many frames per second our component process? 
% (comparation with JM encoder)
% 
% - More specific: Time overhead of wrappers 
% (comparation with JNI, and others) pode ficar na secão anterior, não?
%
% TODO: Dizer os resultados. 
% \begin{itemize}
% \item Tempo de processamento dos frames. (Maybe comparation with JM encoder)
% \item Time overhead of wrappers (comparation with JNI, and others)
% \item Application size and footprint
% \end{itemize}

% ------------------------------------------------------------------------------

