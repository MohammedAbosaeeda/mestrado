\documentclass[10pt,conference,a4paper]{IEEEtran}
\usepackage[latin1]{inputenc}	% for Latin languages
\usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{booktabs}

\include{utils} %new commands 


\begin{document}

%\markboth{T. R. Mück and A. A. Fröhlich}{Unified Design of Hardware and Software Components}

\title{On AOP techniques for C++-based HW/SW component implementation}

\author{\authorblockN{Tiago~Rogério~Mück~and~Antônio~Augusto~Fröhlich}
\authorblockA{Federal University of Santa Catarina\\
Florianópolis, Brazil\\
E-mail: \{tiago,guto\}@lisha.ufsc.br}}

%\author{Authors omitted for peer review}

\maketitle

\begin{abstract}
The increasing complexity of embedded system applications is leading to a convergence between
hardware and software development. In this paper we aim to close the gap between
hardware and software implementation by proposing guidelines for handling both domains in a
unified fashion. We leverage on aspect-oriented programming~(AOP) concepts to
provide unified C++ descriptions that can be both compiled to software or synthesized to dedicated
hardware using high-level synthesis tools. Our results show that our strategy leads to reusable
components at the cost of a small overhead when compared to software-only and hardware-only C++
implementations.
\end{abstract}

\begin{keywords}
System-level design, HW/SW co-design, High-level synthesis, Aspect-oriented system design.
\end{keywords}


\section{Introduction}
\label{sec:introduction}
       

Current embedded applications are becoming more sophisticated as the advances of
the semiconductor industry allows the use of an increasingly amount of computational resources.
Also,
strict time-to-market requirements of most applications demand a better productivity, pushing
embedded system designs to the \emph{system-level}. In this scenario, a convergence between hardware
and software design methodologies is desirable, since a unified modeling approach would enable one
to take decisions about hardware/software partitioning later in the design process, maybe even
automatically. In the last few years, advances in \textit{electronic design automation}~(EDA) tools
are allowing hardware synthesis from high-level, software-like descriptions. This process is known
as \textit{high-level synthesis}~(HLS) and allows designers to describe hardware components using
languages like C++, and higher-level techniques, such as \textit{Object-Oriented Programming}~(OOP).
The focus of these tools, however, is hardware synthesis, and they do not provide a clear design
methodology for developing components that could be reused across the hardware and software domains.

Aiming to narrow this gap, in this paper we describe some design guidelines and mechanisms to
support the implementation of both hardware and software components from a single C++ description.
Our guidelines are built upon the \textit{Application-driven Embedded System Design}~(ADESD)
methodology~\cite{Polpeta:2005}. ADESD leverages on OOP and \textit{aspect-oriented
programming}~(AOP) concepts, defining a domain engineering strategy which allows us to clearly
separate the core behavior and the structure of a component from aspects that must be handled
differently whether a component is implemented as hardware or software. In order to generate
descriptions that can be efficiently synthesized by HLS tools or compiled to a software binary, the
implementation of both the components and the mechanisms which adapt them make extensive use of C++
\emph{generative programming}~\cite{Czarnecki:2000} techniques such as \emph{static
metaprogramming}. 

To evaluate the feasibility of our approach, we use a \textit{Private Automatic Branch
Exchange}~(PABX) application of which some components were reimplemented using our unified design
strategy.


\section{Related work}
\label{sec:related_work}

Several design methodologies and tools were proposed in order to provide more tightly coupled
hardware and software design flows. Most of these methodologies were initially based on the concept
of building a system by assembling pre-validated
components~\cite{Vincentelli:2001,Ha:2008,Davare:2007}, which imposed limitations on terms of
hardware/software partitioning. Current design flows leverage on state-of-the-art EDA tools to
support hardware synthesis from high-level C++ constructs. On this track, the OSSS+R
methodology~\cite{Schallenberg:2009} uses cycle-accurate SystemC and adds new language constructs to
support synthesizable polymorphism and high-level communication. However, hardware/software
partitioning must still be done early in the design process\cite{Gruttner:2008}, and the
inclusion of non-standard language constructs reduces compatibility with available compilers
and synthesis tools. The \emph{Saturn}~\cite{Mischkalla:2010} design flow also contributes in this
scenario, but follows a different approach. It aims to close the gap between UML-based modeling and
the execution of the models for their verification. The authors have elaborated over \emph{SysML},
an extension of UML for system-level design, and developed a tool which generates
C++ for software and RTL SystemC for hardware. SystemCoDesigner~\cite{Keinert:2009} is a tool which
integrates a HLS flow with design space exploration. The design entry of SystemCoDesigner is an
actor-based data flow model implemented using SystemC. After design space
exploration, actors of this model can be converted to synthesizable SystemC or to C++ for software
compilation. However, as the authors themselves claim, SystemCoDesigner targets mostly
data-flow-based applications, and they do not provide directions towards a more general deployment.
The System-on-chip environment~(SCE)~\cite{Rainer:2008} takes SpecC models as input and provides a
refinement-based tool flow.  Guided by the designer, the SCE automatically generates a set of
\textit{Transaction-level models}~(TLM)~\cite{Cai:2003} that are further refined to pin- and
cycle-accurate system implementation.

The ADESD~\cite{Polpeta:2005} methodology elaborates on commonality and variability analysis to
add the concept of aspect identification and separation at early stages of design. It defines a
domain engineering strategy focused on the production of families of scenario-independent
components. Characteristics of specific execution scenarios are modeled in special constructs called
\emph{aspects} and are applied to the components only during the final system assembly. In a
previous work~\cite{Pizani:2011}, we have already shown how the ADESD methodology was used to
provide a C++ description of a resource scheduler suitable for HLS. Throughout
the design process, two basic aspects were identified that required a different approach in
the final hardware/software implementation of the scheduler: \emph{resource allocation} and
\emph{communication interface}. In the next sections we show how one can further leverage on ADESD's
artifacts to provide C++ unified descriptions and efficient hardware/software aspects separation.

         
\section{HW/SW aspect encapsulation}
\label{sec:proposal}

C++ code unified and suitable for automatic implementation in both hardware and software must
follow a careful design process so it will not contain characteristics specific of hardware or
software. Throughout the domain decomposition process in our previous work~\cite{Pizani:2011} we
have identified two main features that distinguish hardware from software: \emph{1)storage
allocation}. In hardware, dynamic features such as dynamic memory allocation are not available,
therefore, in synthesizable C++ code all data structures must reside in statically allocated
memory. And \emph{2) communication interface}. The top-level interface of the resulting hardware
block is usually inferred by HLS tool from a single method or function that serves as an
entry-point, whereas in software, components operation can be requested directly through their
method call interface.

Such differences can be efficiently encapsulated using the \emph{aspect} concept of AOP, and weaved
with the unified C++ descriptions in order to obtain an implementation specific for a hardware or
software implementation flow. ADESD proposes the use  of constructs called \emph{Scenario
adapters}~\cite{Mueck:OSR:2012} to perform aspect weaving. Scenario adapters were developed around
the idea of components getting in and out of an execution scenario, allowing actions to be executed
at these points. Figure \ref{fig_hw_sw_scenarios} shows how this is achieved. The
\emph{SW Scenario} and \emph{HW Scenario} classes represent the software and hardware execution
scenarios, respectively, and incorporate, via aggregation, all aspect programs that are needed to
characterize them. The adaptation of the component to the scenario is performed by the
\emph{Scenario\_Adapter} class via a conditional inheritance implemented using static
metaprogramming.

\figSC{.6}{fig_hw_sw_scenarios}{UML diagram showing component adaptation using scenario adapters}

The \emph{HW Scenario} is composed by the aspects \emph{Static Alloc} and \emph{Dispatch}, whom are
responsible, respectively, for storage allocation and method call dispatch. The former is a storage
allocator used to deal with the absence of dynamic memory allocation in hardware. All components
operations go through the allocator which reserves and releases storage space on demand. It is
important to mention that handling memory allocation externally is only possible if the
component follows a careful design process that removes this feature from its core implementation.
For example, the resource scheduler described in our previous work~\cite{Pizani:2011} uses a linked
list to implement its core behavior. This list is designed in a way it is not responsible for
the allocation of space for links and the objects it stores. It implements only the list algorithms
and deals with references to such elements. The example below shows how the \emph{insert} and
\emph{remove} methods of the scheduler are redefined inside the scenario adapter using this
approach:

\scriptsize\begin{verbatim}
Link insert(Object obj) {
    Link link = Scenario::allocate(obj);
    Component::insert(link);
    return link;
}
Object remove(Link link) {
    Object obj = Scenario::get(link);    
    Component::remove(link);
    Scenario::free(link);
    return obj;
}
\end{verbatim}\normalsize

In hardware implementations, \emph{Scenario::allocate(obj)}, \emph{Scenario::get(link)},
and \emph{Scenario::free(link)} map to operations implemented in the \emph{Static Alloc} aspect. In
this scenario, the number of storage slots for links and objects is defined at synthesis-time and
allocation requests are just mapped to a free slot. In a software implementation, dynamic memory
allocation is available, thus, storage allocation can be handled by either the \emph{Static
Alloc} or the \emph{Dynamic Alloc} aspect, as shown in Figure \ref{fig_hw_sw_scenarios}. 

The \emph{Dispatch} aspect is used, in \emph{HW Scenario}, to define an entry point for the
component so it will be compliant with HLS tools requirements. For the tool used in our case
studies (Calypto's CatapultC~\cite{Calypto:Catapult}), the top-level interface of the resulting
hardware block (port directions and sizes) is inferred from a \emph{single function signature}.
This function is defined by \emph{Dispatch} and receives a \emph{method id} as its first parameter,
interprets its value, performs the necessary type conversions and calls the appropriate method of
the component. The value returned by the called method is also inspected, converted if necessary and
assigned to one of the dispatcher output parameters. A dispatch mechanism is not necessary in
the software scenario since operations are requested using direct method calls.

Finally, it is worth mentioning that aspects, scenario, and adapters are implemented using
static metaprogramming and are highly generic. The scenario to which the component is adapted is,
in fact, defined using metaprogramming, as shown in Figure \ref{fig_hw_sw_scenarios}.  Special
template classes called \emph{Traits} are used to define which characteristics of each component is
activated. The code sample below shows an example of a \emph{Trait} class:

\scriptsize\begin{verbatim}
template <> struct Traits<Component> {
    static const bool hardware = true;
};
\end{verbatim}\normalsize

It defines that the component \emph{Component} has a \emph{hardware} characteristic that is used to
define which domain the component will be on (hardware or software). In Figure
\ref{fig_hw_sw_scenarios}, this characteristic is used to conditionally modify the scenario
adapter's base scenario. This decision is statically determined using a metaprogram. The
implementation of \emph{IF} metaprogram is shown below:

\scriptsize\begin{verbatim}
template<bool condition, typename Then, typename Else>
struct IF { typedef Then Result; };

template<typename Then, typename Else>
struct IF<false, Then, Else> { typedef Else Result; };
\end{verbatim}\normalsize

Other aspects concerning hardware generation using HLS are related to the synthesis process. The
same high-level algorithm can span several different hardware implementations. For instance, loops
can have each iteration executed in a clock cycle, or can be fully unrolled in order to increase
throughput at the cost of additional silicon area. This kind of synthesis decision is usually taken
based on directives which are provided separately from the algorithm descriptions. The definition
and fine tuning of these directives is part of the design space exploration process and is not in
the scope of this work.


\section{Experimental results}
\label{sec:case_study}

In order to evaluate our approach, we have applied its mechanisms in the implementation of the
following components of a PABX application: the thread scheduler of EPOS~\cite{EPOS:2011} operating
system, which has been mentioned in Section~\ref{sec:proposal} and described in our previous
work~\cite{Pizani:2011}; a 16-bit IMA ADPCM
encoder/decoder that is used to reduce the traffic of voice data transmitted
through the system; and a \textit{Dual-Tone Multi-Frequency}~(DTMF) detector that uses the
\emph{goertzel algorithm} to check if a sample frame contains specific frequency components. 

In order to demonstrate that unified implementations can be compared to dedicated ones in terms of
efficiency, we compare software scenario-adapted components against the original C++
implementations, and hardware scenario-adapted components against components manually tailored for
high-level synthesis. The scenario-adapted implementations are feed to their respective
software/hardware flows as shown in Figure \ref{fig_hw_sw_flow}. In the software implementation
flow, we have used \emph{gcc 4.0.2} targeting the \emph{Plasma softcore} (a MIPS32 implementation)
and using \emph{level 2} optimizations.
In the hardware flow, the scenario-adapted code is feed to \emph{Calypto's
CatapultC}~\cite{Calypto:Catapult} HLS tool in order to obtain RTL descriptions of the components.
These descriptions were then synthesized using \emph{Xilinx's ISE 13.4} targeting a
\emph{Virtex6 XC6VLX240T} FPGA. CatapultC and ISE were configured to minimize circuit area
considering a target operating frequency of 100 MHz.

\figSC{.6}{fig_hw_sw_flow}{Implementation steps and tools used, for both hardware and software
flows}

Table \ref{tab_result_exec_time} compares the software/hardware-only C++ with the software/hardware
scenario-adapted C++ in terms of the \textit{worst case execution time}~(WCET) of each operation.
The software WCET of the Scheduler and the ADPCM codec is about 2.5\% higher in the unified
implementation. For the DTMF detector, the difference increases to 5\%. The original DTMF detector
requires a single call to \emph{do\_dtmf} to analyze a frame of samples, while the in the refactored
unified DTMF detector, several calls to an \emph{add\_sample} method are required before performing
the same task, which results in a more significant increase in the execution time. For the hardware
side, the \emph{Dispatch} aspect created an overhead which is proportional to the number of
arguments in the operation (\textit{e.g.} 2 for \emph{Scheduler::insert(thread,priority)} and 1 for
\emph{ADPCM\_Codec::encode(sample)}). Analogous to its software counterpart, the high overhead of
the unified DTMF detector also comes from the additional method invocations required to fill its
internal buffer. This operation is implemented in a stream-like fashion in the HW-only detector.

Table \ref{tab_result_area} shows the memory footprint for software implementations and the amount
of FPGA resource required by the hardware implementations. There is an average increase of about
4.9\% in the total memory footprint. In the case of the Scheduler, the overhead comes from the
generalization of storage allocation (the \emph{Static/Dyn Alloc} aspect). For the remaining
case studies, most of the overhead comes from additional code required to encapsulate the behavior
into more reusable OOP classes with a clear method interface. In the hardware implementations,
there is an absolute increase in the number \textit{look-up tables}~(LUTs) and
\textit{flip-flops}~(FFs) which is proportional to the number of operations that must go through the
\emph{Dispatch} aspect. This aspect implement a generic mechanism for parsing and issuing operation
requests, while the hardware-only descriptions focused on more specific and optimized
interfaces. The amount of other dedicated FPGA resources (\textit{e.g.} DSP and RAM blocks) are not
shown since the introduction of scenario adapters affect only the number of LUTs and FFs.

\tabSC{tab_result_exec_time}
{WCET of software/hardware-only C++ \emph{vs.} Unified C++ adapted to software/hardware.}

\tabSC{tab_result_area}
{Area footprint of software/hardware-only C++ \emph{vs.} Unified C++ adapted to software/hardware.}

\section{Conclusion}
\label{sec:conclusion}
In this paper we have explored a methodology based on AOP and OOP concepts in order to produce
unified descriptions of hardware and software components. We have shown that components designed
following the principles presented in this work are susceptible to both software and hardware
generation using standard compilers and HLS tools. This is possible through the isolation of
specific hardware and software characteristics (resource allocation and communication interface)
into aspect programs which are weaved with the unified descriptions only during the final
implementation stages of the design process. Furthermore, our mechanisms are implemented using only
standard C++ features, thus facilitating compatibility with different C++/C-based HLS tools. 

Finally, we have demonstrated our methods by redesigning some functional blocks of a PABX system.
The resulting components confirmed that, at an acceptable cost in area and performance, we can use
C++ as a unified language to implement both hardware and software in an straightforward way, thus
reducing the costs of design cycles and time-to-market, and contributing to the progress of embedded
system design towards system-level methodologies.


\section*{Acknowledgments}
The authors would like to thank João Paulo Pizani Flor and Marcelo Daniel Berejuck for providing the
original implementations of the some of the case studies used in this work. This work is 
partially supported by CAPES, under grants RH-TVD 006/2008 and 240/2008.

\bibliographystyle{IEEEtran}
\scriptsize
\bibliography{paper}


\end{document}
