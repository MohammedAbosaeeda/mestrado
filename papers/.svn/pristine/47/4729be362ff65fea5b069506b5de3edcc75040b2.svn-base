% ------------------------------------------------------------------------------
\section{Related work} \label{sec:relat}
This section reviews how VHLL interact to hardware devices, and how hardware
devices are abstracted and organized to be used by software.

\subsection{FFIs}
Automatic memory management is one of the main features provided by VHLLs.
Allocated objects are automatically freed after they are no longer needed,
freeing developers from writing code to deallocate objects and eliminating the
risk of memory leak.
On the other hand, because VHLLs use automatic memory management the object
address is only know by the runtime support system (e.g. Virtual Machine) of
the VHLLs.
Therefore, VHLLs are unable to directly control memory mapped devices in the
way languages such as C and C++ do (by using the concept of \emph{pointer}).
VHLLs also do not provide the concept of \emph{inline assembly}, used to
control hardware devices by using dedicated I/O assembly instructions.
In other to solve these limitations, VHLLs use a mechanism called Foreign
Function Interface (FFI).

FFI is a mechanism which allows for programs written in one language to use
constructions of a program written in another.
The language that defines the FFI is called \emph{host language} and the
language that has theirs constructions used is called \emph{guest language}.
The host language is usually a higher level language (i.e. VHLL) and the guest
language is usually a lower level language, such as C and C++.

The FFI mechanism has a high importance to VHLLs, not only new programs use FFI
but also some of the main libraries of the VHLL are implemented by using FFI.
This is the case of the Java Standard Platform (JSE), which uses FFI to
implement packages such as \emph{java.io}, \emph{java.net} and \emph{java.awt}.

However a FFI by itself does not guide the developers on the abstraction of
hardware devices, it just provides for the developers a way to access
constructions of other languages capable of access hardware devices directly.
Besides that a manual utilization of a FFI could be difficult since the
developer must take into consideration the semantics of two distinct languages
(the host and the guest language).
Also the manual utilization of a FFI can be error prone.
The following code illustrates the implementation of a sum method using the
Java FFI KNI \cite{_k_2002}.

\begin{verbatim}
KNIEXPORT KNI_RETURNTYPE_VOID
Java_simplemath_Adder_sum() {
    jint a = KNI_GetParameterAsInt(1);
    jint b = KNI_GetParameterAsInt(2);
    KNI_ReturnInt(a + b);
}
\end{verbatim}

In order to obtain the sum arguments, the developer should remember the order
of the formal parameter declaration, represented by the indexes ``1'' and ``2''
passed to FFI functions.

\subsection{HAL}
% Encapsula todos os recursos disponíveis em uma plataforma
% Interdependência desnecessária entre dispositivos
% Hardware abstraído por meio de serviços
% Todos os serviços devem estar presentes em uma dada plataforma independente da
% aplicação utilizá-los ou não
% 
% = Exemplo Linux
% 
% = Exemplo micro Linux
% 
% = Exemplo eCos
\emph{Hardware Abstraction Layer} (HAL) is an approach to abstract
hardware specificities, providing for the operating system (OS) abstract
hardware devices.
The hardware devices abstraction is performed by services such as interruption
handling, reinitialization handling, DMA transferences, timers control, and
synchronization between multiprocessors \cite{Tanenbaum:2007:MOS:1410217}.

In order to port a HAL to a new hardware platform it is necessary to implement
all services provided by such HAL.
However, many services provided by a HAL could not be used by an application
and providing all these services generates unnecessary memory and performance
overhead.

An example of overhead caused by the way HAL are designed and implemented is
the \textsc{uCLinux}, an OS which target embedded systems and
relies on a HAL. % CITE uCLinux.
In such case, \textsc{uCLinux} inherits from \textsc{Linux} several of its
features, among them, the file system abstraction.
Such fact impacts not only on the OS size, as well in all system
initialization infrastructure and application loading \cite{Polpeta:2004}.

Anther example occurs in the RedHat's \textsc{eCos} OS.
% cite ECOS
Although, the HAL used by \textsc{eCos} is based on software components it is
not generated according to the application thus, it can carry unnecessary code
for the system.
In the case of SOCs generated from the micro-architecture LEON2, for example,
the \textsc{eCos} system assumes the existence of an UART device what is not
necessarily true \cite{Polpeta:2004}.

\subsection{Hardware Mediators} \label{sec:adesc_n_hwmediators}
Methodologies based on domain engineering for developing components have been
used as an alternative to the monolithic HALs approach.
Such methodologies have been used for abstracting hardware devices without
generating unnecessary interdependencies between the devices been abstracted.
That is the case of the Application-Driven Embedded System Design (ADESD)
methodology \cite{Froehlich:2001}.

The \emph{Embedded Parallel Operating System} (EPOS), represents the case study
of the ADESD application on the domain of operating systems.
At EPOS the abstractions obtained from domain decomposition are abstraction
of OS, such as threads, semaphores, abstractions for communication such as
network, channels, and other.

In order to provide system abstractions with the needed hardware support ADESD
defines the concept of \emph{hardware mediator}.
Hardware mediators sustain an \emph{interface contract} between system
abstractions and the machine, allowing for such abstractions to be
machine-independent \cite{Polpeta:2004}.
% Este contrato de interface além de ocultar especificidades de dispositivos de
% hardware de fabricantes ou plataformas distintos, pode prover em software
% funcionalidades que não estejam originalmente presentes no dispositivo de
% hardware utilizado.
% Por exemplo, um mediador de Interface de Rede \textit{NIC} pode prover um
% método
% para geração de \emph{CRC}, um código utilizado para verificar a integridade
% na
% transmissão de quadros em uma rede \emph{ethernet}, independentemente do
% dispositivo de hardware em questão possuir ou não tal funcionalidade.
% Ou seja, a abstração que utilizará o mediador da \textit{NIC} poderá sempre
% assumir
% que o método para calculo de CRC existe e ficará a cargo da implementação do
% mediador delegar este calculo para hardware, caso exista esta funcionalidade
% no
% dispositivo de hardware em questão ou, caso contrário, de implementar esta
% funcionalidade em software.

There is a hardware mediator for each hardware device present in the machine.
Such fine grain control avoids the false dependency between devices that occurs
on the monolithic HALs.
The Figure \ref{fig:hardware_mediator-gs} shows hardware mediators, one for
each hardware device.
The figure also depicts another hardware mediator aspect, it is designed to be
overhead free.
By using metaprogramming techniques and function’s inlining is possible to
dissolve mediators among the abstractions that use it, which avoids time
overhead in the use of mediators eliminating method call overhead.

\figtwocolumn{.7}{hardware_mediator-gs}{Hardware Mediators.}


% ------------------------------------------------------------------------------

