\documentclass[english,letterpaper]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{times}
\usepackage{graphicx}
\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}
\lstdefinelanguage{EPOSCFG} {
  keywords={xml,version,DOCTYPE,SYSTEM,family,interface,common,member,type,
  constant,constructor,method,parameter,cost,feature,dependency,name,value}}
\lstdefinelanguage{DTD} {
  keywords={ELEMENT,ATTLIST}}
\lstdefinestyle{prg} {basicstyle=\small\ttfamily, breaklines=true}
\lstdefinestyle{inlineprg} {basicstyle=\small\ttfamily, breaklines=true}

\newcommand{\fig}[3][htbp]{
  \begin{figure}[#1] {\centering\scalebox{0.6}{\includegraphics{fig/#2}}\par}
    \caption{#3\label{fig:#2}}
  \end{figure}
}

\newcommand{\inlineprg}[2][DTD]{
  \bigskip
  \noindent\makebox[\textwidth][l]{
    \begin{lstlisting}[language=#1,style=inlineprg]{}
      ^^J #2
    \end{lstlisting}}
}

\def\textdtd{\lstinline[language=DTD,style=inlineprg]}
\def\textxml{\lstinline[language=XML,style=inlineprg]}


\title{On the Automatic Configuration of\\Application-Oriented Embedded and Parallel\\Operating Systems}

\author{Gustavo Fortes Tondello and Ant\^onio Augusto Fr\"ohlich\\
  Laboratory for Software/Hardware Integration (LISHA)\\
  Federal University of Santa Catarina (UFSC)\\
  PO Box 476 - 88049-900 Florian\'opolis - SC - Brazil\\
  E-mail: \{tondello | guto\}@lisha.ufsc.br\\
  Homepage: http://epos.lisha.ufsc.br/
}

\begin{document}

\maketitle

\begin{abstract}
  This paper presents an alternative to achieve automatic
  run-time system generation based on the Application Oriented
  Systems Design method. Our approach relies on a static
  configuration mechanism that allows the generation of optimized
  versions of the operating system for each of the applications that are going to
  use it. This strategy is of great value in the domain of high performance
  computing since it results in performance gains and resource usage optimization.
\end{abstract}

\section{Introduction}

Previous studies have demonstrated that embedded and high performance
applications do not find adequate run-time support on ordinary
all-purpose operating systems, since these systems usually incur in
unnecessary overhead that directly impact application's
performance~\cite{Anderson:1992a,Schoen:1998}. Each class of
applications has its own requirements regarding the operating
system, and they must be fulfilled accordingly.

The \emph{Application-Oriented System Design}~(AOSD)
method~\cite{Froehlich:2001} is targeted at the creation of run-time
support systems for dedicated high performance computing applications, in particular
embedded, mobile and parallel ones. An \emph{application-oriented
 operating system} arise from the proper composition of selected
software components that are adapted to finely fulfill the requirements
of a target application. In this way, we avoid the traditional ``got
what you didn't ask for, yet didn't get what you needed'' effect of
generic operating systems. This is particularly critical for high performance
embedded applications, for they must often be executed on platforms with
severe resource restrictions (e.g. simple microcontrollers, limited
amount of memory, etc).

Application-Oriented System Design has been corroborated by several
experiments conducted in the scope of project
\textsc{Epos}~\cite{Froehlich:sbac:1999}, including a communication
system for clusters of workstations interconnected in a \textsc{Myrinet}
network that delivered parallel applications unprecedented communication
performance---lowest latency for short messages and maximum bandwidth
for large ones~\cite{Froehlich:hpcn:2000}.

Nonetheless, delivering each application a tailored run-time support
system, besides requiring a comprehensive set of well-designed software
components, also calls for sophisticated tools to select, configure,
adapt and compose those components accordingly. That is,
\emph{configuration management} becomes a crucial to achieve the
announced customizability.

This paper approaches configuration management in
application-oriented operating systems, taking the strategies and
tools currently deployed in \textsc{Epos} as a case-study of
automatic operating system configuration for embedded and parallel applications.
The following sections describe the basics of the
Application-Oriented System Design method, a strategy to
automatically configure component-based systems and a strategy to
describe the components for that purpose. Subsequently, the current
prototypes are discussed along with a real example of the configuration process,
followed by an outline of the next steps
planed for the project along with author's conclusions.


\section{Application-Oriented System Design}

The idea of building run-time support systems through the
aggregation of independent software components is being used, with
claimed success, in a series of projects
\cite{Beuche:1999,Ford:1997,Reid:2000,Baum:1999}. However, software
component engineering brings about several new issues, for instance:
how to partition the problem domain so as to model really reusable
software components? how to select the components from the
repository that should be included on an application-specific system
instance?  how to configure each selected component and the system
as a whole so as to approach an optimal system?

Application-Oriented System Design proposes some alternatives to proceed
the engineering of a domain towards software components. In principle,
an application-oriented decomposition of the problem domain can be
obtained following the guidelines of \emph{Object-Oriented
  Decomposition}~\cite{Booch:1994}. However, some subtle yet important
differences must be considered.  First, object-oriented decomposition
gathers objects with similar behavior in class hierarchies by applying
variability analysis to identify how one entity specializes the other.
Besides leading to the famous ``fragile base class''
problem~\cite{Mikhajlov:1998}, this policy assumes that specializations
of an abstraction (i.e. \emph{subclasses}) are only deployed in presence
of their more generic versions (i.e. \emph{superclasses}).

Applying variability analysis in the sense of \emph{Family-Based
  Design}~\cite{Parnas:1976} to produce independently deployable
abstractions, modeled as members of a family, can avoid this restriction
and improve on application-orientation.  Certainly, some family members
will still be modeled as specializations of others, as in
\emph{Incremental System Design}~\cite{Habermann:1976}, but this is no
longer an imperative rule. For example, instead of modeling
connection-oriented as a specialization of connectionless communication
(or vice-versa), what would misuse a network that natively operates in
the opposite mode, one could model both as autonomous members of a
family.

A second important difference between application-oriented and
object-oriented decomposition concerns environmental dependencies.
Variability analysis, as carried out in object-oriented decomposition,
does not emphasizes the differentiation of variations that belong to the
essence of an abstraction from those that emanate from the execution
scenarios being considered for it. Abstractions that incorporate
environmental dependencies have a smaller chance of being reused in new
scenarios, and, given that an application-oriented operating system will
be confronted with a new scenario virtually every time a new application
is defined, allowing such dependencies could severely hamper the system.

Nevertheless, one can reduce such dependencies by applying the key
concept of \emph{Aspect-Oriented Programming}~\cite{Kiczales:1997}, i.e.
aspect separation, to the decomposition process.  By doing so, one can
tell variations that will shape new family members from those that will
yield scenario aspects. For example, instead of modeling a new member
for a family of communication mechanisms that is able to operate in the
presence of multiple threads, one could model multithreading as a
scenario aspect that, when activated, would lock the communication
mechanism (or some of its operations) in a critical section.

Based on these premises, Application-Oriented Systems Design guides a
domain engineering procedure (see Figure~\ref{fig:aosd-abs}) that models
software components with the aid of three major constructs: families of
scenario-independent abstractions, scenario adapters and inflated
interfaces.

\fig{aosd-abs}{Overview of application-oriented domain decomposition as
  regards abstractions.}

\subsection*{Families of scenario independent abstractions}

During domain decomposition, abstractions are identified from domain
entities and grouped in families according to their commonalities. Yet
during this phase, aspect separation is used to shape
scenario-independent abstractions, thus enabling them to be reused in a
variety of scenarios.  These abstractions are subsequently implemented
to give rise to the actual software components.

%Any functionality identifyed as optionally aplicable to every member of a
%famlily is modeled as a separate construct named configurable feature.
%Configurable features can be individually activated or deactivated as part
%of the configuration process, and describe the behavior that should be realized by the
%member of a family when it is activated, without the specification of implementation details.

The implementation of the members of a family of abstractions is not
restricted to the use of specialization as we would do in
object-orientation, although it can occur, when convenient. For example,
members could be implemented as classes conjunctly distributed as a
package through aggregation or composition. Afterwards, some families
may contain mutually exclusive members, that is, only one of the members
can be present in the system configuration at a time.

\subsection*{Scenario adapters}

As explained earlier in this article, Application-Oriented System
Design dictates that scenario dependencies must be factored out as
\emph{aspects}, thus keeping abstractions scenario-independent.
However, for this strategy to work, means must be provided to apply
factored aspects to abstractions in a transparent way. The
traditional approach to do this would be deploying an \emph{aspect
weaver}, though the \emph{scenario adapter}
construct~\cite{Froehlich:sci:2000} has the same potentialities
without requiring an external tool.  A scenario adapter wraps an
abstraction, intermediating its communication with
scenario-dependent clients to perform the necessary scenario
adaptations.

\subsection*{Inflated interfaces}

Inflated interfaces summarize the features of all members of a family,
creating a unique view of the family as a ``super component''. It allows
application programmers to write their applications based on well-know,
comprehensive interfaces, postponing the decision about which member of
the family shall be used until enough configuration knowledge is
acquired. The binding of an inflated interface to one of the members of
a family can thus be made by automatic configuration tools that identify
which features of the family were used in order to choose the simplest
realization that implements the requested interface subset at
compile-time.


\section{Software Component Configuration}

An operating system designed according to the premises of
Application-Oriented System Design, besides all the benefits claimed by
software component engineering, has the additional advantage of being
suitable for automatic generation. The concept of inflated interface
enables an application-oriented operating system to be automatically
generated of out of a set of software components, since inflated
interfaces serve as a kind of requirement specification for the system
that must be generated.

An application written based on inflated interfaces can be submitted to
a tool that scans it searching for references to the interfaces, thus
rendering the features of each family that are necessary to support the
application at run-time. This task is accomplished by a tool, the
\texttt{analyzer}, that output an specification of requirements in the
form of partial component interface declarations, including methods,
types and constants that were used by the application.

The primary specification produced by the \texttt{analyzer} is
subsequently fed into a second tool, the \texttt{configurator}, that
consults a build-up database to create the description of the system's
configuration.
This database holds information about each component in the
repository, as well as dependencies and composition rules that are
used by the \texttt{configurator} to build a dependency three.
Additionally, each component in the repository is tagged with a
``cost'' estimation, so that the \texttt{configurator} will chose
the ``cheapest'' option whenever two or more components satisfy a
dependency.  The output of the \texttt{configurator}
consists of a set of keys that define the binding of inflated
interfaces to abstractions and activate the scenario aspects
eventually identified as necessary to satisfy
the constraints dictated by the target application or by the
configured execution scenario.

The last step in the generation process is accomplished by the
\texttt{generator}. This tool translates the keys produced by the
\texttt{configurator} into parameters for a statically metaprogramed
component framework and causes the compilation of a tailored system
instance. An overview of the whole procedure is depicted in
Figure~\ref{fig:tools}

\fig{tools}{An overview of the tools involved in automatic system
  generation.}


\section{Software Component Description}

The strategy used to describe components in a repository and their
dependencies plays a key role in making the just described configuration
process possible.  The description of components must be complete enough
so that the \texttt{configurator} will be able to automatically identify
which abstractions better satisfy the requirements of the application,
and this without generating conflicts or invalid configurations and
compositions.

The strategy to describe components proposed here, could indeed be taken
further as to specify components, for it encompasses much of the
information needed to implement components, including their interfaces
and relationships to other components. It is based on a description
declarative language implemented around the \emph{Extensible Markup
  Language}~(XML)~\cite{xml} and target at the description of individual
families of abstractions\footnote{A complete description of the software
  component repository is obtained simply by merging individual
  families' descriptions.}. The most significant elements in the
language will be explained next, taking as basis the corresponding
\emph{Document Type Definition})~(DTD)~ fragments.

\subsection{Families of abstractions}

The declaration of a family of abstractions in our language consists
of the family's inflated interface, an optional set of dependencies,
and optional set of traits, its common package and a set of family
members (software components), like this:

\inlineprg[DTD]{<!ELEMENT family (interface, dependency*, trait*, common, member+)>}

The inflated interface of a family, as explained earlier, summarizes the
features of the whole family and is specified as follows:

\inlineprg[DTD]{<!ELEMENT interface (type, constant, constructor, method)*>}

The common package of a family holds type and constant declarations that
are common to all family members. It is specified as:

\inlineprg[DTD]{<!ELEMENT common (type, constant)*>}

The \textdtd{member} element shown bellow is used to describe each of
the members in a family. It is at the heart of the automatic
configuration process, enabling tools to make the proper selection while
looking for inflated interface realizations. A family member is declared
as:

\inlineprg[DTD]{<!ELEMENT member (super, interface, trait, cost, feature, dependency)*>}

The \textdtd{super} element enables a member to inherit declarations of
other members in the family, allowing for the creation of incremental
families much as in \emph{Incremental System Design}~\cite{Habermann:1976}.
A member's interface designates a total or partial realization of the family's
inflated interface in terms of members \textdtd{type}, \textdtd{constant},
\textdtd{constructor} and \textdtd{method}.  Element \textdtd{trait},
which can also be specified for the family as whole, designates a configurable
information that can be set by users, via configuration tools, in order to influence
the instantiation of a component\footnote{Traits are made available at
  compile-time to the static metaprograms that build up the component
  framework.}. A trait of a component can also be used to specify
configuration parameters that cannot be automatically figured out, such
as the number of processors in a target machine and the amount of memory
available.

Additionally, each member of a family is tagged with a relative \textdtd{cost}
estimation that is used by the configuration tools in case multiple
members satisfy the constraints to realize the family's inflated
interface in a given execution scenario. This cost estimation is
currently rather simplistic, consisting basically of an overhead
estimation made by the component developer. More sophisticate cost
models, including feed-back from the configuration tools, are planed for
the future.

\subsection{Functional dependencies}

Although we can use the \texttt{analyser} tool to discover the dependencies of the
application regarding the families' interfaces, this tool cannot be used to discover
the dependencies that a family's implementation has on another one. Thus, this
kind of depency must be explicited by the programmer through the \textdtd{dependency}
member. This dependency may happen to the entire family or just on individual members.

The \textdtd{dependency} element has only one attribute that describes the name of
the family whose dependency consists. We should also include in this dependency description
the partial interface with the constructors and methods of one family called by the other
one, allowing the \texttt{configurator} to be able to resolve any kind of dependency.
However, in the actual development stage of Project \textsc{Epos} we have never identifyied
a family of abstractions whose members had dependencies on another family differentiated by
the partial interface description. These differences usually occur regarding non-functional
dependencies (described next). As so, we have decided to keep the simpler description
of the family name only. In the future, if the situation where the partial interface is
necessary to decide which abstraction needs to be selected to satisfy the dependency may
occur, our model will have to be extended to support this detail level.

\subsection{Non-functional properties and dependencies}

The description of the interfaces in a family of abstractions is the
main source of information for the proposed configuration tools, but
correctly assembling a component-based system goes far beyond the
verification of syntactic interface conformance: non-functional and
behavioral properties must also be conveyed. For this purpose, our
component description language includes two special elements:
\textdtd{feature} and \textdtd{dependency}. These elements can be
applied to virtually any other element in the language to specify
features provided by components and dependence among components that cannot
be directly deduced from their interfaces. Enriching the description of
components with features and dependencies can significantly improve the
correctness of the assembly process, helping to avoid inconsistent
component arrangements.

For instance, consider a family of wireless network abstractions. Some
members could declare a ``reliable'' feature, making them eligible to
support an application whose execution scenario demands for reliable
communication. Similarly, members of a family of communication protocols
could specify the dependency on a ``reliable'' wireless network
infrastructure, while other could implement the feature themselves.

A feature has a name and a value. The name should be regarded as a
meaningful feature in the application domain. Considering the example
above, we could specify the reliable feature of a wireless network as
follows:

\begin{lstlisting}[language=EPOSCFG,style=inlineprg]{}
<family name="Wireless_Network">
  <interface>...</interface>
  <common>...</common>
  <member name="Wi-Fi">
    <interface>...</interface>
    <feature name="reliable" value="false"/>
  </member>
</family >
\end{lstlisting}

\noindent and the dependency in the protocol family, extendend to allow
the inclusion of inner \textdtd{feature} elements, as:

\begin{lstlisting}[language=EPOSCFG,style=inlineprg]{}
<family name="Wireless_Protocol">
  <interface>...</interface>
  <dependency family="Wireless_Network"/>
  <common>...</common>
  <member name="Active_Message">
    <interface>...</interface>
    <dependency family="Wireless_Network">
      <feature name="reliable" value="true"/>
    </dependency>
  </member>
</family >
\end{lstlisting}

It is important to mention that the fact of the
\textxml{Active_Message} member of the
\textxml{Wireless_Protocol} family requiring a reliable
\textxml{Wireless_Network} does not
summarily excludes the \textxml{Wi-Fi} member: the \texttt{configurator}
would first check whether a scenario aspect is available that could be
applied to a non-reliable network in order to make it behave as a reliable one.
In the particular case of \textsc{Epos}, such a scenario aspect
exists and would enable the correct integration of both components.


\section{Example}
To validate the ideas proposed here, we have developed a very simple example
to demonstrate the aplication of the concepts.

Our example consists on a \textsc{C++} implementation of the Philosofer's Dinner
using two families of \textsc{Epos} abstractions: \textxml{Thread}
and \textxml{Synchronizer}. The program was written using the inflated
interfaces of each family, without specifying the member implementation to use.

The output of the \texttt{analyser} for our application was:

\begin{lstlisting}[language=EPOSCFG,style=inlineprg]{}
<interface name="Synchronizer">
  <constructor>
    <parameter type="int"/>
  </constructor>
  <method name="p" return="void"/>
  <method name="v" return="void"/>
</interface>

<interface name="Thread">
  <constructor>
    <parameter type="System::Int::Thread_Common::Self const&">
  </constructor>
  <constructor>
    <parameter type="int (*)(int)"/>
    <parameter type="int"/>
    <parameter type="short const&"/>
    <parameter type="short const&"/>
  </constructor>
  <method name="suspend" return="void"/>
  <method name="wait" return="void">
    <parameter type="int *"/>
  </method>
  <method name="yield" return="void"/>
</interface>
\end{lstlisting}

Now we must enter this data into the \texttt{configurator}. For the selection of the
member of the \textxml{Synchronizer} family, it would consult the XML file of the
family, partly listed bellow:

\begin{lstlisting}[language=EPOSCFG,style=inlineprg]{}
<family name="Synchronizer" type="abstraction" class="dissociated">
  <interface>
    ...
    <method name="id" return="const Id &"/>
    <method name="valid" return="bool"/>
    <method name="lock" return="void"/>
    <method name="unlock" return="void"/>
    <method name="p" return="void"/>
    <method name="v" return="void"/>
    <method name="wait" return="void"/>
    <method name="signal" return="void"/>
    <method name="broadcast" return="void"/>
  </interface>
  <common>...</common>
  <member name="Mutex" type="inclusive" cost="1">
    <interface>
      ...
      <method name="id" return="const Id &"/>
      <method name="valid" return="bool"/>
      <method name="lock" return="void"/>
      <method name="unlock" return="void"/>
    </interface>
    ...
  </member>
  <member name="Semaphore" type="inclusive" cost="5">
    <interface>
      ...
      <method name="id" return="const Id &"/>
      <method name="valid" return="bool"/>
      <method name="p" return="void"/>
      <method name="v" return="void"/>
    </interface>
    ...
  </member>
  <member name="Condition" type="inclusive" cost="10">
    <interface>
      ...
      <method name="id" return="const Id &"/>
      <method name="valid" return="bool"/>
      <method name="wait" return="void"/>
      <method name="signal" return="void"/>
      <method name="broadcast" return="void"/>
    </interface>
    ...
  </member>
</family>
\end{lstlisting}

One could easily see that the \textxml{Semaphore} member was the one choosen,
since it is the only one that implement the \textxml{p()} and \textxml{v()}
methods that were used by the application\footnote{The constructors required
  by the application would also be analysed by the \texttt{configurator}, but since
  in this case they would be irrelevant for the selection, we have ommited them.}.

Similarly, the selection of the member of the \textxml{Thread} family member
would be made based on the XML description, whose partly listing is:

\begin{lstlisting}[language=EPOSCFG,style=inlineprg]{}
<family name="Thread" type="abstraction" class="incremental">
  <interface>
    ...
    <method name="id" return="const Id &"/>
    <method name="valid" return="bool"/>
    <method name="state" return="volatile const State &"/>
    <method name="priority" return="const Priority &"/>
    <method name="priority" return="void">
      <parameter type="const Priority &" name="priority"/>
    </method>
    <method name="join" return="int"/>
    <method name="pass" return="void"/>
    <method name="suspend" return="void"/>
    <method name="resume" return="void"/>
    <method name="yield" return="int" qualifiers="class"/>
    <method name="exit" return="void" qualifiers="class">
      <parameter type="int" name="status" default="0"/>
    </method>
  </interface>
  <common>...</common>
  <member name="Exclusive_Thread" type="exclusive" cost="1">
    <interface>
      ...
      <method name="id" return="const Id &"/>
      <method name="valid" return="bool"/>
      <method name="exit" return="void" qualifiers="class">
        <parameter type="int" name="status" default="0"/>
      </method>
    </interface>
    ...
  </member>
  <member name="Cooperative_Thread" type="exclusive" cost="10">
    <super name="Exclusive_Thread"/>
    <interface>
      ...
      <method name="pass" return="void"/>
    </interface>
    ...
  </member>
  <member name="Concurrent_Thread" type="exclusive" cost="15">
    <super name="Cooperative_Thread"/>
    <interface>
      ...
      <method name="state" return="volatile const State &"/>
      <method name="join" return="int"/>
      <method name="suspend" return="void"/>
      <method name="resume" return="void"/>
      <method name="yield" return="int" qualifiers="class"/>
    </interface>
    ...
  </member>
  <member name="Priority_Thread" type="exclusive" cost="20">
    <super name="Concurrent_Thread"/>
    <interface>
      ...
      <method name="priority" return="const Priority &"/>
      <method name="priority" return="void">
        <parameter type="const Priority &" name="priority"/>
      </method>
    </interface>
    ...
  </member>
</family>
\end{lstlisting}

Note that this is an incremental family, and, as so, every member is a
specialization of the previous. Hence, any one of the members supports
the elements declared in its own interface, as well as the elements
inherited from its parents. Because of this, there are two members of the
family that would satisfy the requisits of the application:
\textxml{Concurrent_Thread} and \textxml{Priority_Thread}. In this case,
the \texttt{configurator} would select the one with the lowest cost
estimation, that is, the \textxml{Concurrent_Thread}\footnote{The constructors required
  by the application would also be analysed by the \texttt{configurator}, but since
  in this case they would be irrelevant for the selection, we have ommited them.}.

After this first iteration, the \texttt{configurator} would check the
dependency information for the selected families and members and, if
necessary, include any other required family. In this case,
both families members' implementations depends on the
\textxml{CPU} family, and so it would be also included in the configuration
and the member specific to the target machine processor (informed by the user)
would be selected (promoving portability). A new iteration would be started
to check the dependencies for the newly included families, an so on, until
no new family need to be included.


\section{Limitations}

The mechanism (configuration keys) used to bind the inflated interfaces to
the real implementation of one of their members  only allows the connection of
each inflated interface with just one member at a time.

If the above example was extended to use another kind of synchronization
in conjunction with the semaphores already used, the \texttt{configurator} would
correctly identify that two or more members would have to be selected to satisfy
the requirements. However, that would be impossible to accomplish, since it would only
be posible to bind one of them with the inflated interface of the \textxml{Synchronizer}
family at a time.

The only posible solution for this situation at this moment is to ask the application
programmer to write the calls to the synchronizers directly over the members' interfaces,
instead of using the generic family's interface, thus forcing the programmer to explicit
show his decisions about what kind of synchronizer he is using. If he does so,  the
\texttt{configurator} would understand that both members are necessary and their
implementations would be included in the system's configuration without the necessity for
any binding to the inflated interface.


\section{Supporting Tools}

At the present, we have prototype implementations of the
\texttt{analyzer} for applications written in \textsc{C++} and
\textsc{Java}. These tools are able to parse an input program and
produce a list of the system abstraction interfaces (inflated or
not) used by the program, identifying which methods have been
invoked and, in the case of \textsc{Java}, in which scope they have
been invoked.

This information serves as input for the \texttt{configurator}, which is
currently being developed. The \texttt{configurator} is indeed
implemented by two tools. The first one is responsible for executing the
algorithm that will select which members of each family will be included
in the customized version of the system. This algorithm consists in
reading the requirements found by the \texttt{analyzer} and compare them
with the interfaces of each member of the family as specified in the
repository.  Every time a new member is selected, its dependencies are
recursively verified, including in the configuration any members from
other families that are needed to satisfy them. The second part of the
\texttt{configurator} is a graphical tool that allows the user to browse
an automatically generated configuration, making manual adjustments, if
needed. Moreover, the user will have to enter some important information
not discovered automatically: the configuration of the target machine
(architecture, processor, memory, etc.) and the values of the traits of
each component.

At last, the configuration keys outputted by the \texttt{configurator}
are used by the \texttt{generator}, which is implemented as a wrapper
for the \emph{GNU Compiler Collection}, to compile the system and
generate a boottable image.


\section{Further work}

We are finishing the implementation of the \texttt{configurator} that
will be capable of automatically generating the configuration for a
customized version of \textsc{Epos}. Further works could refine the
specification and implementation of the system configuration model in
two aspects:

\begin{itemize}
\item Inclusion of behavioral specification in the component description
  model. This specification would cover dependencies like: some method
  of a component can only be invoked if the component is in determinate
  state. This kind of specification would have to be validated by some
  sort of formal mechanism, like a Prolog inference engine or a Petri
  network.

\item Evolution of the mechanism used to select members by performance.
  Today, this task is accomplished using the specification by the
  programmer of a cost estimate of each member on each family if the
  form of overhead. More elaborated mechanisms would include an
  automated way to measure real performance of each member during
  execution time.
\end{itemize}


\section{Conclusion}

In this article we have presented an alternative to achieve
automatic run-time system generation taking as base a collection of
software components developed according with the
Application-Oriented System Design methodology. The proposed
alternative consists of a novel component description language and a
set of configuration tools that are able to automatically select and
configure components to assembly an application-oriented run-time
support system.

The described configuration tools are in the final phase of development
and allow the exposition of the system libraries to application
programmers through a repository of reusable components described by
their inflated interfaces, which are automatically bound to a specific
realization at compile time. This is possible due to the component
specification model that contains all the information needed to generate
valid and optimized configurations for each application.

We have shown an example of the configuration process for a simple but
real application, and the limitations of the model regarding the selection
of more than one different realization for a component at the sime time.

This architecture makes possible the creation of optimized versions of the
operating system for the target applications, assuring that the performance
levels and resource usage optimization for embedded and parallel aplications
will be certainly better that those achieved with general-purpose operating
systems.

\bibliographystyle{ieee}
\bibliography{ieee,guto,se,os,network}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sbac2004"
%%% End:
