% Usefull notes -----------------------------------------------------------------------------
%
% Paper to check examples of Guto's notes system for each paragraph:
% https://svn.lisha.ufsc.br/papers/rejected/2012/wosida2012-autonomous_building-arliones/paper.tex
%
% ---------------------------------------------------------------------------------------

\documentclass{sig-alternate}

\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{color}
\usepackage[english]{babel} 
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[caption=false]{subfig}

% Command used to describe the contents of the paragraphs
\newcommand{\note}[1]{}

%Command used to insert figures
\newcommand{\fig}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

% Hyphenation  ------------------------------------------------------------------------------
\hyphenation{Thre-a-ds Pro-ofs}

\begin{document}

%
% --- Author Metadata here ---
\permission{Permission for classroom and personal use is granted, providing this notice appears on all copies.}
\conferenceinfo{LISHA 2013}{Florian칩polis, Brazil}
\crfee{}
\copyrtholder{by the Authors.}
\CopyrightYear{2013}
%\crdata{This work is based on an earlier work: System-Level Verification of Embedded Operating Systems Components, in Proceedings of the ${2}^{nd}$ Brazilian Symposium on Computing System Engineering. \copyright IEEE, 2012. http://dx.doi.org/10.1109/SBESC.2012.39}
% --- End of Author Metadata ---

% Paper Title  ------------------------------------------------------------------------------
\title{The EPOS Hypervisor Architecture Implementation and Verification}

% Authors Information ------------------------------------------------------------------------------
\numberofauthors{1}
\author{
\alignauthor
F치bio Resner\\
       \affaddr{Federal University of Santa Catarina (UFSC)}\\
       \affaddr{Software/Hardware Integration Lab (LISHA)}\\
       \affaddr{880400-900 - Florian칩polis - SC - Brazil}\\
       \email{fabio@lisha.ufsc.br}
}

\date{}
\maketitle

% Abstract ------------------------------------------------------------------------------
\begin{abstract}

\end{abstract}

%\category{D.2.4}{Program Verification}{Correctness proofs}
%\category{D.4.1}{Process Management}{Scheduling}
%\category{D.4.7}{Organi\-za\-tion and Design}{Real-time systems and embedded systems}

\terms{Hypervisor, Design, Verification}
\keywords{Formal Verification, Hypervisors} 

% Introduction ------------------------------------------------------------------------------
\section{Introduction} \label{intro}

\note{Contextualize hypervisors, why they were used in the past and why they are being used again}
A hypervisor is a software that provides virtualization. Platform virtualization refers to technologies that provide 
a layer of abstraction between computer systems and the operating systems that utilize them \cite{DBLP:journals/corr/abs-1110-4672}.
In the past, computational resources were scarse and had a high cost, so virtualization came in hand to help people share that resources.
While computer technology became cheaper, virtualization became obsolete and was forgot for some time. Nowadays, this technology
is back specially because of it's significant improve in security and other aspects: 
%Citation missed - Kenneth Hess & Amy Newman (2010): Practical Virtualization Solutions. Pearson Education, Boston.
"Platform vitualization promises significant benefits in security, efficiency, dependability and cost \cite{}."

\note{Explain the need of a trusted software base and introduce the need for formal verification}
But those benefits depend directly on the trust we have in the hypervisor that provides it. In our vision, the best way of providing trust is through 
%Include EPOS refferences
formal verification. In this paper we present HyPOS (Hypervisor EPOS) an type 1 hypervisor built from the Embedded Parallel Operating System (EPOS) \cite{}.

\note{Give the simple example of the HSM with the proof of the non interference memory addresses}
We will use as a case study in this paper the scenario of a Hardware Security Module (HSM) \cite{Attridge}, specifically, the ASI-HSM \cite{jean}, \cite{tulio}, \cite{dexter}.
We were abble to verify the non interference of memory address. This simple proof enabled us to guarantee that sensitive material (cryptographic keys) 
protected by the HSM were never revealed and never copied. This provided us with the ground need to prove the unicity of the cryptographic key.

\note{Explain why the above paragraph is important in the context of the HSM}
%Search for refferences to PKI
Unicity and non exposal of the key is extremely important. In a PKI \cite{}, if a Certificate Authority's (CA) Private Key (PK) in any level of the infrastructure gets revealed, the whole certificate 
tree below it needs to be invalidated. You can't keep track of which certificates were issued by the original key or malicious issued by the copies. Having sure that the key was only
used incorrectly through any other way, enables us to use auditoring mechanism of the HSM itself to check and remediate the consequences. 

\note{Say that the example above is going to be used as a case study in the paper to examplify implementation/verification}
As cited above, the ASI-HSM and the non interference of memory spaces will be shown in \cite{eval}.
 
\note{Tell the contribution and the objectives of the project}
This project is a part of a greater one, which has the objective of building a Safe Code Execution Environment. This project outputs the trusted base system in which
is going to be studied and built the job left. Figure \ref{fig:arqmkhsm} represents the architecture. It has too a direct application in the context of the HSM, which will be better 
explored in section \ref{eval}. 

\fig{.265}{arqmkhsm}{The Safe Code Execution architecture.}

\note{Higly dissert about the next sections}
In Section \ref{design}, we show the parts of  EPOS that needed to be changed in order to make the formal verification as simple as possible. We based our work on previosly
efforts on kernel design for verification \cite{Klein:2009:SFV:1629575.1629596}, \cite{DBLP:journals/corr/abs-1110-4672}. In Section \ref{verification} we show the techniques
used in the verification steps \cite{syslvlvereos}. Section \ref{eval} is the Case Study. Section \ref{sota} describes in a high level the related works, and finally Section \ref{concl} 
has the conclusions. 

% Design for Verification ------------------------------------------------------------------------------
\section{Design for Verification} \label{design} 
\note{Little introduction about the section, saying that there will be a high level explanation of the design, verification, tools and techniques used}
Some parts of the hypervisor can be very difficult to verify if they were left exactly as they are. Previous efforts \cite{Klein:2009:SFV:1629575.1629596}, besides working on a microkernel, gave us a knowledge base of which components and issues were hard to deal while thinking about formal verification and they were taken in consideration in the desining phase.친

% Based on seL4 paper
\subsection{Global variables and side effects}
\note{Global variables and side effects}
The utilization of global variables for different purposes can led to many side effects that would make verification harder than necessary. The verification of globals start to get hard specially when invariants are temporarily violated. An example would be the addition of a node on a double linked list, which temporarily violate the invariants that guarantees the list is well formed. We threat those issues by limiting preemption points.

\subsection{Kernel memory management}
\note{Kernel memory management}
Our memory management system is build outside the kernel, lefting to authorized user level applications the responsability for the correct use of the memory. It does not only turns the 
kernel size smaller but it facilitates the formal verification. The only thing we need to prove is that the authorization mechanism works correctly, not the user level policy for memory allocation. 

\subsection{Concurrency and non-determinism}
\note{Concurrency and non-determinism}
Concurrency is the parallel execution of computation. Proofs about concurrent programs are much harder than proofs about sequential programs. Parallelism can be in two ways:
\begin{enumerate}
\item Real parallel computation (in the case of multicore processors)
\item Parallel computation simulated by an abstraction (Threads)
\end{enumerate}

There are tecniques to deal with multicore processors but they are out of the scope of this paper. Here we are going to deal with parallelism in uniprocessors.

\subsubsection*{Yelding}
\note{Yelding}
The complexity of dealing with Yelding was avoided by using a event-based kernel execution model, with a single kernel stack.

\subsubsection*{I/O}
\note{I/O}
I/O complexity is avoided leaving device drivers to be used on protected user mode components. 

\subsubsection*{Conclusion}
\note{Conclusion}
In this subsection we were abble to check some high level design choices that we made in order to facilitate the formal verification. The changes have some impact in the performance
of the hypervisor but we took care so that the overhead didn't become greater than acceptable for commom use. We have also enlightened some specific concepts that we used and
the solutions that we took in order to solve than. Next section will deal with the theory and tools used to formalize and verify those concepts. 

% HyPOS Verification --------------------------------------------------------------------------------
\section{HyPOS Verification} \label{verification} 
\note{Introduction about the section}
This section introduces the concepts and tools used while doing formal verification. It will show contracts implemented directly in C++, the problems ocasioned, the concept of 
the scenario adapter and how is it done and the isolation of components for verification. To our knowledge this approach is completely different from others that are going to be
described in Section \ref{sota} and related projects in the area. 
 
% Based on Mateus's paper - https://svn.lisha.ufsc.br/papers/accepted/2013/osr2013-verification-mateus/paper.tex
\note{Contracts in C++ directly in the code, advantages}
Having contracts specified directly in the C++ code facilitate our job. We didn't needed to learn a new language or tool. 
 
\note{Cosiderations about directly injection anotations in the code (runtime overhead, etc)}
In contrast, specifing contracts directly in the source code caused an overhead at runtime and increased the generated code. The overhead didn't  prevented the 
final system for normal use. It has a delay of 5\% and 8\% respectively to seL4 and MinVisor in average in a benchmark that we performed comparing our approach.
The benchmark was carefully designed not to evaluate the specific components of each system (which would be unfeasible). Only the hole process was considered.

\note{Scenario Adapter used in the approach}
\note{Advantage of using the scenario adapater and how is it done}
\note{Isolation of the components for verification}
\note{Conclusion}

% Case Study ------------------------------------------------------------------------------
\section{Case study} \label{eval}
\note{Intro - Why the non interference of memory addresses}
As briefly introduced, the non interference of memory addresses is a key concept for us to provide unicity. 
Proving unicity helps us in the sense that we know the key is unique and so we can keep track of it. 
Auditoring methods could than be used to amortize the impact instead of having to destroy a whole tree of issued certificates.
 
\note{Contract Specification - with example}
\note{C++ assertions - pre and pos coditions - with examples}
\note{CBMC confirming the contracts and performance example}
\note{Conclusion}

% Related Works ------------------------------------------------------------------------------
\section{Related Works} \label{sota}
\subsection*{seL4}
\note{seL4}
The seL4 \cite{Klein:2009:SFV:1629575.1629596} is a project with focus on design, implement and verify a secure micro-kernel. Some of the design issues provided by
seL4 were shown and used as base for developing our secure hypervisor. The verification of this microkernel was done in three steps which are illustrated in 
Figure \ref{fig:Camadassel4} \cite{Klein:2009:SFV:1629575.1629596}. 

\fig{.4}{Camadassel4}{The seL4 Project Process.}

The first step is to build an abstract specification. This abstract specification describes what the system do instead of how is it done. In the second step, 
a prototype of the system is build usign the haskell programming language. Two models are automatically generated from both. A proof called correlation is applyed to 
prove that the haskell prototype follows the abstract specification. In the third step a C version is developed. Again the model is automatically generated and correlation 
between the haskell prototype and the C code is proved. This way, it's proved that the final C code works just like the abstract specification. The theorem prover used in 
the project is Isabelle/HOL. SeL4 have assumptions like the correctness of the linker and the compiler. 

\subsection*{MinVisor}
\note{MinVisor - hypervisor verification}
MinVisor \cite{DBLP:journals/corr/abs-1110-4672}, is a project with a similar objective regarding seL4 but alternative approach. MinVisor wants to verify a hypervisor rather than a microkernel.
They also have some design approaches to facilitate verification. The two principal aspects that differs MinVisor from seL4 are the way MinVisor protects itself in memory
and the fact that they do the verification directly on the binary code. The direct verification on the binary, provides some advantages from MinVisor over seL4. Among them 
is the fact that MinVisor didn't need to assume the correct functionality of the compiler. The complexity of performing the formal verification of a compiler is very hard.

%Citation needed for AMD-V Nested Paging whitePaper
The mechanism used by MinVisor to hide itself in the memory is called NestedPages \cite{}. First it loads the MinVisor image at memory location 0x700C through 
PXE (Pre eXecution Environment) provided by the BIOS. In the memory, it relocates itself to the highest memory address available and marks that location as 
"not-present". It than start the normal boot sequence, searching the operating system in the hard disc an loading it in memory. The Operating System knows nothing
about the existence of Minvisor.  

Nested Pages comes in when the operating system uses paging. The normal paging process of the operating system runs and than the physical address generated by
the paging is used as a index to a new paging system performed by the processor. This paging system almost always does a directly translation except for some addresses.
Among those adresses is the address where MinVisor is loaded in memory. The page is setted as "not present". When the guest OS tries to access a "not present" page, 
the processor generates a exeption and redirects control to the hypervisor with information about what happened.

Besides Minvisor seems to have some strong points when comparing do seL4, the project is still on a initial phase. The hypervisor is not fully featured and only Nested Pages
e some other few mechanisms are formally verified. SeL4 in it's way is a functional microkernel.

\note{osr2013-verification-mateus}

% Conclusions ------------------------------------------------------------------------------
\section{Conclusion} \label{concl}
We saw in the this work, details on the design, implementation and verification of HyPOS. The non interference of memory addresses has been shown as it's practical
use in the context of the HSM has been exemplified. The objectives of the project, that were to construct this secure base system, verify the non interference of 
memory addresses and apply it in the practical context of the HSM were succesfully obtained. In addition a benchmark test comparing our performance to other 
similar projects were provided and we saw that the overhead included while applying our aproach was not prohibitive. We hope to present new results as soon as 
possible continuing from this actual work and that the comunnity could be able to benefit from the tecniques and examples presented in this paper.

\bibliographystyle{abbrv}
\bibliography{referencias}

\end{document}