% -----------------------------------------------------------------------------
\section{Trabalhos relacionados}
\label{sec:related_work}
% Nosso trabalho aborda a questão de como prover acesso a dispositivos de hardware
% ao Java e como prover este acesso de uma forma bem estruturada levando em 
% consideração todos os requisitos do cenário de sistemas embarcados.
%
A linguagem de programação Java é desprovida do conceito de \emph{ponteiro}, 
presente em linguagens como C e C++. 
O endereço das \emph{variáveis de referência}, utilizadas para acessar objetos Java,
é conhecido apenas pela JVM, a qual trata de todos os acessos à
memória. Como a maioria dos dispositivos de hardware são mapeados em endereços de
memória, acessá-los diretamente é um problema para a linguagem Java. 
FFI é a abordagem
utilizada por Java para superar esta limitação uma vez que ela permite ao Java
utilizar construções, como ponteiros C/C++, para acessar diretamente dispositivos
de hardware.
FFIs também tem sido utilizadas por plataformas Java na reutilização de código
escrito em outras linguagens de programação como C e C++ e para embarcar JVMs em 
aplicações nativas permitindo as mesmas acessar funcionalidades 
Java \cite{Liang:1999}.
%(\cite{Liang:1999}, \cite{1288968}).

\emph{Java Native Interface} (JNI) é a principal FFI Java, a qual é utilizada na
plataforma \emph{Java Standard Edition} \cite{Liang:1999}. 
Na JNI, a interface entre código nativo e Java é realizada durante o tempo de 
execução do programa. Isto significa que, durante a execução de um programa, 
a JVM procura e carrega a implementação dos métodos marcados como nativos 
(métodos que possuem a palavra reservada \emph{native} em suas assinaturas).
Usualmente a implementação dos métodos nativos é armazenada em uma biblioteca 
ligada dinamicamente.
Este mecanismo de busca e carga de métodos aumenta a necessidade de memória em
tempo de execução e o tamanho da JVM. Por esta razão eles são evitados em 
sistemas embarcados.

% NOTA: Não estou certo destas limitações da KNI, apesar de estarem na 
% especificação da mesma.
A plataforma \emph{Java Micro Edition} (JME) utiliza uma FFI ``leve'',
chamada de \emph{K Native Interface} (KNI) \cite{_k_2002}. 
A KNI não carrega métodos nativos dinamicamente na JVM, evitando o sobrecusto 
de memória da JNI. 
Na KNI a interface entre Java e código nativo é realizada estaticamente, 
durante o tempo de compilação. 
Entretanto decisões de projeto da KNI impõem algumas limitações. 
A KNI proíbe a criação de objetos Java (exceto de strings) a partir do código 
nativo. 
% É proibida também a chamada de métodos Java, a partir do código nativo. 
Além disto, na KNI os únicos métodos nativos que podem ser invocados são aqueles 
pré-compilados na JVM. 
Não há uma Interface de Programação de Aplicações 
(API - Application Programming Interface) em nível Java para invocar outros 
métodos nativos. % cuidado com esta afirmação. Frase original: There is no Java-level API to invoke others native methods.
Como consequência, é difícil de criar novos controladores de dispositivos de 
hardware utilizando-se a KNI.

% NOTA: Os último argumento, de chamar Java a partir do C... é fraco
A FFI da KESO, utilizada neste trabalho, foca em sistemas embarcados. 
Assim como a KNI, a FFI da KESO não realiza carga dinâmica de métodos nativos.
Entretanto, diferentemente da KNI, a FFI da KESO provê aos programadores uma 
API em nível Java para criação de novas interfaces com código nativo. 
Também não exite problema do código nativo chamar código Java, uma vez que 
KESO e a FFI da KESO geram código C.

O tarefa de escrita de adaptadores para código nativo pode ser facilitada de
duas maneiras, por APIs de alto nível e por ferramentas geradoras. As APIs de
alto nível fornecem métodos específicos para auxiliar na criação desses adaptadores,
enquanto as ferramentas geradoras podem gerar parte de adaptadores ou adaptadores
completos a partir de análise de código nativo ou a partir de uma especificação
em mais alto nível.
SWIG e a biblioteca de função estrangeira de Python \emph{ctypeslib} são exemplos
de ferramentas que geram adaptadores a partir de arquivos \emph{headers} C/C++
como entrada. O primeiro suporta diversas linguagens como saída, como por exemplo
Python, D e Java. O segundo foca em programas Python 
\cite{swig-site},\cite{ctypeslib-site}.
Ravit et al. apresenta uma ferramenta que tem como objetivo prover funcionalidades
da linguagem de mais alto nível (tuplas, por exemplo) para serem utilizadas no 
código dos adaptadores. A ferramenta proposta por Ravit et al. gera adaptadores
Python a partir de código escrito em C e descrições de interface, as quais 
contêm, dentre outras, informações sobre funções e seus respectivos parâmetros
\cite{Ravitch:2009:AGL:1542476.1542516}.
Outras soluções, como a linguagem \emph{Jeannie}, misturam código C e Java em 
um único programa a partir do qual geram adaptadores JNI 
automaticamente \cite{1297030}.
A FFI da KESO, utilizada neste trabalho, provê uma API baseada em aspectos para
ajudar na criação de adaptadores. É possível especificar quais pontos do programa
Java serão afetados pela criação dos adaptadores, assim como qual código deve
ser gerado para cada ponto do programa Java a ser afetado.

% The binding code can be checked for correctness and bug detection. Tools such 
% as J-BEAM and Ilea perform bug checking based on the source code, using static
% analysis techniques\cite{jbeam:2008}, \cite{Ilea:2007}.
% Lee et al. deal with bug detection dynamically, when the FFI code is been 
% used \cite{Lee:2010:JSD:1809028.1806601}.
% Their tool Jinn synthesizes dynamic bug detectors for FFIs from Finite State 
% Machines whose encode FFI constrains that should be tested. The FFI targeted 
% for the Java language is the JNI which contains hundreds os API calls. 
% Although not aborted by this paper, similar bug detectors can be adapted to 
% check bindings generated using the KESO FFI.


% -----------------------------------------------------------------------------

