% ------------------------------------------------------------------------------
\section{Related Works} \label{sota}
% NOTA: Esta seção segue a abordagem: SOTA + Fundamentals juntos...
% Embora C1 seja mais fundamentals e C2 e C3 sejam mais SOTA / Related work. acho
% Pois C1 foca mais em técnicas e C2 e C3 já são abordagens e uso destas técnicas
% Que é o meu caso.
% SOTA == Related Work
%
% NOTA: Então, ser mais neutro em C1 e mais enfático em C2 e C3 (C3 vai ficar pra próxima...).
%
% = Related Work Two categories of related work:
% C1: formal verification techniques for System Level Design, and
% C2: formal verification of embedded systems components.
% A third category is
% C3: formal verification based on contracts.

% Aqui devo focar mais em model checking / property checking.
% Acho que não vou falar de equivalence checking...
%
% = C1: Formal verification techniques for System Level Design: Model Checking
% and Equivalence Checking for SystemC and SpecC, interactive theorem
% proofing, etc.
% Falar que C++ também é uma linguagem usada em SLD, principalmente por causa
% de HLS. Definir brevemente HLS e citar referencias de trabalhos de
% SLD e HLS (e.g. Gerstlauer:2009) e de
% HLS e verificação.
% This section overviews the main languages and techniques used for formal
% verification of System-Level descriptions, and
% works related to formal verification of embedded and operating systems
% component's.

In the last few years, advances in Electronic Design Automation (EDA)
techniques and tools are allowing
hardware synthesis from high-level behavioral models.
This process, known as High-level Synthesis (HLS), allows designers to
describe hardware components using
programming languages such as C++ and Java, and
System-Level Description Languages (SLDLs) such as SystemC and SpecC
\cite{Gerstlauer:2009}.

As HLS allows for hardware components to be described using programming languages,
descriptions can now be verified using tools based on Software Model Checking.
In Software Model Checking, a program is translated into a logical formula.
Properties about the target program can be described in such logics,
directly in the programming language (e.g. by using \emph{assert} expressions),
or even automatically generated by analyzing constructions of the programming
language, such as arrays and pointers.
Then, the logical formula representing the program is combined with given properties,
generating \emph{Verification Conditions} (VCCs) that are passed to a
satisfiability (SAT) solver or to a theorem prover.
Finally, it is determined if all properties of the program are true or not.
In the latter case, a counter-example is generated, demonstrating the execution
path where the property is false.
% Predicate Abstraction
% Aims to reduce the state space by mapping an infinite state space program to an
% abstract program of Boolean type while preserving the behaviors and control
% constructs of the original.
Are examples of tools that use software model checking concepts for checking C/C++
programs:
Blast (C only) \cite{Henzinger:Blast},
CBMC (used in this work) \cite{Kroehning:CBMC},
LLBMC \cite{Sinz:LLBMC},
and SATABS \cite{Kroening:SATABS}.

% * Interactive theorem proving
% acho que vou deixar esta parte quando falar do L4.verified.
% NOTA estratégia:
% Primeiro escrever sobre SystemC e SpecC focando em SW model checking
% Depois voltar e ver se eu ``encherto'' interactive theorem proving na parada.
% Tem outras coisas também, como static analysis, equivalence checking, etc.
%
% Schirmer:2006:PHD /  Parser Norrish (Tuch:2007 / site do parser)
%     C => HOL (Simpl)
% 
% Greenaway:2012
%     C => HOL (high-levels)

Model checking and other verification approaches also have been applied to
SLDLs such as SystemC and Spec.
One of the approaches transforms SLDLs in C++ and then uses software
model checking tools.
That is the case of the KRATOS model checker \cite{Cimatti:2011}, and the Scoot
tool \cite{Blanc:2008}, both targeting SystemC descriptions.
% Both target SystemC description, and the latter is can be used together with
% CBMC.
A similar strategy is used by Clarke for verifying SpecC descriptions
\cite{Clarke:2007}.
%
% 
Besides C++, other languages are used as intermediate to model checking SLDLs
descriptions.
For example, the Afra tool \cite{Razavi:2011}
translates SystemC descriptions to the
Rebeca modeling language
% CITE.rebeca
that can be latter checked by the Modere
model checker which uses
Computation Tree Logic (CTL) and
Linear Temporal Logic (LTL)
% LTL and CTL
to specify properties target of verification.
%
% Cimatti:2010 - Limitations
%
% * Assumes SystemC does not creates threads, channels, and module instances dynamically
% * Pinapa SystemC front end: does not support SystemC TLM models, partial support for function Pointers
% * Translator: does not support STL (templates at all?), structs, pointers, arrays, dynamic creation of objects
% * SyCMC and ESST: do not support structs, pointers, arrays, dynamic creation of objects, and recursive function

Using the ideas aforementioned, Fujita et al. present the verification of
synchronization properties for the Point-to-Point Protocol (PPP)
\cite{Fujita:2008}.
In Fujita's work, the SpecC description of PPP is translated into
Boolean SpecC and then subjected to model checking techniques.
% 
% = C2: Verification of embedded systems components: L4.verified project,
% Microsoft’s Hyper-V hypervisor, and Gotsman:2011 paper
% (verification of linux-like kernels).
%
%
% L4.verified
On the operating system realm, Klein et al. present the results of the
L4.Verified project, which accomplished the verification of
the seL4 micro-kernel used in embedded systems \cite{Klein:2009}.
The strategy used by the L4.Verified project was to translate the C
implementation of
into the Simpl language
\cite{Schirmer:2006:PHD}
implemented
using High-Order Logic (HOL) on the Isabelle theorem prover
\cite{Nipkow:2002}. % CITE.isabelle.
Then, using Isabelle, invariants about the representation of the operating
system components were proved.
The L4.Verified project also had proved, using refinement, that such Simpl
description of components were equivalent to higher level descriptions, also
described using HOL.
% Our proposal in this paper aims to formally verify functional correctness and
% safety properties of the C++ 
% No L4 a abordagem utilizada é verificar corretude funcional segundo invariantes
% escritas em um modelo de mais alto nível, escrito em HOL.
% No L4 existe a necessidade porém de provar que a implementação em C refina a
% implementação de mais alto nível em HOL. Para isso eles converteram C em HOL
% e usaram refinamento... Usaram também um passo intermediário traduzinfo Haskel
% em HOL...
% 
% Microsoft’s Hyper-V hypervisor
Similarly to the L4.Verified project, Cohen presents the verification
of functional correctness of Microsoft’s Hyper-V virtualization platform
% CITE.hyperv
and SYSGO’s embedded real-time operating system PikeOS
% CITE.pikeos.
\cite{Cohen:2010}.
Cohen's approach proposes a logics to express Locally Checked Invariants (LCI).
LCI are used to assign to a component target of verification a predicate over
pairs of states expected to hold that are then checked using the VCC theorem
prover \cite{Microsoft:VCC}.
%  CITE.vcc.
% TODO ver se posso chamar o VCC de theorem prover. Senão chamar simplesmente de
% verifier.
%
Gotstman et al. propose the modular verification of preemptive kernels, running in a
multiprocessor system \cite{Gotsman:2011}.
Gotsman's approach propose two proof systems, one called high-level, in which all
processes have their own virtual CPU, and other called low-level in which the
number of processors is fixed.
The high-level proof system is then used to reason about the schedulable code,
and the lower-level proof to reason about the scheduling itself, separating the
scheduler from the rest of the kernel.
Although the proposal is to verify mainstreams operating systems such as Linux,
FreeBSD, and XNU, all theory presented in the paper is developed around an
assembly language of a fictional machine.
% * It might be feasible to extend the presented ideas for a real machine and to
%  formally map such assembly to a high-level language


% = C3: formal verification based on contracts.
% NOTA: procurando na ACM DL por "Design by Contract" acha-se um monte de coisa,
% inclusive de SO  (tem um do Tiny OS) e de verificação formal.
% Creio que varios destes são trabalhos relacionados importantes de mencionar.
% Fica para a próxima.:)

% Discussion
At this work, we propose the verification of functional correctness properties
and safety properties
of components described at System-Level.
Differently from \cite{Klein:2009} and \cite{Cohen:2010}, the language used to
express the component's contract is the same used for
the component's implementation, that is C++.
Therefore, there is no need to proof refinement from higher levels of the
specification.
Also, because we choose to use a programming language to specify contracts,
no special knowledge on formal logics is required from the designers
in order to express the component's expected behavior.

% ------------------------------------------------------------------------------
