/* THIS FILE IS AUTO GENERATED BY KESO! DON'T EDIT */

#ifndef _GLOBAL_H_
#define _GLOBAL_H_ 1

#define NO_WRITE 1
#include <keso_types.h>
#include <keso_support.h>
#include "os.h"

/* adjust this value to your needs! */
#define KESO_TICKS_MICRO 1995
typedef unsigned short class_id_t;
typedef unsigned long  array_size_t;

/* max. object size is 64 KByte */
typedef unsigned short obj_size_t;

/* it is important for the IRR GC that
 * bit 0 of the first word of the object
 * header is set to 1, in order to distinguish
 * it from object references. The irr-alloc sets
 * bit 0 of gcinfo to 1 on object allocation. If
 * you change the object header, be sure not to break
 * this. Also the endianess is of importance - gcinfo
 * must be the least sigificant byte of the header's
 * first word. The following header is for little
 * endian architectures (just reverse the element order
 * for big endian architectures).
 */
#define OBJECT_HEADER \
	unsigned char gcinfo;\
	unsigned char bitfld1;\
	class_id_t class_id;\

typedef struct {
OBJECT_HEADER
} object_t;

#define CLS_ROFF(_cls_) CLASS(_cls_).roff
typedef struct {
	obj_size_t     size;
/* class info for bidirectional object layout */
	unsigned char roff;
} class_t;

#define ARRAY_HEADER \
OBJECT_HEADER\
	array_size_t size;

typedef struct {
ARRAY_HEADER
} array_t;
#define CLASS(_id_) class_store[((_id_)-1)]
extern class_t	class_store[];
/* KESO_DUP_OBJ_MAX is the maximum of recursion depth
 * for object copy in portal calls */
#ifndef KESO_DUP_OBJ_MAX
#define KESO_DUP_OBJ_MAX 10
#endif
#define KESO_OBJ_PTR(_roff_, _mem_) (object_t*)((object_t**)(_mem_)+(_roff_))
#define KESO_TOP_PTR(_roff_, _obj_) (jbyte*)((object_t**)(_obj_)-(_roff_))
#define KESO_REF_PTR(_roff_, _obj_) (object_t**)((object_t**)(_obj_)-(_roff_))

/* static accesses */
/* test/DebugOut buf rw obj0_0 */
/* java/lang/String NULL rw keso_allocArray(reference,0) */

/* field accesses */
/* java/lang/StringBuffer data rw  */
/* java/lang/String value rw  */
/* java/lang/StringBuffer length rw  */

#define KESO_PENDING_EXCEPTION ((object_t*)0)

#define likely(x) __builtin_expect((x),1)
#define unlikely(x) __builtin_expect((x),0)
#define NORETURN __attribute__((noreturn))
#define ALIGN4 __attribute__ ((aligned (4)))
#define HEAP_SECTION __attribute__ ((section(".objheap")))
/* PSPR section is TriCore architecture only -- ignore. */
#define TRICORE_PSPR_SECTION
#define INLINE_ARRAY_CHK 1

/* BEGIN null_chk.c */

#ifdef KESO_OMIT_SAFECHECKS
#  define KESO_ASSERT_NULLPOINTER(_obj,_method_,_bcPos_)
#  define KESO_CHECK_NULLPOINTER(_obj_,_method_,_bcPos_)
#else
#  define KESO_ASSERT_NULLPOINTER(_obj,_method_,_bcPos_)
#  if defined(KESO_PRODUCTION) || defined(NO_WRITE)
#    define KESO_CHECK_NULLPOINTER(_obj_,_method_,_bcPos_) if (unlikely(((object_t*)0)==(_obj_))) keso_throw_error();
#  else
#    define KESO_CHECK_NULLPOINTER(_obj_,_method_,_bcPos_) if (unlikely(((object_t*)0)==(_obj_))) keso_throw_nullpointer(_method_,_bcPos_);
void 	keso_throw_nullpointer(const char* method, int bcpos) NORETURN ;
#  endif
#endif


/* END null_chk.c */

/* BEGIN array_chk.c */
#ifdef KESO_OMIT_SAFECHECKS
#  define KESO_CHECK_ARRAY(_obj_,_index_,_method_,_bcPos_)  
#  define KESO_CHECK_ARR_REF(_obj_,_index_,_method_,_bcPos_)
#  define KESO_CHK_BOUNDS(_clazz_, _mem_, _a_size_, _method_, _bcPos_)
#  define KESO_CHK_CBOUNDS(_m_size_, _a_size_, _method_, _bcPos_)
#else 
#  ifdef INLINE_ARRAY_CHK
#    define KESO_CHECK_ARRAY(_obj_,_index_,_method_,_bcPos_)\
	if (unlikely(((array_t*)_obj_)->size<=(array_size_t)(_index_))) keso_throw_index_out_of_bounds(_method_,_bcPos_)
#    define KESO_CHECK_ARR_REF(_obj_,_index_,_method_,_bcPos_) keso_check_array((object_t*)_obj_,_index_,_method_,_bcPos_)
#  else
#    define KESO_CHECK_ARRAY(_obj_,_index_,_method_,_bcPos_) keso_check_array((object_t*)_obj_,_index_,_method_,_bcPos_) 
#    define KESO_CHECK_ARR_REF(_obj_,_index_,_method_,_bcPos_) keso_check_array((object_t*)_obj_,_index_,_method_,_bcPos_)
#  endif
#  define KESO_CHK_BOUNDS(_clazz_, _mem_, _a_size_, _method_, _bcPos_)\
	if (unlikely((array_size_t)(_a_size_)>=((_clazz_*)_mem_)->_size)) keso_throw_index_out_of_bounds(_method_,_bcPos_) 
#  define KESO_CHK_CBOUNDS(_m_size_, _a_size_, _method_, _bcPos_)\
	if (unlikely((array_size_t)(_a_size_)>=(array_size_t)(_m_size_))) keso_throw_index_out_of_bounds(_method_,_bcPos_) 
#endif

#ifndef NO_WRITE
void 	keso_throw_index_out_of_bounds(const char* method, int bcpos) NORETURN ; 
#else 
#define keso_throw_index_out_of_bounds(_m_,_pos_) keso_throw_error()
#endif



/* END array_chk.c */

/* BEGIN error_chk.c */

#ifdef NO_WRITE
#  define KESO_THROW(_obj_,_method_,_bcPos_) keso_throw_error()
#  define KESO_THROW_ERROR(_msg_) keso_throw_error()
void 	keso_throw_error() NORETURN ;
#else
#  define KESO_THROW(_obj_,_method_,_bcPos_) keso_throw_exception(_obj_,_method_,_bcPos_)
#  define KESO_THROW_ERROR(_msg_) keso_throw_error(_msg_)
void 	keso_throw_exception(object_t* obj, const char* method, int bcpos);
void* 	keso_throw_error(const char *msg);
#endif


#ifdef DEBUG
#  ifdef NO_WRITE
#    define KESO_ASSERT(__v__) if (!(__v__)) keso_throw_error()
#  else 
#    define KESO_ASSERT(__v__) if (!(__v__)) keso_fatal_error(__FILE__,__LINE__)
void keso_fatal_error(const char* msg, int line) NORETURN ;
#  endif
#else
#  define KESO_ASSERT(__v__)
#endif

jint  	keso_throw_method_not_implemented(const char* method, int bcpos); 

/* END error_chk.c */
#define KESO_LOCK(_obj_)
#define KESO_UNLOCK(_obj_)

#define keso_isObjectArrayClass(_class_id_) (0)
#define keso_isArrayClass(_class_id_) (1<(_class_id_)&&(_class_id_)<3)
#define KESO_HAS_ARRAYS 1

/* not available #define KESO_MEMORYOBJECT_AVAILABLE */
#define keso_isMemoryClass(_class_id_) (0)
#define KESO_MEMORY_ADDR(_obj_) (0)
#define KESO_MEMORY_SIZE(_obj_) (0)

typedef struct keso_stack_s {
	int domain_id;
	object_t** llrefs;
	struct keso_stack_s* next;
} keso_stack_t;

#define KESO_EOLL ((object_t*) -1) /* end of linked list */
#define keso_isStackRef(_ref_) ((unsigned int)(_ref_)&0x1)
#define keso_unpackStackRef(_ref_) (object_t**)((unsigned int)(_ref_)-1)

/* BEGIN heap/gc-common-llrefs.c */

extern object_t** unknown_task; 
typedef void (*callback_fkt_t)(object_t*);
#define KESO_STACK_WALK(_stack_,_callback_)  keso_gc_walk_stack((_stack_)->llrefs,_callback_)
void keso_gc_walk_stack(object_t** stack, callback_fkt_t callback);


/* END heap/gc-common-llrefs.c */

/* static fields */
#define KESO_NUM_STATIC_REFS 3
#define SC3_TASK_C3F5_INVALID_TASK static_ref[2]
#define SC13_DEBUGOUT_C13F1_BUF static_ref[1]
#define SC12_STRING_C12F2_NULL static_ref[0]

extern  __const__ code_t dispatch_table[];
#ifndef KESO_NEED_FINALIZE
#define KESO_INVOKE_FINALIZE(_self_)(_self_)
#endif
#define C1_OBJECT_RANGE 14
#define CHAR_ARRAY_RANGE 2
#define C3_TASK_RANGE 4
#define C4_DMECAPP_RANGE 4
#define C5_PICTUREMOTIONESTIMATOR_RANGE 5
#define C6_STRINGBUFFER_RANGE 6
#define C7_NATIVETESTSUPPORT_RANGE 7
#define C8_MATH_RANGE 8
#define C9_THROWABLE_RANGE 11
#define C10_RUNTIMEEXCEPTION_RANGE 11
#define C11_STRINGINDEXOUTOFBOUNDSEXCEPTION_RANGE 11
#define C12_STRING_RANGE 12
#define C13_DEBUGOUT_RANGE 13
#define C30_PICTURE_RANGE 30
#define C31_PICTUREMOTIONCOUNTERPART_RANGE 31
#define KESO_CLASSSTORE_SIZE 13
#define ASSERTCLASSID(_id_) KESO_ASSERT(0<(_id_) && (_id_)<31)
#define ASSERTOBJ(_obj_)
#include "c12_String.h"
#include "char_array.h"
extern c12_String_t str2;
extern c12_String_t str1;
extern c12_String_t str0;

/* translation callbacks */
void 	keso_check_array(object_t* arr, jint index, const char* msg, jint bcPos);
extern char keso_epos_d_dom1_heap[1024];
#define KESO_GCMODE_LAZY 1
#define KESO_SEND_GCRUN_EVENTS() 
#define KESO_GC_DEFER_TASK() 
#include "c4_DmecApp.h"
#define KESO_TASKCLASSTYPE c3_Task_t
#define KESO_TASKCLASSID C3_TASK_ID
extern keso_stack_t* keso_stack_index[];


/* Task management */

#include "c3_Task.h"
#include "c4_DmecApp.h"
extern c4_DmecApp_t HEAP_SECTION keso_epos_d_dom1_t_task1_obj;

#define KESO_MAX_TASK 1
extern c3_Task_t* keso_task_index[];
#define KESO_CURRENT_TASK keso_curr_task
#define KESO_SET_CURRENT_TASK(_x_) keso_curr_task=(_x_)
extern KESO_TASKCLASSTYPE *keso_curr_task;
KESO_TASKCLASSTYPE *keso_curr_task_fkt();


#endif
