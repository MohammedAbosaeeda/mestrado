%\documentclass[preprint,10pt]{sigplanconf}
\documentclass[letterpaper]{acm_proc_article-sp}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage[latin1]{inputenc}	% for Latin languages
\usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support
\usepackage{graphicx}
%\usepackage{multirow}
%\usepackage{subfig}
\usepackage{color}
\definecolor{Red}{rgb}{.9,0,0}

\include{utils} %new commands 


\begin{document}

\title{Implementing OS Components in Hardware using AOP}


% \author{Tiago R. M�ck\inst{1},
% Michael Gernoth\inst{2},
% Wolfgang Schr�der-Preikschat\inst{2},
% Ant�nio A. Fr�hlich\inst{1}}
% 
% \address{Software/Hardware Integration Lab \\
%   Federal University of Santa Catarina (UFSC)\\
%   Florian�polis, Brazil
%   \nextinstitute
%   Friedrich-Alexander University Erlangen-Nuremberg\\
%   Department of Computer Science 4\\
%   Erlangen, Germany
%   \email{\{tiago,guto\}@lisha.ufsc.br,\{gernoth,wosch\}@cs.fau.de} 
% }

\numberofauthors{2}
\author{
  \alignauthor Tiago Rog\'{e}rio M\"{u}ck and Ant\^{o}nio Augusto Fr\"{o}hlich \\
  \affaddr{Software/Hardware Integration Lab}\\
  \affaddr{Federal University of Santa Catarina}\\
  \affaddr{Florian\'{o}polis, Brazil}\\
  \email{\{tiago,guto\}@lisha.ufsc.br}\\
  \alignauthor Michael Gernoth and Wolfgang Schr\"{o}der-Preikschat \\
  \affaddr{Department of Computer Science 4}\\
  \affaddr{Friedrich-Alexander University Erlangen-Nuremberg}\\
  \affaddr{Erlangen, Germany}\\
  \email{\{gernoth,wosch\}@cs.fau.de}
}           

\maketitle


\begin{abstract}

In this paper we propose a SystemC-based design methodology focusing on the
implementation of operating system components in hardware by using
Aspect-oriented Programming concepts. As a case study to validate our approach,
we have designed and implemented a hardware thread scheduler and a debugging
aspect program. For comparison purposes, a hand-made scheduler with debugging
capabilities was also implemented. The hardware synthesis results shown that
Aspect-oriented Programming concepts and techniques can be efficiently applied to
digital hardware design in SystemC through the proposed methodology. The observed
overhead in terms of area was less than 1\% and the increase in the longest path
delay for the circuit was less than 3\%. Being SystemC an extension of C++, our
strategy puts effective hardware implementation of operating system components
into reach for many operating system developers.

\end{abstract}

%\begin{IEEEkeywords}
%Aspect-oriented programing, digital hardware design, reconfigurable hardware
%\end{IEEEkeywords}

\category{B.6.3}{Logic Design}{Hardware description languages}
\category{D.4.7}{Or\-gan\-i\-za\-tion and Design}{Real-time systems and embedded systems}

\terms{Design, Languages}

\keywords{Aspect-oriented Programming, Digital Hardware Design, Hardware Description Languages,
SystemC}

\section{Introduction}
\label{INTRO}


%%%%%%%%%

In contrast with general purpose operating systems, embedded operating systems
are usually customized to provide only the functionality necessary to support a
well-specified target application. Factoring the operating system into re\-u\-sa\-ble
components is a good way to model and to design embedded operating systems.
However, dedicated systems are often built as an integrated software/hardware
design and the resulting components not rarely need to cope with extreme
architectural diversity in order to be effectively reused. Some will be initially
deployed in the context of a simple 8-bit microcontroller but will eventually
end in an \emph{Application-specific Integrated Circuit}~(ASIC) or in a
high-end multicore CPU. This architectural variability imposes a major challenge
to the design of really reusable operating system components.

The integrated design of software and hardware allows features typically found on
operating systems to be implemented in hardware, using programmable logic devices
or even designing ASICs. In this context, CPU schedulers have been a favorite for
operating system designers considering hardware implementation as means to reduce
overhead and interference, particularly on real-time tasks. Furthermore,
operations such as context switch and preemption put CPU schedulers high on the
list of complicated OS components to be implemented in hardware and thus are
usually taken as demonstrators for novel design
strategies~\cite{Kuacharoen:2003,Mooney:2000,Kohout:2003,Anderson:2006,Lubbers:2008,So:2008,
Chandra:2006,Pizani:ICECS:2011}.

However, bringing operating system components to hardware is not a trivial task.
Currently there is still a considerable gap between the methodologies and
languages used in software design and those used in hardware design. Electronic
circuits are created from descriptions written in a \emph{Hardware Description
Language}~(HDL). These descriptions can be used either for design verification or
for hardware synthesis (i.e. generate the physical circuit from a description).
Differently from most software programming languages, HDLs are intrinsically
parallel and provide explicit means to describe timing. VHDL~\cite{VHDL:2000}
and Verilog~\cite{Verilog:2001} are the most widely used HDLs and provide means
for designing hardware at \emph{Register Transfer Level}~(RTL). In RTL, circuits
are described in terms of the operations between storage elements which are
synchronized using clock signals. In Verilog/VHDL, a hardware design may be
composed by several \texttt{modules}, whose instances are interconnected to
build the system. However, in contrast to programming languages, the modules
communication is data-driven, and occurs throu\-gh signals defined by the modules
input/output interface.

Nevertheless, the ever increasing complexity of digital hardware designs is
leading to the unification of hardware and software design methodologies. For
example, \emph{Object-oriented Programming}~(OOP) is already supported in the
hardware domain by some HDLs, such as SystemC~\cite{Panda:2001}, a C++ based
modeling platform and language supporting design abstractions at both low and
high levels of abstraction. However, the advances in software engineering have
already shown that OOP still have some limitations in the way it allows a complex
problem to be broken up into reusable abstractions. Even though most classes in
an object-oriented model will perform a single function, they often share common,
secondary elements with other classes. The implementation of these
\emph{crosscutting concerns} is scattered among multiple abstractions, thus
breaking the encapsulation principle. \emph{Aspect-oriented
Programming}~(AOP)~\cite{Kiczales:1997} is an elaboration over OOP to deal with
crosscutting concerns. AOP proposes the encapsulation of such concerns in special
units called \emph{aspects}. An aspect can alter the behavior of the base code by
applying \emph{advices} (small pieces of code defining additional behavior) in
specific points of a program called \emph{pointcuts}. Some extensions to OOP
languages have been proposed to support these concepts. For example,
AspectJ~\cite{Kiczales:2001} and AspectC++~\cite{Spinczyk:2002} extend Java and
C++ with full support for AOP features. They provide both new language constructs
and an \emph{aspect weaver}, a tool responsible for applying the advices to the
base code before it is processed by the traditional compiling chain.

Analogous to software, in hardware some system-wide cross-cutting concerns cannot
be elegantly encapsulated. For example, in complex circuits, interconnection of
several entities is realized by introducing buses. A bus physically interacts
with other components (e.g. CPU, memory, devices), but it is difficult to use a
module or a class to encapsulate the bus because its interface and arbitration
method has to be implemented in every attached component~\cite{Engel:2008}. Other
examples of crosscutting concerns in hardware designs can be also found in parts
of a system related to its overall functionality or to the implementation of
non-functional properties such as fault-tolerance, power management, debugging,
clock handling, and many others~\cite{Endoh:2011}. Even with the introduction of
OOP in hardware, this scattered code is hard to maintain and bugs may be easily
introduced. The introduction of AOP to hardware design is expected to provide the
easy encapsulation of cross-cutting concerns and an increase in the overall
design quality.

% In this paper we explore ... (describe solution) AOP, AOP increases OOP
% expressiveness ... Our proposal...
In this paper we aim to close the gap between the design of hardware and software
operating system components. We propose a design methodology which leverages on
SystemC features in order to enable the implementation of operating system
components in hardware using OOP and AOP concepts. Along with the use of OOP
techniques (e.g. inheritance), we propose the use of a domain engineering
strategy which yields components whose execution scenario dependencies are
isolated and encapsulated as \emph{aspects} and \emph{configurable features}.
These artifacts are implemented using standard C++ metaprogramming features
within the SystemC synthesizable subset~\cite{systemc_subset}, thus yielding
\emph{synthesizable components} that can be more easily modified and reused in a
wider range of execution scenarios. This method is illustrated by the design and
implementation of a task scheduler.

% The remaining of this paper is organized as follows...
The remaining of this paper is organized as follows: Section~\ref{sec:related}
presents a discussion about works related to both the implementation of operating
system features in hardware and the implementation of hardware components using
AOP; Sections~\ref{sec:proposal} and~\ref{sec:case} present our methodology and
the design and implementation of our task scheduler in hardware;
Section~\ref{sec:results} discuss our experimental results; and
Section~\ref{sec:conclusion} closes the paper with our conclusions.

\section{Related Work}
\label{sec:related}

In this section we provide an overview of previous works related to the
implementation of operating system features in hardware. In the subsequent
session we branch to a comprehensive discussion about works related to the
deployment of AOP techniques in hardware design.

\subsection{HW-based Operating Systems}

Several research groups have explored hardware/software co-design for real-time
systems in the last years. Hardware support for task schedulers was proposed,
among others, by Mooney, who has implemented a cyclical
scheduler~\cite{Mooney:2000}, and by Kuacharoen, who has implemented the RM and
EDF priority algorithms~\cite{Kuacharoen:2003}. Beyond the support for tasks
scheduling, Kohout has developed hardware support for time and event management,
taking advantage of the fact that these activities are very often present in
real-time systems and have a high intrinsic parallelism~\cite{Kohout:2003}.
However, this support is limited to fixed priority scheduling and the hardware
implementation of such features does not follow a specific design methodology
that could be reused to bring another components to hardware as well.

Other works focus on the unification of the interface between software and
hardware. This approach is followed by the \emph{HThread}
project~\cite{Anderson:2006}, the ReconOS~\cite{Lubbers:2008} and the
BORPH~\cite{So:2008} operating system. In these works a task performed in
hardware is also abstracted as an OS thread, and a system call interface is
provided between them. In order to allow the interaction of hardware and software
threads, these works propose the implementation of schedulers and synchronization
devices on both domains (hardware and software). However, despite providing this
unified interface, an enormous gap still exists between the way the
hardware and software threads themselves are implemented.

The HW-RTOS~\cite{Chandra:2006} follows a different approach to bring operating
systems features to hardware. It leverages on behavioral synthesis in order to
implement a hardware unit responsible for task scheduling and inter-process
communication. HW-RTOS was described in C and synthesized with a behavioral
synthesis tool, which allowed features to be implemented in hardware by
extracting pieces of code directly from software RTOS kernel.

% From Guto to Tiago: tirei Shalan, pois os outros dois são sim task management.
% Ele ficaria perdido!
Agkul has implemented the priority inheritance protocol with a hardware resource
manager in order to prevent deadlocks and unlimited task
blocking~\cite{Akgul:2003}. Rafla and Gauba have proposed to implement the
context switch in multithread operating systems inside the processor. They
proposed the creation of extra register files dedicated for saving the context
of specific threads, thus allowing very fast context switches in real-time
environments~\cite{Rafla:2011}.

\subsection{AOP Applied to Hardware Design}

% works discussing AOP in hardware \cite{Engel:2008} - AOP discussion and
% proposed VHDL extension / no implementation\newline
% \cite{Bainbridge-Smith:2005} - AOP discussion and proposed new language / few
% details\newline \cite{Burapathana:2005} - very low-level HW design / discussion
% and proposal / no implementation\newline
Several works have already addressed the use of AOP concepts in hardware design.
Engel and Spinczyk discussed the nature of crosscutting concerns in VHDL-based
hardware design and proposed a hypothetical AOP extension to
VHDL~\cite{Engel:2008}. However, the work lacks a concrete implementation so
that the impact of AOP in the design can be consistently evaluated.
Bainbridge-Smith and Park discussed how the separation of concerns may relate to
different levels of algorithmic abstraction. They have mentioned the development
of ADH, a new HDL based on AOP, but further details about ADH are not
mentioned~\cite{Bainbridge-Smith:2005}. Burapathana and others proposed the use
of AOP concepts to sequential logic design. Nevertheless, they focused on very
simple and low level examples like flip-flops and logic
gates~\cite{Burapathana:2005}.

% works that focus on verification \cite{Kallel:2010} - TLM\cite{Cai:2003}
% verification / simulation only / SystemC+AspectC++\newline \cite{Liu:2010} -
% high-level power estimation / simulation only / SystemC+AspectC++\newline
% \cite{Vachharajani:2004} - high-level specification (but AOP features only for
% verification)/ simulation only / new language\newline \emph{Endoh et
% al.}~\cite{Endoh:2008} used AOP to enable assertion-based verification in
% high-level hardware design, in which assertions are based on pointcuts instead
% of specifiers to signal changes. They have designed and implemented two
% assertion languages with pointcut-based assertions, ASystemC and ASpecC, which
% work alongside SystemC and SpecC, respectively. ASystemC uses pointcut of
% AspectC++, and its implementation translates assertions into aspects of
% AspectC++.
There are also several works that proposed the use of AOP concepts mostly for
hardware verification. Kallel and others proposed the use of SystemC and
AspectC++ to implement assertion checkers~\cite{Kallel:2010}. They focused on the
verification of \emph{Transaction-level Models}~(TLM)~\cite{Cai:2003} in which
transaction state updates are taken as pointcuts. They provide a framework in
which the user's verification classes extend base aspect classes that implement
the pointcuts and the verification primitives. Vachharajani and others have
developed the \emph{Liberty Structural Specification
Language}~(LSS)~\cite{Vachharajani:2004}. In LSS, each module can declare
instances which emit certain events at runtime. These events behave like
pointcuts of AOP. Each time a certain state is reached or a value is computed,
the instance will emit the corresponding event and user-defined aspects will
perform statistics calculation and reporting. Liu and others also proposed
AOP-based instrumentation, but focusing high-level power
estimation~\cite{Liu:2010}.  They have developed a methodology based on SystemC
in which AspectC++ is used to define special power-aware aspects. These aspects
are used as configuration files to link power aware libraries with SystemC
models.

% works that focus on design \cite{Endoh:2011} - component design and
% verification / simulation only / SystemC extension \cite{Deharbe:2006} -
% component design and verification / simulation only / SystemC+AspectC++\newline
% \cite{Vax:2007} - modeling and verification (mainly) / simulation only / new
% language\newline \cite{FengLiu:2009} - component design / simulation only /
% SystemC+AspectC++\newline \cite{Jun:2009} - FOP+AOP for hardware design /
% simulation-only / SystemC\newline
Other works provide AOP features not only for verification, but also for actual
 hardware design. D\'{e}harbe and Medeiros presented
and assessed possible applications of AOP in the context of integrated system
design by using SystemC with AspectC++~\cite{Deharbe:2006}. Differently from the
works discussed previously, they showed how AOP can be used to encapsulate some
functional characteristics of hardware components. They modeled as aspects the
replacement policy of a cache, the data type of an FFT, and the communication
protocol between modules. However, only simulation results are shown and they do
not compare the implementation of aspect-based components against components with
all the functionalities hand-coded. In a similar work, Liu and others implemented
a SystemC model for a 128-bit floating-point adder and described the
implementation of the same model using AOP techniques~\cite{FengLiu:2009}. But,
synthesis results are not provided and the two models are compared only in terms
of functionality to show that the AOP design works like the original SystemC-only
design. ASystemC~\cite{Endoh:2011} also extends SystemC in a similar fashion,
but, instead of using AspectC++, the authors developed their own aspect weaver.
The new aspect language was introduced through different case studies involving
high-level estimation of circuit size, feature-configurable products, and
assertion-based verification. However, the evaluation of ASystemC has the same
flaws of the works discussed above.

Other works in this area follow different approaches. The \emph{E} programming
language~\cite{Vax:2007} was designed for modeling and verification of electronic
systems and some of its mechanisms can be used to support AOP features. Apart
from its OOP features, \emph{E} has some constructs to define the execution order
of overloaded methods in inherited classes, which can be used to define pointcuts
and implement aspects. Indeed, this can be used to implement the behavior of
hardware components, but \emph{E} is more focused in high-level specification and
there is not any tool support for synthesis. Jun and others have analyzed the
application of \emph{Aspectual Feature Module}~(AFM)~\cite{Apel:2008} to HDLs.
They have implemented a RISC processor using SystemC and
FeatureC++~\cite{Apel:2008}, and showed how AFM enables the incremental
development of hardware through the modularization of code fragments for the
implementation of a function~\cite{Jun:2009}. However, AOP is used only for
encapsulation of verification code and the authors do not provide synthesis
results of the resulting code.

In summary, several of the previous works have focused on high-level
specification and AOP features are used mostly for code instrumentation and
verification. Also, there are not any related work aiming at using AOP for the
actual design of synthesizable hardware, since, as discussed above, all works
present experiments only at the simulation level and lack a more comprehensive
discussion about the overheads related to the use of AOP.

\section{Designing Hardware OS Components Using AOP}
\label{sec:proposal}

%-Introduction
%Introduction to ADESD (previously known as AOSD\cite{Froehlich:2001})
%Use the techniques proposed by ADESD and implemented in C++ to
%implement HW components in SystemC
%Maybe include the classic ADESD figure

% OBS.: come�ar falando que vamos aplicar AOP em HW usando conceitos da ADESD ao
% inv�s de sair falando de cara sobre cen�rio adapters.
\emph{Application-driven Embedded System Design}~(ADESD)~\cite{Froehlich:2001},
the design method used in this work, is an elaboration over techniques which have
been used in the software domain to develop component-based systems. The
methodology elaborates on commonality and variability analysis---the well-known
domain decomposition strategy behind OOP---to add the concept of aspect
identification and separation at early stages of design. It defines a domain
engineering strategy focused on the production of families of
scenario-independent components. Dependencies observed during domain engineering
are captured as \emph{scenario aspects}, thus enabling components to be reused
on a variety of execution scenarios by the application of the respective
\emph{scenario aspects}. This aspect weaving is performed by constructs called
\emph{Scenario Adapters}~\cite{Froehlich:2000}.

The design artifacts proposed in ADESD were implemented and validated on the
\emph{Embedded Parallel Operating System} (EPOS) \cite{Froehlich:2001}. EPOS aims
to automate the development of dedicated computing systems, and features a set of
tools to select, adapt, and plug components into an application-specific
framework, thus enabling the automatic generation of an application-oriented
system instance. EPOS is implemented in C++ and leverages on \emph{Generative
Programming}~\cite{Czarnecki:2000} techniques such as \emph{Static
Metaprogramming} in order to achieve high reusability with low overhead.

Whether such guidelines can also be defined for designing operating system
hardware components has not yet been investigated, but nonetheless, SystemC
enables the introduction of convenient C++ constructs to increase the quality of
hardware designs. This will be demonstrated in the next sections.

%-Describe the design artifacts
%Describe the artifacts belows in terms of hardware (with signals, etc)

\subsection{Scenario Adapters}
%Scenario adapters\cite{Froehlich:2000}.

Scenario adapters were developed around the idea of components getting in and out
of an execution scenario, allowing actions to be executed at these points,
therefore, a scenario must define at least two different operations:
\texttt{enter} and \texttt{leave}. These actions must take place respectively
before and after each of the component's operation in order to setup the
conditions required by the scenario. For example, in a compressed scenario, enter
would be responsible to decompress the component's input data, while leave would
compress its outputs.

In the software domain, components are objects which communicate using method
invocation (considering an OOP-based approach) and the execution of all
operations are naturally sequential, so the scenario adapters were originally
developed to provide means to just efficiently wrap the method calls to an object
with enter and leave operations. However, in the hardware domain, components have
input and output signals instead of a method or function interface, and all
operations are intrinsically parallel. These different characteristics required
some modifications of the original scenario adapter. The new scenario adapter is
shown in Figure~\ref{fig_scenario_adapters_uml_detail}.

\figTC{.65}{fig_scenario_adapters_uml_detail}
{UML class diagram showing the general structure and behavior of a scenario adapter.}

SystemC defines hardware components by the specialization of the
\texttt{sc\_module} class. Components communicate using special objects called
\texttt{channels}. SystemC channels can be used to encapsulate complex
communication protocols at register transfer or higher levels of abstraction.
However, these complex channels lie outside the SystemC synthesizable subset, so
we use only \texttt{sc\_in} and \texttt{sc\_out}, which define simple input and
output ports for components. Methods which implement the component's behavior
must be defined as SystemC processes. In our examples we use SystemC clocked
threads (\texttt{SC\_CTHREAD}), in which all operations are synchronous to a
clock signal. The implementation of the \texttt{Component::controller} method in
Figure~\ref{fig_scenario_adapters_uml_detail} shows the common behavior of a
\texttt{SC\_CTHREAD}. SystemC \texttt{wait()} statements must be used to
synchronize the operations with the clock, in other words, all operations defined
between two \texttt{wait()} statements occur in the same clock cycle.

Using these constructs, we define each aspect as a single and independent
hardware component (\texttt{Aspect} class). \texttt{enter()} and \texttt{leave()}
operations are defined using a simple handshaking protocol (\texttt{op\_rdy\_out}
and \texttt{op\_req\_in} signals) to trigger its execution. The remaining
input/output ports define which operation are being triggered (this is specific
of each aspect). With this kind of handshaking communication protocol we can
produce more re\-u\-sa\-ble components, since the number of clock cycles it requires
for each operation is hidden by the protocol, thus making it easier to
synchronize component execution with the rest of the design.

The \texttt{Scenario} class incorporates, via aggregation, all of the aspects
which define its characteristics. It defines \texttt{enter()} and
\texttt{leave()} methods to encapsulate the implementation of the handshaking
protocol which trigger the aspects. Figure~\ref{fig_scenario_adapters_uml_detail}
shows how the scenario's \texttt{enter()} operation is implemented. All aspects
are triggered at the same time and executes in parallel, however, if required by
the scenario, this can be modified in order to execute each aspect sequentially
at the cost of additional clock cycles.

The adaptation of the component to the scenario is performed by the
\texttt{Scenario Adapter} class via inheritance. This adaptation is possible
through the separation of the component's input/output protocol from the
implementation of its behavior. A SystemC process (\texttt{controller} method)
handles the input/output protocol (\texttt{behavior} method) and calls the
requested operations, which are each implemented in its own methods. These
methods are overridden in the \texttt{Scenario Adapter} class. Notice that,
although scattered through a class hierarchy and different methods, all
operations (from the handling of the component's input/output protocol, to the
triggering of the aspects) executes inside the \texttt{controller}
\texttt{SC\_CTHREAD} process. For the proposed scheme to work, \texttt{wait()}
statements are also used to schedule the operations among the clock cycles,
instead of defining explicit state machines. If the latter is used, it would not
be possible to elegantly implement the structure described in
Figure~\ref{fig_scenario_adapters_uml_detail}, since a state machine would
require manual intervention to add the operation defined by the scenario.

%Figure \ref{fig_scenario_adapters_block}
%also show how the design entities interacts by using a representation which is closer
%to the physical implementation.
%\fig{.58}{fig_scenario_adapters_block}
%{Block diagram showing the general structure of a scenario adapter.}  


\subsection{Configurable Features}
%Configurable features using static metaprogramming.

Additionally to the analysis and domain engineering process, several
characteristics can be identified as configurable features of the components. In
fact, such characteristics represent fine variations within a component, which
can be set in order to change slightly its behavior or structure.
Figure~\ref{fig_config_features_uml} shows how this features can be implemented
using \emph{Static Metaprogramming}~\cite{Czarnecki:2000} techniques. Special
template classes called \emph{Traits} are used to define which characteristics of
each component is activated. Metaprograms are then used to conditionally modify
the component behavior or modify its structure through inheritance.

\figTC{.65}{fig_config_features_uml}
{Components behavior and structure modified by configurable features.}


\subsection{ADESD and Classic AOP}
%-Discussion: ADESD X classic AOP (for hardware design)
%Basically, needs to justify the use of the above artifacts for HW design
%instead of other stuff proposed by other authors
%Using AspectC++ for example allows for full AOP in SystemC 
%(more powerful then scenario adapters), so why don't we use it ?
%The resulting code is not synthesizable, AspectC++ introduces dynamic pointers
%and objects outside the SystemC synthesizable subset (strong claim, actually needs further
%investigation)
%Most of the examples in the related works used have design problems that could be 
%more elegantly solved using other techniques rather than AOP (e.g. inheritance, 
%template parameters -- when using C++/SystemC)\cite{Afonso:2007, Deharbe:2006}
%The remaining problems can be easily solved by scenario adapters
%Only standard languages features are used. No extensions or extra tools are required.
%Can use OOP + scenario adapters + static metaprogramming and still remains within the
%SystemC synthesizable subset.
%Maybe talk something about homogeneous and heterogeneous crosscutting~\cite{Jun:2009}

Several previous works have already discussed aspect-oriented hardware design
using SystemC and proposed solutions based on classic AOP concepts using the well-known 
AspectC++ language. Indeed, AspectC++ provides more powerful mechanisms for
aspect implementation then ADESD, especially when it comes to the definition of
the pointcut, however, this additional mechanisms are usually either unnecessary
or can be efficiently replaced. For example, the aspects implemented by
D\'{e}harbe and Medeiros~\cite{Deharbe:2006}~(Section \ref{sec:related}) could be
more elegantly implemented using other standard C++ features like inheritance and
templates parameters. In the scope of ADESD, we can say that scenario adapters
can be used to implement \emph{homogeneous crosscutting}~\cite{Jun:2009} (the
process of adding the same behavior for all classes). \emph{Heterogeneous
crosscutting}~\cite{Jun:2009}(when concern is specific to a certain component or
family of components) can be easily implemented with standard OOP (e.g.
inheritance). Additionally the implementation of ADESD's mechanisms can be
realized using only standard SystemC features. Previous works focus on tools and
languages which were deployed only for software development (e.g. AspectC++),
which limits its use for the generation of synthesizable hardware.

\section{Case Study: a Hardware Scheduler}
\label{sec:case}

%-Describe the case study: the OS Scheduler\cite{Marcondes:2009:2}
%*Talk about the separation between the scheduling mechanism and the scheduling 
%criteria. Figure \ref{fig_scheduler_model}.
%\figEMPTY{3in}{4in}{fig_scheduler_model}{Simplified version of the
%task scheduler model}

Our case study is based on a previous implementation of the EPOS scheduler
described by~\cite{Marcondes:2009:2}, which described a task scheduling
suitable for hardware and software implementation. However, the original VHDL
implementation was not susceptible to the same mechanisms that render its
software counterpart flexible and re\-u\-sa\-ble. The new System-based hardware
scheduler is described below.

Figure~\ref{fig_schduler_model_uml} shows a simplified view of the task
scheduling model. In this design, the task is represented by the class
\texttt{Thread} and defines the execution flow of the task, implementing the
traditional functionality (e.g. suspend and resume operations). This class models
only aperiodic tasks. Periodic tasks, a common abstraction of real-time systems,
are in fact a specialization of the \texttt{Thread} class which aggregates the
mechanisms related to the re-execution of the task periodically, responsible for
reactivating the task when a new period expires.

\fig{.6}{fig_schduler_model_uml}
{Simplified UML view of the task scheduling model.}

The classes \texttt{Scheduler} and \texttt{SchedulingCriteria} define the
structure that realizes the task scheduling. Traditional design and
implementations of scheduling algorithms are usually done by a hierarchy of
specialized classes of an abstract scheduler class, which can be further
specialized to bring new scheduling policies to the system. In order to reduce
the complexity of maintenance of the code (generally present in such hierarchy of
specialized classes), as well as to promote its reuse, the design detaches the
scheduling policy (criteria) from its mechanisms (lists implementations) and also
detaches the scheduling criteria from the thread it represents.  This is achieved
by the isolation of the element's comparison algorithm of the scheduler in the
criteria.

\subsection{Hardware Implementation}
%-Describe the hardware scheduling mechanism. Figure \ref{fig_scheduler_hw_blocks}.
%\figEMPTY{3in}{3in}{fig_scheduler_hw_blocks}{Block diagram of HW scheduling mechanism}

The separation of the mechanism from the scheduling policy was fundamental for
the construction of the scheduler in hardware. The hardware scheduler component
implements only the mechanisms that realize the ordering of the tasks, based on
the selected policy. In this sense, the same hardware component can realize
distinct policies.

The implementation of the scheduler in hardware follows a well-defined structure.
It has an internal memory that implements an ordered list. One process
(\texttt{Controller}) is responsible for interpreting all the data received by the
interface of the component in hardware and then to activate the process
responsible for implementing the functionality requested by the user (through the
command interface register). This implementation, as the software counterpart,
realizes the insertion of its elements already in order, that is, the queue is
always maintained ordered, following the information that the
\texttt{SchedulingCriteria} provides. In the memory of the component, a
double-linked list is implemented.

It worth's highlight two aspects of the implementation of this component
regarding its implementation on hardware, especially for programmable logic
devices. Both of these aspects are related to the constraints in terms of
resources of such devices. Ideally, a hardware scheduler should exploit as most
the inherent parallelism of the hardware resources. However, such resources are
very expensive, especially when the internal resources are used to implement
several parallel bit comparators in order to search elements on the queue, as
well as to find the insertion position of an element in queue.

Moreover, the use of 32 bits pointers to reference the elements stored on the
list (in this case \texttt{Threads}) becomes extremely costly for implementing
the comparators to search such elements. On the other side, the maximum number of
tasks in an embedded system is usually known at design time, and for that reason,
the resources usage of this component could be optimized by implementing a
mapping between the system pointer (32 bits) and an internal representation that
uses only the necessary number of bits, taking into account the maximum number of
tasks running on the system.

Another aspect is related to the search of the position of insertion of the
element on the queue. Ideally, such searching could be implemented through a
parallel comparison between all elements on the queue, in order to find the
insertion point in only one clock cycle. However, such approach, besides
increasing the consumption of the resources, as the number of tasks increase it
could lead to a very high critical path delay on the synthesized circuit, and
thus, to reduce the operating frequency of the component.

By this reason, the insertion of elements was implemented doing a sequential
search of the insertion position of the element, which will take N cycles in the
worst-case. Besides in this approach, the insertion time could the variable, such
variation is hidden by the effect that the insertion could be realized in
parallel to the software running on the CPU.

\subsection{Aspects Implementation}

%-Describe the aspects implemented
%*Implemented aspects from de Debugged family (talk  little about it,
%reference Guto's thesis)\cite{Froehlich:2001} for hardware debugging through JTAG
%*Traced aspect. Figure \ref{fig_debug_aspects}
%*Profiled aspect. Figure \ref{fig_debug_aspects}
%*Watched aspect. Figure \ref{fig_debug_aspects}
%\figEMPTY{3in}{4in}{fig_debug_aspects}{The debugged family of hardware aspects}

We have implemented aspects for debugging. Unlike previous works, which focused
on simulation-time tracing and logging~\cite{Vachharajani:2004,Liu:2010}, we have
focused on \emph{Design for Testability}~\cite{Williams:1983} and implemented
aspects for on-chip debugging using a JTAG scan chain.
Figure~\ref{fig_debug_aspects_uml} shows the debugged family of hardware aspects.
The class~\texttt{DebuggedCommon} defines common ports for all aspects. Besides
the ports used for clock and reset, it defines outputs for a JTAG debug
protocol~(\texttt{trigger\_out} and \texttt{data\_out}) and for the enter/leave
protocol~(\texttt{op\_rdy\_out} and \texttt{op\_req\_in}). The input values for
the ports defined by the subclasses determine which operation will be triggered.

\fig{.6}{fig_debug_aspects_uml} {The debugged family of hardware aspects.}
\fig{.6}{fig_adapted_sched_diagram_uml}{Scheduler modified by the scenario
adapter.}

The aspects implemented define the following debugging functionality:
\texttt{Watched} causes the state of a component to be dumped every time it is
modified; \texttt{Traced} causes every operation execution to be signalized; and
\texttt{Profiled} counts the number of clock cycles used by the component for
each operation.


\subsection{Scenario Adapter Implementation}
%-The weaving process
%*Describe the Debugged scenario
%*Describe the scenario adapter for the scheduler
%*wait() statements are used to schedule operations instead of state machines
%\figEMPTY{3in}{4in}{fig_adapted_sched_diagram}{Scheduler modified by the scenario adapter}

Figure~\ref{fig_adapted_sched_diagram_uml} shows how we applied the aspects to
the scheduler using a scenario adapter (for simplicity, some details, such as
methods, ports, and hierarchies, are omitted). The implementation follows the
guidelines depicted in Figure~\ref{fig_scenario_adapters_uml_detail}. The class
\texttt{Scheduler} defines the scheduler component. The \texttt{controller}
SystemC process is responsible for reading the component inputs and calling the
method which implements the corresponding operation. The class
\texttt{AdaptedScheduler} implements the scenario adapter. It inherits from the
\texttt{Scheduler} and \texttt{Debugged} classes, and redefines the operation
methods by adding calls to the \texttt{enter()} and \texttt{leave()} methods of
\texttt{Debugged}. The \texttt{Debugged} class defines the scenario and its
methods implement the handshaking protocol that triggers the aspects components.
%The debug information
% generated by the aspects is forwarded to outputs defined by the scenario.


\section{Experimental Results}
\label{sec:results}


We have evaluated the efficiency aspect-oriented implementation described
previously with an object-oriented-only implementation in which the aspects
behavior is \emph{hand-coded} in the core components. We have synthesized our
design to physical circuits targeting a \emph{Field-programmable Gate
Array}~(FPGA) and analyzed their performance and size (area).
Figure~\ref{fig_synth_flow} shows the synthesis flow. The SystemC designs are
first converted to VHDL descriptions using Celoxica's Agility 1.3. Then, Xilinx
ISE 13.1 is used for both logic synthesis and place-and-route (the process of
fitting a circuit for a specific FPGA device). As our target device we have
chosen a Xilinx XC3S2000 FPGA. All the synthesis processes described in the flow
were executed with all the optimizations enabled.

\fig{.65}{fig_synth_flow}
{Design synthesis flow targeting FPGAs.}

Tables~\ref{tab_results_agility_est} and \ref{tab_results_xilinx_edif} show the
number of \emph{slices} used (a configurable logic element in Xilinx's FPGA) and
the \emph{longest path delay}~(LPD). The LPD represents the performance of the
circuit, while the number of slices is used to evaluate the area. \emph{Standard
scheduler} is the scheduler component without any modification, \emph{Debugged
scheduler---scenario adapter} is the scheduler modified with the scenario adapter
while \emph{Debugged scheduler---hand coded} is the scheduler with the aspects
functionalities hand coded. Table~\ref{tab_results_xilinx_edif} also shows the
debugged family synthesized in isolation.

\tabTC[ht]{tab_results_agility_est}
{Hardware resources estimated by Agility}

\tabTC[ht]{tab_results_xilinx_edif}
{Hardware resources used after placing and routing Agility's netlists}

The results show that the use of scenario adapters yields a very low overhead in
terms of both resource consumption and performance.  For the scenario-adapted
scheduler, the number of occupied slices is about $1\%$ higher than the
hand-coded scheduler. This overhead comes basically from the additional signal
and registers required by the handshaking protocol that is used to trigger the
aspects, which is not required when everything is coded within a single SystemC
process. The difference in performance (given by the longest path delay) is about
$3\%$. Curiously, in the final place-and-routed designs, the hand-coded scheduler
has the smaller longest path delay. This may be the result of some optimization
algorithm applied in the place-and-route back-end.

%Also, the modularized structure of the
%scheduler does not yield any overhead since it is based on static mechanisms
%which are resolved at synthesis-time.

%Tables \ref{tab_results_xilinx_edif} and \ref{tab_results_xilinx_vhdl} also compares
%the synthesis results of the designs synthesized from SystemC using
%Agility with a design implemented by hand in VHDL and fully synthesized
%using Xilinx's tools. Both the \emph{Normal scheduler} and the \emph{VHDL scheduler}
%are semantically equivalent and differ only in the syntax defined by SystemC
%and VHDL, respectively, however, the SystemC scheduler occupies $46\%$ more area
%and is $97\%$ slower than the VHDL scheduler, showing that SystemC synthesis
%is still an open issue even for RTL designs.

%-Discussion
%*scenario adapted scheduler - scheduler with hand-coded debugging = 
%this technique overhead (we hope it is not too high)
%*Original VHDL scheduler much more efficient. This just shows that Agility's
%SystemC synthesis is not very efficient
%*Comment something about Agility's direct synthesis results

%\tabTC{tab_results_xilinx_vhdl}
%{Hardware resources used when synthesizing the VHDL generated by Agility.}

\section{Conclusion}
\label{sec:conclusion}
In this paper we have shown how the ADESD domain engineering strategy and AOP
techniques can be applied to design and implement flexible operating system
components in hardware. As a case study we have implemented a task scheduler in
SystemC. The scheduler's dependencies from a debugging execution scenario were
encapsulated in aspects and further applied to the core component through the use
of a scenario adapter, thus providing a better separation of concerns.

In comparison with other approaches, we have focused in the design of
synthesizable hardware components, rather than verification and simulation-only
models. The results showed that our design artifacts can be synthesized
without introducing significant overhead in the generated components.

\section*{Acknowledgments} This work was partially supported by the
\emph{Coordination for Improvement of Higher Level Personnel}~(CAPES) grant,
projects RH-TVD 006/2008 and 240/2008, and by the \emph{German Research
Council}~(DFG) under grant no. SCHR 603/7-1.

\bibliographystyle{abbrv}
\bibliography{paper}

\end{document}
