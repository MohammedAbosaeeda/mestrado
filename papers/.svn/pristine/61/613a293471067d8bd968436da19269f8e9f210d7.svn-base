%-------------------------------------------------------------------------------
% ARTIGO PARA O SBAC'96
%-------------------------------------------------------------------------------
\documentstyle[times,12pt]{artigo}

%-------------------------------------------------------------------------------
% NOVOS COMANDOS
%-------------------------------------------------------------------------------
\newcommand {\putpict} [5] {
  \begin {figure} [htb]
  \centerline {
    \psfig{figure={#1},width=#2cm,height=#3cm}
  }
  \caption{#4}
  \label{#5}
  \end{figure}
}

%-------------------------------------------------------------------------------
% DEFINIÇÃO DAS PÁGINAS
%-------------------------------------------------------------------------------
% Margem superior de 3.5cm
% Margens laterais de 3cm
% Margem inferior de 2cm
% Sem numero de página
\oddsidemargin	4.6mm
\evensidemargin	4.6mm
\topmargin	-2.1cm
\headheight	1cm
\headsep        2cm
\footskip	1.5cm 
\textheight	242mm
\textwidth	150mm
\parskip	0.5em
\pagestyle{empty}

\begin{document}

%-------------------------------------------------------------------------------
% CAPA 
%-------------------------------------------------------------------------------
\title{\bf Ambiente para Execução de Programas Concorrentes no i486}

\author{Antônio A. Fröhlich, Hélder Savietto, João P. de Oliveira \\ Jorge R. de Oliveira, Luciano Piccoli \& Rafael B. Ávila}

\date{}

\maketitle

\thispagestyle{empty}

\vspace{-0.5cm}
\begin{center}
  Universidade Federal de Santa Catarina \\
  Centro Tecnológico \\
  Departamento de Informática e de Estatística \\
  88.049.970 - Florianópolis - SC\\
  Tel.:(048)231-9498 Fax:(048)231-9770 \\
  E-mail: guto@inf.ufsc.br
\end{center}

%-------------------------------------------------------------------------------
% INCLUI DEFINIÇÕES PARA AS FIGURAS
%-------------------------------------------------------------------------------
\input{psfig}

%-------------------------------------------------------------------------------
% RESUMO
%-------------------------------------------------------------------------------
\begin{abstract}

	Este artigo descreve um ambiente de programação concorrente para a família de processadores 486 da Intel. O ambiente proposto faz uso das características avançadas do processador, tais como gerência de memória, {\em multitasking} e proteção, para fornecer um ambiente de execução compacto e seguro às aplicações.

	O ambiente, no que diz respeito à gerência de processos, suporta {\em multitasking}, {\em multithreading} e escalonamento com prioridade dinâmica. Quanto à gerência de memória, o ambiente suporta um esquema de paginação que mapeia toda a memória física disponível em espaços lógicos de 4 Gbytes por processo. A cooperação entre processos é feita através de memória compartilhada e semáforos, enquanto que a proteção dos objetos do ambiente é feita com o auxílio de {\em capabilities}.

\end{abstract}

%-------------------------------------------------------------------------------
% ABSTRACT
%-------------------------------------------------------------------------------
\begin{englishabstract}

	This paper describes a concurrent programming environment for the Intel's 486 processors family. The environment uses the processor's advanced features, like memory management, multitasking and protection, in order to supply the application level with a compact and secure running environment.

	Regarding process management, the environment supports multitasking, multithreading and dynamic priority scheduling. The memory management strategy is based on paging. The available physical memory is mapped into 4 Gbytes logical address spaces for each process. Cooperation among process is achieved through memory sharing and semaphores. Environment's objects are protected by means of capabilities.

\end{englishabstract}

%-------------------------------------------------------------------------------
% INTRODUÇÃO
%-------------------------------------------------------------------------------
\section{Introdução}

	Desde que a IBM escolheu o 8088 como processador principal para sua linha de computadores pessoais, esta família de processadores vem sendo cada vez mais utilizada. Hoje, a maior parte dos computadores pessoais está equipada com este tipo de processador. Ao longo dos anos, esta família de processadores tem incorporado uma série de novas características, tais como gerência de memória, {\em multitasking} e mecanismos de proteção. Entretanto, apesar da potencialidade do processador, poucos sistemas operacionais fazem uso dos recursos mais avançados. 

	Este artigo descreve um ambiente para a execução de programas concorrentes em PCs com processadores da família 486 (386, 486, Pentium, etc). Os principais recursos disponíveis no processador são utilizados para garantir um ambiente compacto, eficiente e seguro que é disponibilizado às aplicações na forma de primitivas. O ambiente proposto, devido à sua versatilidade, pode ser utilizado diretamente pelas aplicações ou pode servir de suporte ao desenvolvimento de um sistema operacional. Além disso, seu código de tamanho reduzido permite que ele seja armazenado em EPROM e sirva de suporte em {\em hardwares} dedicados.

      Este artigo está organizado da seguinte forma: primeiramente, são apresentados o processador i486 e a estrutura básica do ambiente de execução; a seguir, são descritos os esquemas de gerência de processos, memória e entrada e saída; após o que são apresentados os mecanismos de proteção e se suporte a programação concorrente; por fim, os autores apresentam uma análise das perspectivas para o ambiente e suas conclusões pessoais.

	
%-------------------------------------------------------------------------------
% O PROCESSADOR i486
%-------------------------------------------------------------------------------
\section{O Processador i486}

	O processador Intel i486 \cite{int87,int90} é um processador CISC bastante versátil. Ele apresenta três modos de operação: real, virtual e protegido. Quando em modo real, o processador se comporta como um 8086 de alta velocidade. Neste modo de operação, o espaço de memória é dividido em segmentos de 64 Kbytes e não existe nenhuma forma de proteção, nem quaisquer mecanismos de suporte a {\em multitasking}.

	O modo virtual é um meio termo entre os modos real e protegido. Os recursos de proteção de memória e {\em multitasking} estão disponíveis, porém o conjunto de instruções e o mecanismo de tradução de endereços continuam limitados aos do 8086. O modo virtual pode ser comparado a vários processadores 8086 trabalhando simultaneamente.

	O modo protegido é o modo que permite a plena utilização dos recursos do processador. Nele são habilitados todos os mecanismos de proteção, de suporte a {\em multitasking} e de gerência de memória. Duas estratégias de gerência de memória estão disponíveis: segmentação e segmentação paginada. Com segmentação, a memória é organizada em segmentos de tamanho variável, enquanto que a paginação faz uso de páginas de tamanho fixo igual a 4 Kbytes. Existem ainda quatro níveis de privilégio de execução que podem ser utilizados para implementar esquemas de restrição de acesso à memória e às instruções do processador.

%-------------------------------------------------------------------------------
% ESTRUTURA DO SISTEMA
%-------------------------------------------------------------------------------
\section{Estrutura do Ambiente}

	O ambiente proposto é formado por quatro módulos: gerência de processos, gerência de memória, sincronização e suporte a E/S. Sobre estes módulos reside uma camada de interface com as aplicações que garante a proteção dos objetos do ambiente, que são: segmentos lógicos de memória, {\em tasks}, {\em threads}, semáforos, tratadores de interrupções e portas de E/S.

	Existem dois modelos básicos de uso do ambiente: como suporte a um sistema operacional, ou como suporte às aplicações. Uma vez que o ambiente fornece apenas abstrações básicas, é possível desenvolver um sistema operacional sobre ele praticamente sem restrições \cite{eng94}. Por outro lado, o ambiente é completo o suficiente para suportar aplicações específicas. A figura \ref{environment} ilustra os dois casos.

\putpict{environment.ps}{13}{4}{Ambiente de execução suportando (a) um sistema operacional e (b) aplicações.}{environment}

%-------------------------------------------------------------------------------
% GERÊNCIA DE PROCESSOS
%-------------------------------------------------------------------------------
\section{Gerência de Processos}

	O gerenciador de processos desenvolvido para o ambiente teve como principais metas a eficiência e a flexibilidade. Para atingir a meta de eficiência, ele suporta {\em multitasking}, {\em multithreading} e escalonamento com política de prioridade dinâmica. Para ser flexível, o gerenciador de processos abdica de boa parte das abstrações normalmente presentes em sistemas convencionais, como por exemplo hierarquia de processos. A seguir serão analisadas cada uma destas características.


\subsection{Processo}

	A fim de aproveitar da melhor forma possível os recursos da arquitetura, o ambiente implementa o conceito de processos como combinações de {\em tasks} e {\em threads} \cite{tan92b,acc86}, onde {\em tasks} são entidades passivas, constituídas de áreas de memória protegidas para código e dados globais; e {\em threads} são entidades ativas que executam o código de uma {\em task} e manipulam seus dados. Cada {\em thread} possui seu próprio contexto e pilha, de tal forma que uma mesma {\em task} pode apresentar vários {\em threads} simultaneamente.

	Além de suportar {\em multithreading}, o ambiente suporta a coexistência de múltiplas {\em tasks}. Para tal, são mantidos descritores que armazenam informações estatísticas e de controle sobre {\em tasks} e {\em threads}. A figura \ref{process} mostra a representação do modelo de processos do ambiente.

\putpict{process.ps}{9}{3}{Modelo de processo no ambiente.}{process}

\subsection{Escalonamento}

	A entidade de escalonamento do ambiente é o {\em thread}, independente da {\em task} à qual pertença. Ou seja, {\em threads} de uma mesma {\em task} concorrem pela CPU em estado de igualdade com {\em threads} de outras {\em tasks}.

	A política de escalonamento de {\em threads} implementada pelo ambiente é, em última análise, a de prioridades dinâmicas. Contudo, existem várias formas de influenciar as decisões de escalonamento. Quando um {\em thread} é criado, lhe é atribuído, pelo {\em thread} criador, um limite de prioridades. Sempre que um {\em thread} é escalonado, um {\em timer} é programado para limitar o tempo que ele pode executar a uma fatia de tempo. Quando o {\em thread} deixa a CPU, sua prioridade é recalculada com base na utilização da fatia de tempo, e ajustada para o intervalo definido na criação. 

	Esta política é similar à utilizada no sistema operacional {\sc Unix} \cite{bac87} e, ao longo dos anos, vem se mostrando muito eficiente para sistemas interativos, pois beneficia os processos que realizam mais E/S. A principal diferença está na existência de um intervalo de prioridades, que permite definir políticas específicas. Este intervalo pode ser alterado pelo {\em thread} criador a qualquer momento. Desta forma, um sistema operacional sobre o ambiente poderia atribuir intervalos distintos de tamanho 1 para os {\em threads} e redefini-los de acordo com um política própria.

	A implementação atual trabalha com fatias de tempo de 10 "ticks" de 10 ms. Prioridades são números de 8 bits, sendo que zero é a mais alta prioridade. As prioridades são recalculadas a cada ciclo de execução segundo a fórmula abaixo e ajustada ao intervalo:

Nova Prioridade = Prioridade Atual / 2 + \% fatia de tempo * 128
	
	{\em Threads} são implementados através dos {\em Task State Segments} (TSS) do i486 \cite{int90}, que permitem o salvamento automático de contexto. 	


\subsection{Sincronização}

	Uma vez que {\em threads} de uma mesma {\em task} compartilham os dados globais, eles não precisam de mecanismos explícitos para cooperarem; entretanto, mecanismos específicos devem ser fornecidos para evitar interferências indesejadas. O ambiente suporta semáforos que podem ser usados para sincronizar {\em threads} de uma mesma {\em task} ou compartilhados por {\em threads} de {\em tasks} distintas.

	As operações permitidas sobre um semáforo são: alocação, inicialização, compartilhamento e alteração de valor. Para a alteração do valor do semáforo são oferecidas as operações P e V, conforme definidas por Dijkstra \cite{and91}. A atomicidade destas duas operações é garantida através da instrução {\tt XCHG} do i486, que manipula duas posições de memória atomicamente.

%-------------------------------------------------------------------------------
% GERÊNCIA DE MEMÓRIA
%-------------------------------------------------------------------------------
\section{Gerência de Memória}

	A estratégia de gerência de memória ideal para o ambiente é a paginação, principalmente por não apresentar fragmentação externa, mas também por ser um esquema flexível e amplamente utilizado. Todavia, o processador i486 não suporta paginação pura.

	A fim de mapear toda a memória de física disponível em espaços lógicos de 4 GBytes, adotou-se o modelo de segmentação paginada onde existem apenas dois segmentos, um de código e um de dados, que são utilizados por todos os processos. Estes segmentos têm base no endereço zero e limite em 4 Gbytes e são mapeados através de tabelas de páginas privativas a cada {\em task}. Desta forma, a segmentação fica sem função.

	Note que a iniciativa de alocar memória cabe a um {\em thread}, entretanto a alocação se dá a nível de {\em task}. Ou seja, a memória alocada por um {\em thread} é automaticamente disponível aos demais {\em threads}
da mesma {\em task}.

	A alocação de memória é feita em segmentos lógicos de até 4 Mbytes, que são mapeados em memória física. Um segmento lógico nada tem a ver com os segmentos do i486, sendo apenas um conceito de gerenciamento. Cada {\em thread} pode alocar quantos segmentos achar necessário.

	O controle de acesso à memória é feito através de bits de proteção associados a cada página. Os atributos que podem ser associados a uma página pelo i486 são: leitura e escrita / apenas leitura e supervisor / usuários. O ambiente utiliza estes atributos, em combinação com os níveis de privilégio de execução, da seguinte forma:

\begin{itemize}
\item Páginas de segmentos de código são apenas para leitura;
\item Apenas código do ambiente executa em modo supervisor;
\item Páginas do ambiente são acessíveis apenas em modo supervisor.
\end{itemize}

	Qualquer segmento pode ser expandido ou reduzido, entretanto os segmentos lógicos de pilha são autoexpansíveis.  Ou seja, quando houver necessidade ({\em stack overflow}), uma nova página é alocada. Da mesma forma, quando uma página deixa de ser utilizada, ela é automaticamente liberada.

%-------------------------------------------------------------------------------
% SUPORTE A ENTRADA E SAÍDA
%-------------------------------------------------------------------------------
\section{Suporte a Entrada e Saída}

	O ambiente proposto não suporta qualquer tipo de dispositivo de entrada e saída. Entretanto, ele permite que um processo solicite que interrupções e portas de E/S sejam mapeadas em seu espaço de endereçamento. Ou seja, a gerência de entrada e saída é feita completamente fora do ambiente por aplicações ordinárias. Desta forma, o ambiente se mantém compacto e as aplicações ficam livres para manipular os dispositivo de forma mais eficiente ou mapear {\em drivers} fornecidos pelos fabricantes. Este mecanismo é implementado através de mapas de permissão de E/S associados aos {\em Task State Segments} do i486.

%-------------------------------------------------------------------------------
% PROTEÇÃO DOS OBJETOS DO AMBIENTE
%-------------------------------------------------------------------------------
\section{Proteção dos Objetos do Ambiente}

	Os objetos internos do ambiente são identificados e protegidos por um esquema de {\em capabilities}. Uma {\em capability} é uma estrutura constituída de quatro elementos: a identificação da classe do objeto, a identificação do objeto dentro de sua classe, permissões sobre o objeto e um número randômico. Este esquema foi introduzido pelo sistema Amoeba \cite{tan92c} e foi adotado por se adequar perfeitamente ao ambiente proposto.

	Cada objeto mantido pelo ambiente está associado uma {\em capability}, que lhe é atribuída quando de sua criação. Esta {\em capability} é também repassada ao {\em thread} que solicitou a criação do objeto. O controle de acesso fornecido pelo ambiente é muito simples: sempre que um {\em thread} requisita acesso à um objeto do ambiente, ele deve fornecer uma {\em capability} que é comparada à armazenada internamente.

	Um {\em thread} está livre para repassar uma {\em capability} que tenha obtido a outros {\em threads}, podendo para isso, solicitar ao ambiente a criação de {\em capabilities} restritas. Desta forma, um processo externo pode implementar qualquer política de controle de acesso.

%-------------------------------------------------------------------------------
% SUPORTE À PROGRAMAÇÃO CONCORRENTE
%-------------------------------------------------------------------------------
\section{Suporte a Programação Concorrente}

	{\em Threads} de uma mesma {\em task} cooperam através do compartilhamento do segmento de dados e se sincronizam através do mecanismo de semáforos descrito anteriormente. {\em Threads} de {\em tasks} distintas cooperam através do compartilhamento de segmentos lógicos de memória e do compartilhamento de semáforos.

	O compartilhamento de segmentos lógicos é feito através do mecanismo de paginação, que pode mapear uma mesma página em mais de um espaço de endereçamento.  Com o compartilhamento de memória, torna-se possível a comunicação entre {\em threads} de {\em tasks} distintas. Um exemplo de compartilhamento de página pode ser visto na figura \ref{pageshare}.

\putpict{pageshare.ps}{9}{4}{Compartilhamento de páginas entre {\em threads} de {\em tasks} distintas.}{pageshare}

	O compartilhamento de semáforos é inteiramente suportado pelo ambiente, uma vez que está fortemente atrelado à gerência de processos.

%-------------------------------------------------------------------------------
% FUTURAS IMPLEMENTAÇÕES
%-------------------------------------------------------------------------------
\section{Futuras Implementações}

	O ambiente proposto foi desenvolvido com cuidados especiais no que diz respeito à portabilidade. Tentou-se evitar ao máximo a programação {\em assembly}, dando-se preferência à linguagem C. Além disso, trechos de código dependentes do i486 foram isolados. Isto permite vislumbrar a migração do ambiente para um processador RISC, possivelmente o Power PC ou o Sparc.

	No momento está sendo desenvolvida uma versão do ambiente para utilização em automação, como ferramenta de suporte a {\em hardwares} dedicados. Esta versão deverá residir em uma EPROM de 64 Kbytes e deverá suportar multiprocessamento.

	Além disto, o grupo está trabalhando na consolidação dos mecanismos de comunicação do projeto Nó//, que visa a concepção de uma plataforma completa de programação paralela, incluindo a construção de um multicomputador \cite{cor93}. A inclusão dos mecanismos de comunicação ao ambiente dará origem ao {\em micro-kernel} que executará em cada nó do multicomputador.


%-------------------------------------------------------------------------------
%CONCLUSAO
%-------------------------------------------------------------------------------
\section{Conclusões}

	Este artigo descreveu um ambiente para execução de programas concorrentes no processador i486. O ambiente suporta um conjunto mínimo de abstrações: {\em tasks}, {\em threads}, segmentos paginados de memória, semáforos, tratadores de interrupções e portas de E/S. Desta forma, ele pode ser utilizado como plataforma para o desenvolvimento de um sistema operacional completo, ou pode ser utilizado diretamente pelas aplicações.

	Uma versão incial do ambiente está completamente operacional e vem se mostrando muito eficiente. Os testes realizados até o momento revelaram que o gerenciamento dos processos apresenta um bom desempenho, inserindo pouco {\em overhead} à execução dos processos. Além disso, a estratégia de páginação permite o compartilhamento de memória de forma eficiente.

	A principal dificuldade para avaliar-se o desempenho do ambiente é a ausência de sistemas similares. Comparar o ambiente a um sistema operacional completo seria irreal, uma vez que a complexidade dos {\em softwares} não é compatível. Mesmo a comparação com {\em micro-kernels} como o {\sc Mach} não seria real, pois ele inclui suporte a comunicação e a vários {\em drivers} de E/S dentro do {\em kernel}.


%-------------------------------------------------------------------------------
% REFERÊNCIAS BIBLIOGRÁFICAS
%-------------------------------------------------------------------------------
\begin{thebibliography}{WWW 88W}

\bibitem[ACC 86] {acc86} ACCETTA, M. et alli, {\it Mach: a New Kernel Foundation for UNIX Development}, Pittsburgh: Proceedings of the Summer 1986 USENIX Conference, julho de 1986.

\bibitem[AND 91] {and91} ANDREWS, G., {\it Concurrent Programming: Principles and Practice}, Redwood City: Benjamin/Cummings, 1991.

\bibitem[BAC 87] {bac87} BACH, M., {\it The Design of the UNIX Operating
System}, Englewood Cliffs: Prentice-Hall, 1987.

\bibitem[COR 93] {cor93} CORSO, T., {\it Ambiente para Programação Paralela em Multicomputador}, Florianópolis: UFSC/CTC/INE, 1993 (Relatório Técnico).

\bibitem[ENG 94] {eng94} ENGLER, D., KAASHOEK, M. \& O'TOOLE, J., {\it The Operating System Kernel as a Secure Programmable Machine}, In Proceedings of the Sixth SIGOPS European Workshop, September 1994.

\bibitem[INT 87] {int87} INTEL CO., {\it 80386 System Software Writer's Guide}, Santa Clara: Intel Corporation, 1987.

\bibitem[INT 90] {int90} INTEL CO., {\it 80486 Programmers Reference Manual}, Santa Clara: Intel Corporation, 1990.

\bibitem [LEF 89] {lef89} LEFFLER, S. at alli, {\it The Desing and Implementation of The 4.3 BSD Unix Operating System}, Reading: Addison-Wesley, 1989.

\bibitem[STE 92] {ste92} STEIN, B., {\it Projeto do Núcleo de um Sistema Operacional Distribuído}, Porto Alegre: UFRGS, 1992 (Dissertação de Mestrado).

\bibitem[TAN 92a] {tan92b} TANENBAUM, A., {\it The Amoeba Distributed Operating System}, Amsterdam: Vrije Universiteit, 1992 (Relatório Técnico).

\bibitem[TAN 92b] {tan92c} TANENBAUM, A., {\it Using Sparse Capabilities in a Distributed Operating System}, Amsterdam: Vrije Universiteit, 1992 (Relatório Técnico).

\end{thebibliography}

 
\end{document}

