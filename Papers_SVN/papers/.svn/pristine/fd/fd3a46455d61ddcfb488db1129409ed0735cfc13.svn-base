\documentclass[conference]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{struct_type}
\hypersetup{colorlinks=true,linkcolor=black,urlcolor=black}


\title{Improving Non-Functional Properties of Operating Systems by Reconfigurable Hardware
\thanks{This work was partly supported by the German Research Foundation (DFG)
 under grant no. SCHR 603/7-1 and SFB/TR 89.}}


\author{
Michael Gernoth\IEEEauthorrefmark{1},
Tiago Mück\IEEEauthorrefmark{2},
Alexander Würstlein\IEEEauthorrefmark{1},
Wolfgang Schr\"oder-Preikschat\IEEEauthorrefmark{1}\\

\IEEEauthorblockA{\IEEEauthorrefmark{1}Friedrich--Alexander University Erlangen--Nuremberg, Germany\\
{\tt \{gernoth, arw, wosch\}@cs.fau.de}}

\IEEEauthorblockN{\IEEEauthorrefmark{2}Software/Hardware Integration Lab\\
Federal University of Santa Catarina,
Florianopolis, Brazil\\
{\tt \{tiago\}@lisha.ufsc.br}}
}

\IEEEoverridecommandlockouts
\begin{document}

\maketitle

\section{Abstract}
\label{sec-1}

%\cite{teich-esm}
%\cite{ios-1841-fpga}
The increasing availability of cheap FPGAs gives rise to the question if and how operating systems can benefit from these means. So far, only applications in userspace (like video filters) or special dedicated algorithms in kernel space (like cryptography) make use of reconfigurable hardware.

Building hardware which operates on operating system internals presents the problem of getting access to the required data needed for its operation.
The host system has to transform internal data structures into a format understood by the hardware and write the result to the configuration interface of the hardware.
This induces overhead which can negate the benefits of using the hardware in the first place.

In this paper we propose a technique to build hardware which understands operating system internals and can adapt to changes in the system without adding overhead and complexity to the system software.

This allows us to implement services of an operating system as hardware blocks to gain additional, or improve on existing non-functional properties like performance, safety, security and determinism.

\section{Introduction}
\label{sec-2}

With the availavility of reconfigurable hardware which can be easily integrated into common computer systems, the question arises if this hardware can be reasonably used by the operating system.
If an operating system service can be easily migrateable to hardware, a deep integration of hardware into core operating system functionality becomes possible, providing additional non-functional properties\cite{lohmann:05:aosd-acp4is} to the system.

This is, in contrast to current approaches using reconfigurable hardware, for improving system performance.
%\cite{teich-esm}
%\cite{ios-1841-fpga}
These are usually used for specific userspace applications like video filters or algorithms from special domains (like cryptography) in kernel space.
Even ``reconfigurable operating systems'' like ReconOS\cite{lubbers:07:fpl} focus on using reconfigurable hardware to improve userspace applications by providing access to hardware threads to users.
These traditional approaches use specialized drivers which are tailored to the hardware and ``know'' how to interface the hardware with the system.

When trying to migrate a operating system service to hardware, this programming model no longer suffices and a more flexible interface to the hardware is needed.
Looking at the Linux kernel development makes it is obvious that there are no static interfaces in the core kernel code.
This results in every approach of using a fixed hardware interface as an interface to a kernel service to be immediately obsolete.

As a consequence of this, the only way of using reconfigurable hardware in the kernel is by adapting the hardware to the software and not the other way around.

This paper presents a novel way to aid the translation of a software feature to hardware and the automatic generation of interfaces for the resulting hardware which are dynamically adaptable to software changes.

\subsection{Motivation}

Integrating hardware into operating system kernels was not really feasible in the past, as building hardware meant designing and producing silicon chips with defined interfaces to the system software.
The operating system needed to transform internal data structures into formats understood by the hardware, tell the hardware to work on a given problem and transform the result computed by the hardware back into internal data-structures.
This overhead of transforming data structures needed to be done in the operating system, as fixed hardware can only be adaptive to small interface changes.

There is also the problem of different code bases for the software and hardware side of the interface, which could lead to subtle bugs in the implementation, not found when looking at either source base alone.

With the introduction of reconfigurable hardware, this problem of transforming data structures can be solved by adapting the hardware implementation to the operating system and not the other way around.
This also allows the hardware to operate on its own without being instructed by the system.
When hardware has an understanding of system internals, an efficient external manipulation of system state becomes possible.


%\subsection{Outline}
%
%In section blubb and section blah

\section{Improving Non-Functional Properties of Operating Systems}
\label{nfp}

An additional benefit of having reconfigurable hardware executing system services is the possibility to improve the non-functional properties of the system.
Traditionally, desktop systems put their focus on drastically different properties than embedded systems which are used in safety critical applications.
With the addition of hardware, some properties from one domain can be made available in another.
A few examples of these non-functional properties and their respective focus are:

\begin{enumerate}
	\item Performance: Perceived overall speed of the system. Desktop systems focus on this property e.g. to improve the user experience to provide a smooth desktop experience.

	\item Safety: The system does not harm its environment. E.g. when an unexpected event occurs, the system enters a predefined safe state. Embedded systems in safety critical areas (like engine-control ECUs) focus on this property.

	\item Security: Security policies like access-control lists or capabilities are enforced by the system providing data integrity, confidentiality and availability of the system in case of atttacks. This property is pronounced in server- and multiuser-systems.

	\item Determinism: The system follows a predefined execution plan, so the cause for each action of the system can be determined, be it the scheduling of a task or the reaction to events from the surrounding environment. Real-Time Systems are an example of systems focusing on this property.
\end{enumerate}

Current operating systems focus on optimally achieving only a subset of these properties, because the addition of more properties leads to conflicts with existing properties by inducing additional overhead or complexity.

If a current operating system allows the user to change its non-functional properties, this is done by techniques like pre-processor macros\cite{tartler:10:osdi-poster} or AOP\cite{lohmann:09:usenix}.

\section{Integrating Hardware in the Operating System Core}

The overhead of additional properties in an operating system (as described in section \ref{nfp}) can be drastically reduced by having (reconfigurable) hardware implement an operating system service providing the property.
This reconfigurable hardware should have direct access to the hosts memory and the ability to send interrupts to the CPU when interaction with the operating system becomes necessary.
Due to these requirements, an FPGA connected to the PCI or PCI-Express bus seem like an ideal choice to provide the integration of reconfigurable hardware into an operating system.

\subsection{Solving the interface-problem\label{sec-solving-interface-problem}}

Moving operating system code to hardware blocks has the disadvantage that the operating system still needs to convert data into a representation understood by the hardware implementation.
This includes converting internal data structures into a format understood by the hardware by resolving all indirections and writing the result into dedicated configuration registers.
When the overhead and added complexity induced by these operations is taken into account, this type of integration rapidly loses its appeal.

To help with this problem of interfacing hardware with software, we adapt the hardware to the operating system and not the operating system to the hardware.
In order to achieve this goal, we extract the memory layout of internal operating system structures by looking at object-files including debugging informations produced during compilation of the operating system kernel.
The \textit{DWARF} debugging format used by \textit{gcc} and other compilers contains enough information to produce HDL code for accessing the structures referenced in the object and can provide means to adapt the hardware to inner changes of the system.

\subsection{The dwarf2vhdl Tool}

We have implemented the idea from section~\ref{sec-solving-interface-problem} in a tool we call \textit{dwarf2vhdl}, which reads in an object file with \textit{DWARF} debug symbols and generates \textit{VHDL}-code to access the individual members of referenced data structures.
This code can then be used to access the contents of these structures by utilizing \textit{DMA}-transfers from the main memory to the FPGA card.
Computed results can be transferred back to the appropriate memory location in the same way.
This all happens without the host system needing to prepare the data and initiating the execution of the hardware service.

\begin{lstlisting}[language=C,
			numbers=left,
			numberstyle=\tiny,
			stepnumber=2,
			numbersep=5pt,
			basicstyle=\small,
			caption={Simple C struct},
			captionpos=b,
			label=c-struct]
struct struct_sample {
  unsigned short flags;
  char info[2];
  char *data;
};
\end{lstlisting}

\begin{figure}
\begin{center}
\begin{struct}[4]{7}
%struct struct_sample: 3
\member{0.000}{2.000}{blue!20}{unsigned short flags};
\member{2.000}{2.000}{green!20}{char info[2]};
\member{4.000}{4.000}{yellow!20}{char *data};
\end{struct}
\end{center}
\caption{Memory layout of \textbf{struct sample}\label{fig-mem-layout}}
\end{figure}

Listing \ref{c-struct} gives an example of a very simple structure with just three members, each being 16 or 32 bit long (on a 32 bit architecture).
The memory layout of this simple structure is shown in Figure~\ref{fig-mem-layout}.
When this structure is converted to VHDL with \textit{dwarf2vhdl}, code as shown in Listing \ref{vhdl-struct} is generated.

\begin{lstlisting}[language=VHDL,
			numbers=left,
			numberstyle=\tiny,
			stepnumber=2,
			numbersep=5pt,
			basicstyle=\small,
			breaklines=true,
			caption={Struct from Listing~\ref{c-struct} converted to VHDL},
			captionpos=b,
			label=vhdl-struct]
entity struct_sample is port (
  signal flags_i: in std_logic;
  signal info_i: in std_logic;
  signal data_i: in std_logic;

  signal base_addr_i: in std_logic_vector(31 downto 0);
  signal addr_o: out std_logic_vector(31 downto 0);
  signal clk_i: in std_logic
  );
end entity struct_sample;

architecture struct_sample__arch of struct_sample is
begin
  process (clk_i)
  begin
    if (clk_i'event and clk_i = '1') then
      if (flags_i = '1') then
        addr_o <= base_addr_i + 0 + 0;
      elsif (info_i = '1') then
        addr_o <= base_addr_i + 0 + 2;
      elsif (data_i = '1') then
        addr_o <= base_addr_i + 0 + 4;
      else
        addr_o <= base_addr_i;
      end if;
    end if;
  end process;
end architecture struct_sample__arch;
\end{lstlisting}

This generated interface consists of a declaration of input- and output signals (lines \textit{2} -- \textit{8}) and a hardware representation of the memory layout of the structure (lines \textit{12} -- \textit{28}).
The generated signals in this example are:
\begin{itemize}
	\item \verb|flags_i|, \verb|info_i| and \verb|data_i| (lines \textit{2} -- \textit{4}): Inputs selecting which member of a structure should be accessed. By setting one of these inputs to \textit{high}, the address of the corresponding member is calculated.
	\item \verb|base_addr_i| (line \textit{6}): 32 bit input for the base-address of the structure. This can either be a static address determined during compilation of the kernel or a dynamic address obtained by following pointers from other structures.
	\item \verb|addr_o| (line \textit{7}): 32 bit output providing the address of the reqeuested struct-member. This address can then be used to access the member in-memory by using DMA-transfers.
	\item \verb|clk_i| (line \textit{8}): Input providing a clock-signal. This eliminates undefined states of the output-signals by clocking on the rising edge.
\end{itemize}

\begin{lstlisting}[language=VHDL,
			numbers=left,
			numberstyle=\tiny,
			stepnumber=2,
			numbersep=5pt,
			basicstyle=\small,
			caption={conversion of nested structures in the Linux task\_struct to VHDL},
			captionpos=b,
			label=vhdl-task-struct]
elsif (se_group_node_i = '1') then
  addr_o <= base_addr_i + 44 + 20;
elsif (se_group_node_next_i = '1') then
  addr_o <= base_addr_i + 64 + 0;
elsif (se_group_node_prev_i = '1') then
  addr_o <= base_addr_i + 64 + 4;
elsif (se_on_rq_i = '1') then
  addr_o <= base_addr_i + 44 + 28;
elsif (se_exec_start_i = '1') then
  addr_o <= base_addr_i + 44 + 32;
\end{lstlisting}

Applying our tool to a more complex structure containing nested structures and a nested linked list (\verb|struct sched_entity| contains the list \verb|struct list_head group_node|) is (partially) shown in Listing~\ref{vhdl-task-struct}, which is a part of the Linux-kernel process-structure \verb|struct task_struct|. 
This is a structure with 127 members (in Linux 2.6.32.15) which is correctly converted by \textit{dwarf2vhdl} to VHDL code.

After generating the interfaces with \textit{dwarf2vhdl}, they can be connected to other hardware blocks implementing the corresponding service and providing access to the main memory.
Even if the layout of a structure changes, in most cases only the automatic regeneration of the interface becomes necessary and the hardware implementation can be left untouched.
This is very useful when accessing structures which are in a constant flow of changes, where most changes are not affecting the functionality required by the hardware but change the memory-layout (like \verb|struct task_struct| in Linux, which changes with most released kernel versions).
With this ability it is possible to integrate hardware services into highly dynamic systems with ever-changing interfaces like the Linux kernel.

\section{Prototypical Implementation}

In our research we are using a PCI connected FPGA board\footnote{Raggedstone-1 from Enterpoint, containing an Xilinx XC3S1500} to show the practical applicability of our research to the Linux and EPOS\footnote{\url{http://epos.lisha.ufsc.br/}} kernel.
The FPGA is directly connected to the PCI bus of the host system, with no additional bridge-chips in between.

The choice of using the PCI bus in contrast to the PCI-Express bus is caused by the availability of a high quality open source PCI core\footnote{\url{http://opencores.org/project,pci}} with bus-master DMA functionality, which can be configured to suit our requirements.
Equivalent cores for PCI-Express are currently not available under those terms, so the decision for PCI was made, even though the decreased latency and increased bandwith of the PCI-Express bus would be beneficial.
Nevertheless, our work should be easily adaptable to PCI-Express once an open-source core implementing the wishbone interface\cite{wishbone:10:specification} becomes available.

This is currently all work in progress, so that's it for now. More to come...

%\subsection{Semaphore (EPOS)}
%
%As a first example of providing non-functional properties in hardware we have implemented a sempahore aspect in the EPOS\footnote{\url{http://epos.lisha.ufsc.br/}} operating system as a hardware block on our reference hardware to show the viability of our approach using a PCI connected FPGA to execute operating system functions.
%This implementation does not use an automatically generated interface between the operating system and the hardware implementation but an explicit programming interface of the semaphore using control registers in the FPGA.
%
%TODO: Results from Tiago

\subsection{Scheduler (EPOS/Linux)}

%EPOS scheduler, register
%
%Linux-scheduler hand coded process walk, automatic interface generation

\subsection{Security (Linux)}

%Linux security modules in hardware, not being influenced by software attacks, can check if hooks are still in kernel code, more policy decisions based on the environment.

\subsection{Routing (Linux)}

%Linux-kernel routing table access
%
%IOS TCAM explicit programming, complex transformation algorithms
\cite{liu:02:ieee-micro}

\subsection{Current status}

%generated hardware is able to read kernel structures and follow linked lists in Linux
%
%manual implementation of functionality
%
%semaphore / scheduler in EPOS
%
%deterministic run time
%
%unaffected by external signals
%
%latency is a problem, PCI bus transaction are slower than current implementations, PCI-E could help. see hardware section
%
%current approach not suited for transforming basic os functionality (like semaphores) to hardware on a general purpose system (latency)

\section{Related work}

\cite{guo:06:fpl}
\cite{guo:05:date}

%EPOS - interface zur hardware ist von hardware vorgegeben - register!
%
%scenario adapters / AOP
%Scenario adapters - still manual interfacing, but same interfaces for hw/sw
%
%AOP - really working for synthesis, how to weave interfaces?
%
%ReconOS
\cite{lubbers:07:fpl}

\section{Future work}

This paper describes the automatic generation of hardware adapting to operating systems.
We are also working on automating the task of transforming operating system code to hardware blocks.
For this we are extending the \textit{ROCCC}\cite{guo:05:date} compiler to cope with operating system source code and generate hardware blocks from Linux kernel source code.

\section{Conclusion}
\label{conclusion}
%Work in progress
%
%Generating interfaces from object code seems like a viable approach
%
%Problems in EPOS with C++...
%
%Linux works somehow

\bibliographystyle{plain}
\bibliography{bib/macros-short,bib/all}

\end{document}
