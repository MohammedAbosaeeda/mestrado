\documentclass[portuguese,a4paper,12pt]{article}

\usepackage{sbc2003}
\usepackage{graphicx,url}
\usepackage{epsfig}

\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

\usepackage[tmargin=3.0cm, bmargin=2.5cm, lmargin=2.5cm, rmargin=2.5cm,nohead]{geometry} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinelanguage{XML} {
  keywords={xml,version,DOCTYPE,SYSTEM,EPOSConfig,family,member,name,type,
  default,pos,pre}}
\lstdefinestyle{prg} {basicstyle=\small\sffamily, lineskip=-0.2ex}
\lstdefinestyle{prgbox} {basicstyle=\small\sffamily lineskip=-0.2ex}
\lstdefinestyle{inlineprg} {basicstyle=\small\sffamily}

\newcommand{\fig}[3][htbp]{
  \begin{figure}[#1] {\centering{\includegraphics{fig/#2}}\par}
    \caption{#3\label{fig:#2}}
  \end{figure}
}

\newcommand{\prg}[4][h]{
  \begin{figure}[#1]
    \vspace{\parskip}
    \framebox[\textwidth][c]{
      \lstinputlisting[language=#2,style=prg,
                       basicstyle=\fontfamily{pcr}\fontseries{m}\selectfont\footnotesize
                      ]{prg/#3.prg}}
    \vspace{0.3\parskip}
    \caption{#4\label{prg:#3}}
  \end{figure}
}

\newcommand{\inlineprg}[2][C++]{
  \vspace{\parskip}
  \noindent\makebox[\textwidth][c]{
    \begin{lstlisting}[language=#1,style=inlineprg]{}
      ^^J #2
    \end{lstlisting}}
  \vspace{0.3\parskip}
}

\def\textprg{\lstinline[language=C++,style=inlineprg]}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\sloppy

\title{Portabilidade em Sistemas Operacionais Baseados em Componentes de Software}

\author{Fauze Valério Polpeta\inst{1}, Antônio Augusto Fröhlich\inst{1}\\
        Arliones Stevert Hoeller Júnior\inst{1}, Tiago Stein D´Agostini\inst{1}}

\address{Laboratório de Integração Software e Hardware -- 
         Universidade Federal de Santa Catarina\\
         PO Box 476\\
         88049-900 Florianópolis - SC, Brazil\\
         \texttt{\{fauze,guto,arliones,tiago\}@lisha.ufsc.br}\\
         \texttt{http://www.lisha.ufsc.br/$\sim$\{fauze,guto,arliones,tiago\}}
}

\begin{document}

\maketitle

\begin{abstract}
In this article we elaborate on portability in component-based
operating systems, focusing in the \emph{hardware mediator} construct
proposed by Fröhlich in the \emph{Application-Oriented System Design}
method. Differently from hardware abstraction layers and virtual
machines, hardware mediators have the ability to establish an
interface contract between the hardware and the operating system
components and yet incur in very little overhead when comparing to
traditional portability approaches.
  
The use of hardware mediators in the \textsc{Epos} system corroborates
the portability claims associated to the techniques explained in this
article, for it enabled \textsc{Epos} to be easily ported across very
distinct architectures, such as the \texttt{IA-32} and the
\texttt{H8}, without any modification in its software components.
\end{abstract}

\begin{resumo}
Este artigo apresenta um estudo realizado sobre portabilidade em
sistemas operacionais baseados em componentes de software. Tem como
principal foco \emph{mediadores de hardware}, um artefato de software
proposto por Fröhlich em sua metodologia \emph{Application Oriented
System Design}. Diferentemente de camadas de abstração de hardware e
máquinas virtuais, mediadores de hardware permitem que seja
estabelecido um contrato de interface entre o hardware e os
componentes do sistema operacional, garantindo a indepência
de plataforma sem \emph{overhead} significativo quando comparado aos
mecanismos tradicionais de portabilidade.

O uso de mediadores de hardware no sistema \textsc{Epos} permite
comprovar o grau de portabilidade associado às técnicas apresentadas
neste artigo, visto que este sistema foi facilmente portado para
arquiteturas distintas como \texttt{IA-32} e \texttt{H8} sem que
qualquer modificação nos componentes do sistema operacional fosse
realizada.
\end{resumo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}

Portabilidade é tópico importante no desenvolvimento de sistemas
operacionais devido à natureza comum que estes sistemas possuem de
abstrair o hardware para que programadores produzam aplicativos
independentes de plataforma. Espera-se que um aplicativo desenvolvido
sobre um dado sistema operacional seja executado sem qualquer
modificação em todas as arquiteturas suportadas por este
sistema. Logo, sistemas operacionais constituem um dos pilares
centrais da portabilidade de aplicativos de software, o que
caracteriza a própria necessidade de serem também portados para
diversas plataformas.

%Estratégias tradicionais que garantem a portabilidade de sistemas
%operacionais estão concentradas essencialmente em dois flancos:
%\emph{Máquinas Virtuais}~(VM) e \emph{Camadas de Abstração de Hardware}~(HALs).
%Considerando a primeira estratégia, deve-se ressaltar que a máquina
%virtual está intrinsicamente ligada ao sistema operacional,
%constituindo parte dele---de acordo com Habermann, o sistema
%operacional se estende do hardware à
%aplicação~\cite{Habermann:1976}. Desta forma, a máquina virtual
%constitui a porção do sistema operacional que é dependente de
%plataforma, ao passo que provê portabilidade para os componentes sobre
%ela implementados. A principal deficiência deste mecanismo é o
%\emph{overhead} gerado nas operação de tradução de código
%intermediário para código nativo.

%arliones
São duas as estratégias mais usadas de modo a garantir portabilidade
em sistemas operacionais: \emph{Máquinas Virtuais}~(VM) e
\emph{Camadas de Abstração de Hardware}~(HALs). Máquinas Virtuais
estão intrinsicamente ligadas ao sistema operacional, constituindo
parte dele---Habermann afirma que o sistema operacional se estende do
hardware à aplicação~\cite{Habermann:1976}. Desta forma, a VM
constitui a porção do sistema que é dependente de plataforma, ao passo
que provê portabilidade para os componentes sobre ela implementados. A
principal deficiência deste mecanismo é o \emph{overhead} gerado nas
operações de tradução de código intermediário para código nativo.

A segunda estratégia basea-se em camadas de abstração de hardware, as
quais constituem um substrato dependente de arquitetura que encapsula
detalhes específicos da plataforma e disponibiliza para o sistema
operacional, através de uma interface comum de acesso, os recursos da
plataforma. Ainda que não gerem o mesmo \emph{overhead} gerado pelas
máquinas virtuais, técnicas refinadas de implementação devem ser
utilizadas na construção de HALs a fim de prover uma performance
satisfatória.

Um problema adicional associado a estes dois mecanismos está
relacionado ao projeto. Sem uma estratégia adequada de engenharia de
domínio é muito comum que VMs e HALs encorporem detalhes arquiteturais
da plataforma para a qual foram inicialmente planejadas, o que torna
difícil adaptá-las em outras plataformas. Esta é, por exemplo, a razão
provável de sistemas operacionais de propósito geral e providos de um
sistema complexo de gerência de memória (e.g. \textsc{Unix} e
\textsc{Windows}), ficarem descaracterizados quando portados para
arquiteturas de 8-bits.

Recentemente, estratégias de desenvolvimento de sistemas operacionais
baseados em componentes de software têm sido
elaboradas~\cite{Baum:1999,Constantinides:2000,Froehlich:2001},
possibilitando que sistemas operacionais distintos como
\textsc{Epos}~\cite{Froehlich:sbac:1999} e
\textsc{Pure}~\cite{Schoen:1998} tomem forma. Fruto de um processo de
engenharia de domínio (e não engenharia de sistema), os componentes de
software destes sistemas podem ser organizados de modo que uma grande
variedade de sistemas para suporte em tempo de execução
(\emph{run-time}) surjam. Especificamente, a metodologia
\emph{Application-Oriented System Design}~(AOSD) proposta por
Fröhlich~\cite{Froehlich:2001}, combina princípios de
\emph{Programação Orientada a Objetos}~(POO)~\cite{Booch:1994} com
\emph{Programação Orientada a Aspectos}~(POA)~\cite{Kiczales:1997} e
\emph{Metaprogramação Estática}~(MPE)~\cite{Czarnecki:2000} de maneira
a guiar o desenvolvimento de componentes de software altamente
adaptáveis no domínio de sistemas operacionais.

Esta nova classe de sistemas operacionais orientados a aplicação têm a
mesma necessidade de portabilidade dos sistemas operacionais
tradicionais, entretanto, a combinação de \textsc{POA} e \textsc{MPE}
conduz para uma nova forma de implementação de VMs e HALs:
\emph{mediadores de hardware}. Basicamente, um mediador de hardware é
um artefato de software que encapsula um componente de hardware de
maneira que sua interface seja definida no contexto de sistemas
operacionais. Este conceito assemelha-se aos elementos de uma HAL, mas
o uso de \textsc{POA} e \textsc{MPE} garante que mediadores de
hardware sejam muito mais flexíveis e apresentem melhor performance.

%Este artigo define, no âmbito de AOSD, que mediadores hardware são um
%poderoso mecanismo para a garantia de portabilidade em sistemas
%operacionais. Após traçar um paralelo entre as estratégias de
%portabilidade comumente usadas pelos sistemas operacionais
%tradicionais, o conceito de mediadores de hardware é apresentado em
%detalhes, seguido de um estudo de sua aplicabilidade no sistema
%\textsc{Epos}. O artigo é finalizado com uma exposição de trabalhos
%futuros e perspectivas dos autores.

%tiago
Este artigo define, no âmbito de AOSD, que mediadores de hardware são
um mecanismos para a garantia de portabilidade em sistemas
operacionais. Após traçar um paralelo entre estratégias de
portabilidade usadas por sistemas operacionais tradicionais, o
conceito de mediadores de hardware é apresentado, seguido de um estudo
de seu uso no sistema \textsc{Epos}.
%O artigo é finalizado com uma exposição de trabalhos futuros e 
%perspectivas dos autores.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Portabilidade em Sistemas Operacionais Tradicionais}

Sistemas operacionais, como discutido na introdução deste artigo,
constituem um dos principais artefatos para a viabilização da
portabilidade de software, escondendo as dependências arquiteturais
através de interfaces padronizadas como \textsc{Posix}. Um sistema
operacional projetado adequadamente permite que aplicações possam
acompanhar a rápida evolução do hardware computacional sem maior
impacto. Conseqüentemente, estar apto para portar um sistema
operacional para uma nova plataforma de hardware vem a ser um ponto
estratégico para a indústria de software.

%Na década de setenta, o sistema operacional \textsc{VM/370}\footnote{A
%literatura técnica freqüentemente refere-se ao \textsc{VM/370} da IBM
%também como \textsc{CP/CMS}.} da \textsc{IBM}~\cite{Case:1978} foi 
%inicialmente associado ao conceito de portabilidade. Com o objetivo de 
%viabilizar em seu ambiente a execução de aplicações de lote 
%desenvolvidas para sistemas mais antigos, a \textsc{IBM} optou por 
%introduzir suporte multi-tarefa no \textsc{VM/370}. Este suporte, 
%fundamentou-se em um esquema de máquinas virtuais onde cada aplicação 
%recebia uma cópia ``real'' do hardware para ser executada. Com isto, 
%cada máquina virtual executava um sistema operacional que se adequasse a 
%cada aplicação. Entretanto, tendo em vista que a maioria das instruções 
%da máquina virtual eram, de fato, instruções nativas da plataforma e, 
%com isto, executadas diretamente pelo processador, o esquema apresentou
%boa performance; porém seu porte para outras arquiteturas, que não a
%\textsc{TSS/370}, foi inviabilizado.

%arliones
Na década de setenta, o sistema operacional
\textsc{VM/370}\footnote{Também referenciado como \textsc{CP/CMS}.} da
\textsc{IBM}~\cite{Case:1978} foi associado ao conceito de
portabilidade. Objetivando a execução de aplicações desenvolvidas para
sistemas antigos, a \textsc{IBM} introduziu suporte a multi-tarefa em
seu sistema. Este suporte foi fundamentado num esquema de máquinas
virtuais, onde cada aplicação recebia uma cópia ``real'' do hardware
para ser executada. Assim, cada máquina virtual executava um sistema
operacional que se adequase à aplicação. Embora tivesse bom
desempenho, já que a maioria das instruções da máquina virtual eram
instruções nativas da plataforma, seu porte foi, por isto,
inviabilizado para outras arquiteturas.

%No entanto, o conceito que define máquina virtual (ou abstrata) vai
%além do esquema introduzido pelo \textsc{VM/370}. Sabe-se que qualquer
%camada de software que estende a funcionalidade ou constitui um nível
%de abstração de um sistema computacional pode ser caracterizada como
%uma \emph{máquina virtual}. Um compilador para linguagens de alto
%nível que traduz código-fonte para instruções de máquina pode ser visto
%como uma máquina virtual~\cite{Wirth:1992}. Isto poderia levar-nos a
%concluir que a simples escolha de uma linguagem de programação
%universal---como \textsc{C}, para a qual existem inúmeros
%compiladores---para implementar o sistema operacional poderia resolver
%toda a questão de portabilidade. Isto, definitivamente, não pode ser
%afirmado: primeiro, porque linguagens de alto-nível não dispõem de
%todos os recursos necessários para interagir com o hardware, o que
%força programadores a escrever código nativo (e.g. \emph{assembly})
%não traduzível para novas arquiteturas; e em segundo, o fato de que
%\emph{drivers} de dispositivos (i.e. \emph{device drivers}) são
%usualmente específicos para uma dada plataforma e não podem ser
%automaticamente convertidos (e.g. um driver \textsc{IDE} não pode ser
%convertido automaticamente para um \textsc{SCSI}).

%arliones
Contudo, o conceito de máquina virtual (ou abstrata) vai além do
esquema introduzido pelo \textsc{VM/370}. Sabe-se que qualquer
software que estende a funcionalidade ou constitui um nível de
abstração de um sistema computacional pode ser caracterizada como uma
\emph{máquina virtual}. Um compilador para linguagens de alto nível
que gera instruções de máquina pode ser visto como uma máquina
virtual~\cite{Wirth:1992}. Isto poderia levar-nos a concluir que a
simples escolha de uma linguagem de programação universal---como
\textsc{C}, para a qual existem inúmeros compiladores---para
implementar o sistema operacional resolveria toda a questão de
portabilidade. Isto, definitivamente, não pode ser afirmado: primeiro,
porque tais linguagens não dispõem de todos os recursos necessários
para interagir com o hardware, exigindo que código-nativo
(i.e. \emph{assembly}) seja usado; e em segundo, o fato de
\emph{drivers} de dispositivos serem usualmente específicos, os
impossibilita de serem automaticamente convertidos (e.g., a conversão
de um \emph{driver} \textsc{IDE} em um \textsc{SCSI} não é
automática).

%Mesmo que linguagens de programação não possam garantir exclusivamente
%a portabilidade de sistemas operacionais, são, em verdade, cruciais
%para que isto seja alcançado. Através de uma linguagem de programação
%portável e do isolamento das dependências arquiteturais em uma
%\emph{camada de abstração de hardware}, projetistas de sistema
%operacionais têm a chance de desenvolver sistemas portáveis. O sistema
%\textsc{Unix}~\cite{Thompson:1974} foi um dos primeiros sistemas a usar 
%este mecanismo. Como descrito por Miller~\cite{Miller:1978}, portá-lo
%da arquitetura para a qual foi originalmente implementado, um
%\textsc{PDP}, para um \textsc{Interdata}, foi consideravelmente simples 
%e intimamente concentrado na implementação da nova \textsc{HAL}. Esta
%estratégia de portabilidade é até hoje adotada por muitos sistemas
%operacionais; incluso os descendentes do próprio
%\textsc{Unix} e os da família \textsc{Windows}.

%tiago -- pequenas mudanças.. poupa uma linha
Mesmo que linguagens de programação não garantam por si só a
portabilidade, são, em verdade, cruciais para que isto seja
alcançado. Através de uma linguagem de programação portável e do
isolamento das dependências arquiteturais em uma
\emph{camada de abstração de hardware}, projetistas de sistema
operacionais têm maior chance de desenvolver sistemas portáveis. O
sistema \textsc{Unix}~\cite{Thompson:1974} foi um dos primeiros
sistemas a usar este mecanismo. Como descrito por
Miller~\cite{Miller:1978}, portá-lo da arquitetura para a qual foi
originalmente implementado, um \textsc{PDP}, para um
\textsc{Interdata}, foi consideravelmente simples e concentrado na
implementação da nova \textsc{HAL}. Esta estratégia de portabilidade é
até hoje adotada por muitos sistemas operacionais; incluso os
descendentes do próprio \textsc{Unix} e os da família
\textsc{Windows}.

Avanços recentes na duas frentes podem ser representados
respectivamente pela \textsc{Máquina Virtual Java}~(JVM) e pelo
\textsc{Exokernel}. Sistemas como o \textsc{JavaOS}~\cite{Madany:1996}, 
desenvolvido pela Sun Microsystems, têm promovido a \textsc{JVM} como
um atraente mecanismo de portabilidade, mas não diferente de qualquer
outro sistema baseado em máquinas virtuais, ela abstrai todos os
detalhes do hardware devendo ser reimplementada para cada nova
plataforma. Quanto ao \textsc{Exokernel}~cite{Engler:1995}, eliminando
as noções de abstração do sistema operacional para prover formas de
controlar os recursos do sistema através de um ambiente multi-usuário
seguro, este sistema comprometeu sua portabilidade diante da
dificuldade em abstrair em sua reduzida interface a diversidade de
dispositivos existentes nas plataformas~\cite{Kaashoek:1997}.
%Entretanto, a diversidade de dispositivos em cada plataforma
%de hardware impõe inúmeras restrições e dificuldades para com o
%estabelecimento da interface do \textsc{Exokernel}, e portanto
%compromete sua portabilidade~\cite{Kaashoek:1997}.

Todavia, ambas as estratégias têm se tornado fator limitante para o
atendimento dos requisitos das técnicas de engenharia de software
utilizadas no projeto de sistemas operacionais modernos. O projeto
destes artefatos tradicionais de portabilidade esteve sempre ligado à
necessidade de tornar todos os recursos de uma dada plataforma de
hardware disponíveis para um dado sistema operacional. Porém, associar
o projeto a uma plataforma específica faz com que o sistema
operacional tenha dependências desnecessárias, limitando a
reusabilidade e a própria portabilidade do mesmo. Objetivando entender
como estas depedências passam a existir no sistema, consideremos o já
bem conhecido esquema de gerência de memória~\cite{Bach:1987} usado
pelo \textsc{Unix}\footnote{Um esquema similar é também usado pelo
\textsc{Windows}, logo a ``crítica'' poderia a princípio ser estendida
ao cenário geral de sistemas operacionais \emph{desktop}}.

No sistema \textsc{Unix}, a chamada de sistema \texttt{brk} é
utilizada por processos para modificar o tamanho de seu segmento de
dados, mais especificamente, utilizada pelas funções \texttt{malloc} e
\texttt{free} da biblioteca \texttt{libc} para gerenciar o segmento
\emph{heap} de um processo. Sua implementação presume a existência de
uma \textsc{MMU} em hardware como suporte a sua estratégia de
gerenciamento de memória baseada em \emph{paginação}. Logo,
implementar \texttt{brk} sem uma \textsc{MMU} seria impraticável pois
implicaria em um processo de relocação dinâmica. Conseqüentemente, a
\textsc{HAL} do sistema \textsc{Unix} inclui um mecanismo de alocação
paginada, o que torna este sistema atraente quando pensamos em um
ambiente multi-tarefa, mas compromete severamente sua portabilidade
para uma plataforma que não dispõe de uma \textsc{MMU}\footnote{Um
design melhor planejado, que elimina esta dependência, será
apresentado na seção~\ref{sec:epos}.}

%Eliminar dependências arquiteturais deste tipo, que trazem para dentro
%da \textsc{API} do sistema as características intrínsicas do hardware
%presentes nas \textsc{HALs}, é fundamental para sistemas comprometidos
%com portabilidade e reusabilidade. Em particular aos sistemas
%embutidos, que hoje representam cerca de 98\% dos processadores no
%mercado~\cite{Tennenhouse:2000}, não se deve impor restrições como
%estas. Além disto, o fato de sistemas embutidos operarem
%freqüentemente com recursos restritos, o uso de \textsc{VM}s ou
%\textsc{HAL}s tendem a depreciar o sistema.

%tiago
Eliminar tais dependências arquiteturais é fundamental para sistemas
comprometidos com portabilidade e reusabilidade. Em especial nos
sistemas embutidos, que representam 98\% dos
processadores~\cite{Tennenhouse:2000}, onde a escassez de recursos
deprecia o uso de \textsc{VM}s e \textsc{HAL}s. Neste contexto, uma
\textsc{HAL} cujos componentes possam ser selecionados e adaptados de
acordo com a demanda da aplicação é fator determinante para a
portabilidade do sistema. A próxima seção introduz uma nova estratégia
para a garantia de portabilidade em sistemas baseados em componentes
de software.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mediadores de Hardware: Um Artefato de Portabilidade para 
         Sistemas Operacionais Baseados em Componentes}

% What is a HM
% How is it used
% Advantages of HM over traditional portability artifacts
% Limitations of HM

\emph{Mediadores de hardware} foram propostos por Fröhlich no
contexto de \emph{Application-Oriented System
Design}~\cite{Froehlich:2001} como um artefato de software que media a
interação entre os componentes do sistema operacional, sub-entendidos
como \emph{abstrações do sistema}, e os componentes do hardware. A
idéia principal que satisfaz o conceito de mediador não é a
constituição de camadas universais de abstração de hardware ou
máquinas virtuais, mas sim manter o \emph{``contrato de interface''}
entre sistema e máquina. Diferentemente das tradicionais
\textsc{HAL}s, mediadores de hardware não constituem uma camada
monolítica de encapsualmento de todos os recursos disponíveis em cada
plataforma. Cada componente do hardware é mediado via seu próprio
mediador, garantindo assim, a portabilidade das abstrações que o usam
sem gerar dependências desnecessárias. Adicionalmente, o fato de serem
metaprogramados, os levam a sua ``diluição'' no código das abstrações
na medida que o contrato de interface é atendido.
%Em outras palavras, um mediador de hardware
%entrega a funcionalidade de um hardware através de uma interface
%orientada pelas necessidades do sistema operacional e não pelas
%capacidades do hardware.

Tal como abstrações em \emph{Application-Oriented System Design},
mediadores são organizados em famílias cujos membros representam
entidades dentro de um domínio
específico(figura~\ref{fig:family}). Considere a família de mediadores
\texttt{CPU}, esta englobaria, por exemplo, membros dentre os quais
podemos destacar: \texttt{ARM}, \texttt{AVR8} e \texttt{PPC}. Já os
aspectos não funcionais e propriedades transversais são fatoradas como
\emph{aspectos de cenário}, podendo ser aplicados aos membros da
família quando requeridos. Exemplificando, famílias como \texttt{UART}
e \texttt{Ethernet} devem freqüentemente operar em modo de acesso
exclusivo, o que poderia ser realizado com o uso de um aspecto de
controle compartilhado entre as famílias.

\fig{family}{Uma família de mediadores de hardware.}

Outro importante elemento de mediadores de hardware são
\emph{configurable features}, as quais garantem que algumas
propriedades dos mediadores possam ser alteradas de acordo com as
necessidades das abstrações. Estas propriedades não estão restritas
somente a um flag de ativação ou desativação de um algum elemento do
hardware. A implementação de \emph{configurable features} usando
\emph{Programação Genérica}~\cite{Musser:1989} permite também que
algumas destas propriedades sejam implementadas em software através de
estruturas e algoritimos que fazem por suprir sem \emph{overhead}
significativo uma capacidade não avaliada no hardware. Um exemplo é
caracterizado pela geração de códigos \texttt{CRC} por uma
\emph{configurable feature} implementada junto ao mediador de um
dispositivo de comunicação \texttt{Ethernet}.

O uso de técnicas de \emph{Metaprogramação Estática} e
\emph{Programação Orientada a Aspectos} na implementação mediadores de
hardware acrescentam-lhes significante vantagem sobre os mecanismos
tradicionais baseados em HALs e VMs. A partir da definição do cenário
no qual o mediador será utilizado, é possível adaptá-lo para que
desempenhe seu papel sem compromentimento de sua interface e sem
acréscimo de código desnecessário.

No que se refere à implementação de mediadores de hardware, a
linguagem de programação \textsc{C++} provê poderosos recursos para a
meta-progamação estática, tais como classes e funções parametrizadas e
resolução de expressões constantes. Com isto, mediadores de hardware
podem ser implementados como classes parametrizadas cujos métodos são
declarados \texttt{inline} e embutem explicitamente instruções
\emph{assembly}. Com isto, o \emph{overhead} de chamadas de funções é 
eliminado e a performance é otimizada\footnote{Freqüetemente, as
otimizações realizadas por alguns compiladores \textsc{C++} é mais
eficiente que as equivalentes escritas a mão.}. A figura~\ref{prg:tsc}
ilustra a implementação do método \texttt{tsc} do mediador de
\texttt{CPU} para a arquitetura \texttt{IA-32}, que retorna o valor 
corrente do contador de tempo (i.e. time-stamp) da \textsc{CPU}. A
invocação deste método na forma \inlineprg{register unsigned long long
tsc = IA32::tsc();} produz uma única instrução de máquina:
\textprg!rdtsc!.

\prg{C++}{tsc}{Fragmento do mediador \textsc{CPU} para a arquitetura 
\texttt{IA-32}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Mediadores de Hardware no EPOS: Um Estudo de Caso}
\label{sec:epos}

% What is EPOS

%DETALHE DEMAIS DO EPOS! No máximo um parágrafo.. quem quiser saber mais leia o paper do Guto

O sistema \textsc{Epos}~(\emph{Embedded Parallel Operating System})
provê suporte operacional adequado para aplicações computacionais
dedicadas. Toma a metodologia \emph{Application-Oriented System
Desing} como base para o desenvolvimento de famílias de componentes de
software constituídas por abstrações independentes de cenário que,
através de adaptadores de cenário, são adaptadas em diferentes
ambientes de execução. Os componentes de cada abstração são
armazenados em um repositório e exportados através de interfaces
infladas~\cite{Froehlich:2001}, as quais, além de esconder do
programador as peculiaridades de cada membro utilizado na aplicação,
fazem com que toda a família seja vista como um único componente. Esta
estratégia, além de reduzir drasticamente o número de abstrações
exportadas, permite ao programador apresentar mais facilmente os
requerimentos de sua aplicação perante o sistema operacional.

%Uma aplicação planejada e implementada sob a filosofia proposta pelo
%sistema \textsc{Epos} pode ser submetida a um analisador que realiza
%uma análise sintática e de fluxo de dados que extrai requisitos da
%aplicação junto ao sistema operacional. Estes requisitos são então
%refinados em uma análise de dependências que é contraposta às
%características do cenário de execução, que é informado pelo usuário
%através de ferramentas de especificação visuais. Resumidamente, este
%processo define a geração de um sitema operacional orientado à
%aplicação.

% How HM are used in EPOS

% MMU Example

%A fim de preservar a portabilidade de seus componentes, o sistema
%\textsc{Epos} faz uso de mediadores de hardware e, a princípio,
%nenhuma de suas abstrações interage diretamente com o hardware. Um
%exemplo substancial pode ser encontrado nos componentes que compõe a
%gerência de memória no \textsc{Epos}. Todos os sistemas operacionais
%ditos portáveis esbarram no fato de que algumas plataformas de
%hardware possuem sofisticadas unidades de gerência de
%memória~(\textsc{MMU}), enquanto outras não provêm qualquer mecanismo
%para mapear e proteger espaços de endereçamento. Para a maioria destes
%sistemas isto é uma barreira inquebrável que se traduz na dificuldade
%de portá-los para plataformas que não dispõem de algum tipo de
%hardware para a gerência de memória. Um projeto cuidadoso de
%abstrações e mediadores garante aos componentes de gerência de memória
%do \textsc{Epos} a possibilidade de serem portados, idealmente, para
%qualquer plataforma, incluso microntroladores ``rudimentares'' como os
%das famílias \textsc{H8} e \textsc{AVR8}, ou até mesmo poderosos
%microprocessadores, como \textsc{IA-32} e \textsc{PowerPC}s.

Um exemplo substancial do uso de mediadores de hardware no
\textsc{Epos} é encontrado nos componentes que compõe a 
gerência de memória do sistema. Todos os sistemas operacionais ditos
portáveis esbarram no fato de que algumas plataformas de hardware
possuem sofisticadas unidades de gerência de memória~(\textsc{MMU}),
enquanto outras não provêm qualquer mecanismo para mapear e proteger
espaços de endereçamento. Para a maioria destes sistemas isto é uma
barreira inquebrável que se traduz na dificuldade de portá-los para
plataformas sem algum tipo de hardware para a gerência de memória. Um
projeto cuidadoso de abstrações e mediadores garante aos componentes
de gerência de memória a possibilidade de serem portados, idealmente,
para qualquer plataforma, incluindo microntroladores ``rudimentares''
como os das famílias \textsc{H8} e \textsc{AVR8}, ou até mesmo
poderosos microprocessadores, como \textsc{IA-32} e \textsc{PowerPC}s.

%A exemplo, a
%decisão pela troca de contexto tomada no escopo das abstrações de
%\texttt{Thread} para decidir qual será a próxima thread a ocupar a
%\textsc{CPU} tem as operações de salvamento e restauração de contexto 
%implementadas unicamente no mediador de \textsc{CPU}
%correspondente. Isto pode parecer óbvio, mas definir uma interface
%comum para estes mediadores se torna um tarefa difícil se consideramos
%a variabilidade destes dispositivos e os diferentes cenários em que
%são utilizados: \emph{multithread}, \emph{multitask},
%\emph{multiprocessor}, etc.

% The MMU example
%Um exemplo mais substancial pode ser encontrado nos componentes que
%compõe a gerência de memória no \textsc{Epos}. Todos os sistemas
%operacionais ditos portáveis esbarram no fato de que algumas
%plataformas de hardware possuem sofisticadas unidades de gerência de
%memória~(\textsc{MMU}), enquanto outras não provêm qualquer mecanismo
%para mapear e proteger espaços de endereçamento. Para a maioria destes
%sistemas isto é uma barreira inquebrável que se traduz na dificuldade
%de portá-los para plataformas que não dispõem de algum tipo de
%hardware para a gerência de memória. Um design cuidadoso de abstrações
%e mediadores garantem aos componentes de gerência de memória do
%\textsc{Epos} a possibilidade de serem portados, a princípio, para
%qualquer plataforma, incluso microntroladores rudimentares como os das
%famílias \textsc{H8} e \textsc{AVR8}, ou mesmo poderosos
%microprocessadores, como os \textsc{IA-32} e \textsc{PowerPC}s.

A principal decisão de projeto que garante a portabilidade do sistema
de gerência de memória do \textsc{Epos} é fundamentada no 
encapsulamento realizado pelo mediador da \texttt{MMU} dos detalhes
referentes à proteção do espaço de endereçamento, tradução de
endereços e alocação de memória. O sistema \textsc{Epos} inclui uma
abstração \texttt{Address\_Space}, que caracteriza-se como um
\emph{container} de ``pedaços'' de memória chamados
\emph{segmentos}. Esta abstração não implementa nenhuma proteção,
tradução ou alocação; na verdade delega estes deveres ao mediador da
\texttt{MMU}. Um membro particular da família \texttt{Address\_Space} 
chamado\texttt{Flat\_AS} define um modelo de memória onde endereços
físicos e lógicos são equivalentes, o que elimina a real necessidade
de um componente de hardware \texttt{MMU}. Este design é apresentado
na figura~\ref{fig:memory}, que adicionalmente mostra o fluxo de troca
de mensagens para a criação (1 e 2) de um segmento e sua anexação (3 e
4) ao espaço de endereçamento.

\fig{memory}{Componentes do gerente de memória no \textsc{Epos}.}

O mediador de \texttt{MMU} para uma plataforma que não dispõe dos
componentes de hardware correspondentes é, antes de tudo, um artefato
de construção simplificada, visto que seu uso implica no da abstração
\texttt{Flat\_AS}\footnote{No \textsc{Epos} regras de inferência 
são usadas para especificar as dependências entre componentes e
necessidades individuais de cada componente. Estas regras constituem
uma base de dados que é processada por ferramentas de configuração e
não aparecem no código fonte dos componentes.}. Com isto os métodos
que desempenham a anexação de segmentos de memória ao espaço de
endereçamento \emph{flat} tornam-se ``vazios'', visto que no modelo
\emph{flat} os segmentos são diretamente ``plugados'' aos 
seus endereços físicos. Já os responsáveis pela alocação de memória,
operam, em linhas gerais, de maneira similar à tradicional função
\texttt{malloc} da biblioteca \texttt{libc}. Para ilustrar este
exemplo, a figura~\ref{prg:mmu} apresenta fragmentos da implementação
do métodos \texttt{map} para duas arquiteturas singnificantes:
\textsc{H8} e \textsc{IA-32}.

\prg{C++}{mmu}{Método \texttt{map} do mediador \texttt{MMU} de 
arquiteturas \texttt{Intel IA-32} e \texttt{Hitachi H8.}}

O exemplo na figura~\ref{prg:mmu} mostra uma típica implementação do
método \texttt{map} para uma arquitetura provida de um mecanismo que
permite paginação em dois níveis (e.g. IA-32) como também para
plataformas que não possuem \textsc{MMU} (e.g. H8). Esta variabilidade
entre os membros de uma família de mediadores não afeta o contrato de
interface da família pois, conceitualmente, o modelo de memória
definido por \texttt{Flat\_AS} pode ser visto como uma degeneração do
modelo paginado onde o tamanho da página equivale a uma única palavra
e com tabelas de páginas mapeando endereços físicos e lógicos
diretamente.

%\prg{C++}{h8mmu}{Implementação do método \texttt{map} do mediador 
%\texttt{MMU} para a arquitetura \texttt{Hitachi H8}.}

% The UART example
Um fenômeno adicional e típico da programação em baixo-nível é
definido pelo tratamento realizado sobre um mesmo dispositivo
existente em diferentes plataformas. Por exemplo, supondo que um dado
dispositivo é parte integrante de duas plataformas de hardware, uma
que usa I/O programado (portas) e outra que usa I/O mapeado em
memória. Sendo este dispositivo uma \textsc{UART}, idêntica em ambas
as plataformas, é desejado que os procedimentos utilizados para
interagir com esta \textsc{UART} sejam os mesmos, o que portanto, 
tornaria o driver do dispositivo portável para ambas as plataformas. 
Através de mediadores de hardware metaprogramados, situações como esta 
podem ser resolvidas com a introdução de uma abstração denominada 
\texttt{IO\_Register}, que em tempo de compilação resolve os possíveis 
modos de acesso ao dispositivo. Um esboço desta abstração é
apresentado na figura~\ref{prg:io_reg}.
%Um esboço desta abstração, bem como 
%um simples exemplo de seu uso, são apresentados na figura~\ref{prg:io_reg}.

\prg{C++}{io_reg}{A implementação meta-programada de \texttt{IO\_Register}.}

%Um visão geral de como estão organizados os mediadores de hardware no
%sistema \textsc{Epos} é apresentada na figura~\ref{fig:epos_machine}.
%O mediador \texttt{Machine} representa a abstração de mais alto nível
%de uma plataforma de hardware. Compreende um conjunto de outros
%mediadores, dentre estes, o processador (\texttt{CPU}), o controlador
%de interrupção (\texttt{IC}), temporizadores (\texttt{TMR}), o relógio
%de tempo-real (\texttt{RTC}) e vários outros dispositivos.

%\fig{epos_machine}{O mediador de hardware \texttt{Machine} no 
%\textsc{Epos}.}

\section{Análise de Aplicabilidade de Mediadores}

Objetivando ilustrar a portabilidade alcançada com os mediadores de
hardware, uma mesma configuração do sistema \textsc{Epos} foi
instanciada para três arquitetura distintas: \textsc{IA-32},
\textsc{H8} e \textsc{PPC32}. Esta configuração incluiu suporte 
\emph{mono-task} com múltiplas threads em um ambiente cooperativo de 
execução. Alocação dinâmica de memória foi também introduzida no
sistema. A tabela~\ref{tab:compare} mostra o tamanho (em bytes) dos
segmentos relativos a cada imagem gerada.

\begin{table}[h]   
  \begin{center}
    \begin{tabular}{|l|r|r|r|r|}
      \hline
      \multicolumn{1}{|c|}{\textbf{Arq.} } & 
      \multicolumn{1}{|c|}{\textbf{.text}} & 
      \multicolumn{1}{|c|}{\textbf{.data}} &
      \multicolumn{1}{|c|}{\textbf{.bss} } & 
      \multicolumn{1}{|c|}{\textbf{total}} \\
      \hline
      IA-32 & 926 & 4 & 64 & 994 \\
      \hline
      H8 & 644 & 2 & 22 & 668 \\
      \hline
      PPC32 & 1.692  & 4 & 56 & 1.752 \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Tamanho (em bytes) da imagem do sistema \textsc{Epos} 
           para três arquiteturas.\label{tab:compare}}
\end{table}

Os dados mostrados na tabela~\ref{tab:compare} ilustram a adequação do
sistema como suporte a aplicações embutidas, tendo como consideração o
baixo \emph{overhead} do código gerado. Todas as três instâncias foram
geradas a partir dos mesmos componentes de software (abstrações), mas
usando mediadores de hardware particulares. Os diferentes tamanhos
para o segmentos \texttt{.text}, \texttt{.data} e \texttt{.bss}
decorrem dos diferentes formatos de instruções e tamanho de palavra
das arquiteturas.

Uma análise mais significativa poderia ser estabelecida pela relação
entre os fragmentos de código portável gerado (abstrações, aspectos e
framework) e não-portável (mediadores de hardware). Porém, o uso de
\emph{Metaprogramação Estática} na implementação de mediadores de 
hardware faz com que o código gerado para o mediador se encontre
disperso no código-objeto do sistema operacional, tornando esta
análise incoerente. A contagem do número de linhas no código-fonte
também caracteriza uma medida sem muita expressividade, já que grande
parte do código dos mediadores é dedicado a interação com outros
metaprogramas e abstrações, não gerando qualquer código-objeto. Ao
menos, até o momento, o grau de portabilidade deve ser inferido a
partir da própria facilidade em portar sistemas baseados em
componentes de software para diversas arquiteturas como as utilizadas
no exemplo. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusões} % - Revisit introduction %

Neste artigo conjecturamos a respeito de portabilidade em sistemas
operacionais baseados em componentes, tendo como principal foco o
artefato \emph{mediador de hardware} proposto por Fröhlich em sua
metodologia \emph{Application-Oriented System
Design}~\cite{Froehlich:2001}. Diferentemente das camadas de abstração
de hardware e máquinas virtuais, mediadores de hardware possuem a
habilidade de estabelecer um contrato de interface entre o hardware e
os componentes do sistema operacional sem gerar, a princípio, um
\emph{overhead} significativo. O uso deste mecanismo no sistema
\texttt{Epos} define um exemplo categórico de como este artefato de
software pode ser usado como um recurso de software que permita o
porte do sistema sem qualquer alteração em seus componentes. 

%Os resultados apurados foram tão positivos que um projeto de
%software-hardware co-design foi iniciado com o objetivo estender o
%conceito interface software/hardware dos mediadores para outro que
%permita a estes componentes estarem associados a descrições de
%hardware, de tal forma que, quando instanciados, além de uma
%interface, deêm origem ao próprio hardware.

\bibliographystyle{apalike}
\bibliography{guto,se,os} 

\end{document}
