%-------------------------------------------------------------------------------
% SERVIDOR DE BUFFERS
%-------------------------------------------------------------------------------
\section{Servidor de Buffers}

Uma grande parte dos objetos manipulados pelo sistema ficam residentes em disco. Um acesso a disco é sabidamente muito mais lento do que um acesso a memória principal. Assim sendo, definimos um conjunto de \buffers\ que  serão utilizados para armazenar temporariamente blocos de dados de disco. Dessa forma, quando um processo solicitar algum dado de disco, não necessariamente um bloco inteiro, que faça parte de algum \buffer, poderemos responder à solicitação sem realizar acesso a disco.

O mecanismo escolhido para implementar o servidor de \buffers\ é uma {\em cache} \cite {tan92}. Nesta abordagem, uma solicitação de dados de um certo disco pode gerar uma das duas situações abaixo:

\begin {enumerate}

\item Se o bloco estiver bufferizado, ou seja, estiver em memória principal, ele é simplesmente copiado para a área de usuário;

\item Se o bloco solicitado não estiver bufferizado, ele será buscado no disco e passará então a acupar um \buffer.

\end {enumerate}


\subsection{Manutenção de Dados Bufferizados}

Uma vez definido o esquema de bufferização de dados, devemos especificar a maneira pela qual os clientes do servidor de \buffers\ acessarão os dados bufferizados.

Para que vários processos possam acessar um mesmo \buffer\ com o menor tempo de espera possível, decidimos que todos os \buffers\ ficarão sob responsabilidade do servidor de \buffers\ que só bloqueará o acesso durante o tempo necessário à transferência dos dados do disco para o \buffer\ e do \buffer\ para a memória do cliente. Note que as transferências de dados entre o servidor e os clientes não são, necessariamente, de blocos inteiros.

Essa decisão cria um problema grave de sincronização de acesso aos blocos de dados bufferizados. Imagine o que aconteceria se um cliente solicitasse um bloco, alterasse-o e, antes de tê-lo salvo, um outro cliente solicitasse uma cópia do mesmo bloco. A segunda solicitação receberia o bloco sem as alterações efetivadas pelo primeiro cliente. O estado do bloco seria definido pela última solicitação de atualização do mesmo.

A entidade que solicita blocos de discos é, a priori, o servidor de arquivos. Esse servidor implementa um mecanismo de abertura de arquivos com exclusividade. Assim sendo, podemos sincronizar, de uma só vez, o acesso a todos os blocos de um arquivo. Exclusividade de acesso a um determinado bloco de dados de um arquivo é uma tarefa que poderá ser implementada por um servidor de {\em locks} \cite {tan92}. A proposta básica do sistema não inclui tal servidor, entretanto não seria difícil definí-lo.


\subsection{Política de Substituição de Buffers}

Quando o servidor recebe a solicitação de um bloco que ainda não está bufferizado e não existem mais \buffers\ livres, ele deve escolher um \buffer\ para ter seu conteúdo substituído.

Existem  vários métodos para escolhermos o \buffer\ que será substituído \cite {sil90}. Alguns deles fazem uso de informações como freqüência de acesso e/ou tempo do último acesso, outros dão preferência aos \buffers\ que não tenham sido alterados, e portanto não necessitam regravação.

Definimos aqui um algoritmo híbrido que levará em conta a freqüência de acesso e tentará substituir primeiro os \buffers\ que não necessitem transferência para disco. A técnica consiste em mantermos todos os \buffers\ numa lista duplamente encadeada sob a política LRU ({\em Last Recently Used}), ou seja, sempre que um bloco é acessado ele é deslocado para o fim da lista. Este algoritmo supõe que um \buffer\ há muito não acessado pertença a um arquivo fechado ou a arquivos abertos por processos com baixo fluxo de entrada e saída.

Sempre que precisarmos substituir um \buffer\ escolheremos o primeiro da lista LRU. Note que até aqui nada podemos afirmar sobre a necessidade ou não de gravação do bloco de dados do \buffer\ a ser substituído. Esse problema é tratado por um fluxo de execução específico do servidor que fica verificando a existência de algum dispositivo livre, isto é, com fila de espera vazia. Quando encontrar um dispositivo livre ele então pecorrerá a lista LRU em busca do primeiro \buffer\ alterado, i. e., que necessite regravação, com dados daquele dispositivo. Encontrado um \buffer\ que satisfaça os requisitos citados, o processo dispara a regravação do respectivo bloco de dados. Esse algoritmo, embora  não garanta que um \buffer\ escolhido para ser substituído não necessite ter seu bloco de dados gravado, otimiza bastante a substituição de \buffers.


\subsection{Método de Acesso aos Buffers}

Quando solicitamos a leitura ou escrita de dados em disco informamos ao servidor de \buffers\ o identificador do dispositivo em questão, o endereço do bloco, a posição do primeiro byte que nos interessa e o número de bytes que devem ser transferidos. Com essas informações o servidor obtém o bloco e copia os dados relevantes para ou da memória do cliente.

Para otimizar o acesso aos \buffers\ defimos um algoritmo de pesquisa {\em hash} com tratamento de sinônimos por encadeamento duplo. A função {\em hash} leva em conta apenas o identificador do bloco, utilizando o identificador do dispositivo apenas para distinguir os sinônimos encadeados na entrada equivalente ao bloco. A função {\em hash} escolhida é simples e seu cálculo envolve apenas o deslocamento de bits para obter o resto de uma divisão:

\begin {large} {\em hash} ({\em bkaddr}) = ({\em bkaddr} módulo {\em n}) \end {large}, onde {\em bkaddr} é o endereço do bloco e {\em n} é o número de \buffers\ do servidor. 

Para diminuir os sinônimos de uma certa entrada da tabela {\em hash} podemos replicar o servidor de \buffers, talvez dedicando servidores particulares aos dispositivos com maior freqüência de acesso.

\subsection{Replicação do Servidor de Buffers}

Quando um certo dispositivo apresenta um elevado fluxo de acesso e temos disponível no sistema uma quantidade razoável de memória, talvez fosse uma boa idéia dedicarmos a esse dispositivo um servidor de \buffers\ particular. Um servidor de \buffers\ que bufferizasse blocos de um único dispositivo apresentaria uma série de vantagens, a primeira delas seria a dispensa dos múltiplos fluxos de execução do servidor, pois uma vez que um fluxo bloqueasse, todos os demais fluxos do servidor também bloqueariam. Além disso, o número de sinônimos da tabela {\em hash} diminuiria consideravelmente, otimizando a pesquisa de um bloco bufferizado.

Uma abordagem extrema, embora possível em ambientes com poucos discos ou com abundância de processadores (multiprocessador) e memória, é a criação de um servidor de \buffers\ para cada disco.
