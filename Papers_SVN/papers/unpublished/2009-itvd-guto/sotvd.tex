\documentclass[portuguese,a4paper,12pt]{article}
\usepackage[latin1]{inputenc}  
\usepackage{graphicx}
\usepackage{babel}   
\usepackage{times}   

\usepackage[margin=2.5cm,nohead]{geometry} 

\newcommand{\fig}[3][htbp]{
  \begin{figure}[#1] {\centering{\includegraphics{fig/#2}}\par}
    \caption{#3\label{fig:#2}}
  \end{figure}
}

\title{Uma Reflexão Despretensiosa sobre um possível Sistema de Suporte
  de Tempo de Execução para Terminais de Televisão Digital Interativa}

\author{Antônio Augusto Fröhlich\\
  Laboratório de Integração de Software e Hardware\\
  Universidade Federal de Santa Catarina\\
  CP 476\\
  88049-900 Florianópolis - SC\\
  \texttt{guto@lisha.ufsc.br}\\
  \texttt{http://www.lisha.ufsc.br/$\sim$guto}
}

\sloppy

\begin{document}

\maketitle

%\begin{abstract}
%\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminares}

Começo esta despretensiosa reflexão sobre um possível sistema de suporte
de tempo de execução para terminais de televisão digital interativa
tecendo alguns comentários sobre o que entendo que seja um ``sistema de
suporte de tempo de execução'' e um terminal de ``televisão digital
interativa''. Um \emph{sistema de suporte de tempo de execução}, ou
\emph{run-time support system}~(RTSS) em inglês, é o que Habermann
chamava de sistema operacional nos anos 70~\cite{Habermann}, ou seja,
todo e qualquer artefato de software, incluindo firmware, acrescentando
a um sistema computacional afim de abstrair seus recursos físicos de
forma conveniente às aplicações. Sem perder de vista que o objetivo de
qualquer sistema computacional é executar uma ou mais aplicações,
poderíamos ainda dizer que um RTSS é o \emph{overhead} de software do
sistema computacional necessário ao pronto desenvolvimento dos
aplicativos almejados.

Particularmente, muito me agrada a idéia de utilizar RTSS como sinônimo
de sistema operacional, entretanto, muitos segmentos parecem querer
confinar o sistema operacional a uma camada de software bem comportada
entre o firmware e as bibliotecas de tempo de execução das linguagens de
programação. Isso sem falar na ruptura do conceito de serviços do
sistema operacional com a inclusão de camadas adicionais de midleware.
Toda esta separação me parece servir a um único objetivo: poder dizer
que nossos sistemas operacionais, que tanto assustam aos desenvolvedores
de software, estão bem comportados confinados, amarrados, engessados e
anestesiados por padrões que muitos não lembram mais sequer em que
década foram definidos. Na verdade, se nossos sistemas operacionais
tivessem uma arquitetura flexível e robusta, facilmente se adaptariam
tanto às inovações do hardware quanto às demandas das aplicações,
dispensando o próprio conceito de midleware. Neste contexto, usarei as
expressões \emph{sistema de suporte de tempo de execução} e
\emph{sistema operacional} de forma indistinta, referindo-me sempre ao
conjunto de software existente entre o hardware e as aplicações.

Definir \emph{televisão digital interativa}~(TVDi) me parece algo bem
mais difícil e prefiro não me arriscar. Gostaria apenas de lembrar o que
me parece óbvio: um terminal de televisão continua sendo um terminal de
televisão no mundo digital interativo. Logo, áudio e vídeo têm
precedência sobre qualquer inovação. Não tão óbvio, mas ainda em um
nível segura para afirmar, está o fato de que a codificação dos sinais
utilizados para a transmissão da áudio e vídeo de forma digital não deva
ficar a cargo do SO principal do terminal de acesso, mas sim de um
hardware dedicado a este propósito ou de um outro processador com SO
próprio para tal finalidade. Por fim, arrisco afirmar que, enquanto o
pessoal de televisão experimenta novos conceitos de interatividade que
se tornarão possíveis com a nova tecnologia, o que os usuários terão
como interatividade será algo muito parecido com o que hoje chamamos de
\emph{Web}.

Feitos estes esclarecimentos, creio poder agora dar inicio a minha
despretensiosa reflexão sobre um possível sistema operacional para
terminais de televisão digital interativa. Como criador da metodologia
de \emph{Projeto de Sistemas Orientados a
  Aplicação}~(AOSD)~\cite{Froehlich:2001}, não poderia começar a
reflexão senão pelas aplicações. Mesmo tendo dito que não existe hoje
uma noção clara de como as aplicações de televisão digital interativa
serão em cindo ou dez anos, não faria sentido analisar um RTSS para TVDi
em função do hardware hoje disponível ou de compatibilidade com este ou
aquele SO. Melhor tomar como base o pouco que sabemos sobre as
aplicações:

\begin{itemize}
\item Elas serão enviadas aos terminais de acesso juntamente com a
  programação de televisão, multiplexadas no fluxo de áudio e vídeo, sem
  entretanto atrapalhar o tratamento deste (assistir televisão (ainda) é
  a prioridade).
\item Elas serão executadas em terminais de acesso diversos, alguns com
  mais, outros com menos, funcionalidades.
\item Elas, pelo menos inicialmente, farão uso do controle remoto como
  principal mecanismo de interação com os usuários, além de dispositivos
  típicos de computadores pessoais, tais como teclado e mouse.
\item Algumas implicarão na transmissão de dados através de um canal de
  retorno de forma muito similar as aplicações web atuais.
\item Algumas explorarão conceitos como gravadores de vídeo pessoais que
  demandam grande capacidade de armazenamento.
\item Poucas desafiarão os conceitos estabelecidos, introduzindo
  verdadeiras revoluções na forma como vemos a televisão hoje.
\end{itemize}

Com este pequeno conjunto de detalhes, podemos começar a esboçar o que
realmente importa em um SO do ponto de vista das aplicações: sua
interface de programação (\emph{API - Application Program Interface}).
Entretanto, levando-se em consideração os ítens acima, especialmente o
último, alguém poderia afirmar que não conhecemos as aplicações
suficientemente bem para definir uma API e, portanto, deveríamos
encerrar aqui a reflexão proposta. Todavia, o estado atual das técnicas
de desenvolvimento de software nos permite definir uma API extensível,
de tal forma que novos serviços possam ser incluídos no SO e
disponibilizados às aplicações sem comprometer a integridade de
aplicações antigas. Mesmo que não se possa hoje definir uma API
completa, a análise dos compromissos envolvidos no processo de decisão
de seus elementos revela interessantes requisitos para o SO que a
implementaria. O restante desta reflexão será baseada em tais
compromissos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Uma API para TVDi}

Para efeitos desta reflexão sobre \emph{sistemas de suporte de tempo de
  execução para terminais de televisão digital interativa}, considerarei
que a API do SO definirá uma espécie de \emph{linguagem de televisão
  digital interativa}~(LTVDi). Sem querer entrar no campo da taxonomia
de linguagens computacionais, que é muito fértil e geralmente faz uso de
critérios muito bem definidos, uma primeira decisão poderia então
envolver a natureza desta linguagem: \emph{programação} ou
\emph{descrição}\footnote{O termo \emph{linguagem descritiva} é
  utilizado neste artigo como uma tradução livre do termo \emph{markup}
  em inglês.  Neste contexto, \texttt{HTML} e \texttt{XML} são
  linguagens descritivas.}.

Uma \textbf{linguagem de programação}, similar as que hoje utilizamos
para o desenvolvimento de software (i.e., onde expressamos computações
elementares), como definidora da API do SO permitiria aos
desenvolvedores de aplicações de TVDi ``programar'' o terminal de acesso
para executar tarefas paras quais ele não fora previamente programado
pelo fabricante. Assim, os desenvolvedores de aplicação poderiam
simplesmente ignorar os serviços de alto nível disponibilizados pela API
e implementar seus próprios serviços sem necessitar de apoio dos
fabricantes de terminais de acesso e nem mesmo de uma atualização do SO.
Por outro lado, uma linguagem de programação deste tipo implicaria em um
interpretador relativamente complexo, aparentemente impedindo que o
projeto do terminal de acesso seja desenvolvido no contexto de sistemas
computacionais embutidos, forçando-o a seguir os dogmas do universo de
computadores pessoais de uso geral, incluindo o custo final do produto.

Como alternativa a linguagens de programação, temos as
\textbf{linguagens de descrição}, que nos permitem especificar ``o que''
deve ser computado sem ter que especificar ``como''. A grande vantagem
de uma linguagem deste tipo advém da possibilidade de definir-se
elementos complexos (i.e., de alto nível) como por exemplo:
\texttt{Programa\_de\_Televisão} (a ser tratado pelo sistema de
recepção, decodificação e apresentação), \texttt{URL} (a ser tratada por
um \emph{browser}), \texttt{Etiqueta\_de\_Gravação} (a ser tratada pelo
sistema pessoal de gravação de vídeo). Um conjunto de elementos
lingüísticos desta natureza permitiria uma implementação mais ``enxuta''
dos serviços da API, uma vez que cada SO os implementaria de forma
específica, levando em consideração os recursos disponíveis no terminal
de acesso alvo. 

Para diferenciar as duas alternativas com mais precisão, descerei mais
um nível na árvore de decisão. Se optarmos por uma \textbf{linguagem de
  programação}, logo teremos que decidir se ela será traduzida para uma
linguagem de máquina real ou virtual. A tradução da LTVDi para uma
\textbf{linguagem de máquina real} apresentaria uma série de vantagens
no que diz respeito ao uso mais racional dos recursos físicos
disponíveis na máquina e, por conseguinte, voltaria a habilitar um
projeto de terminal de acesso no escopo de sistemas embutidos.
Entretanto, esta decisão implicaria em que os programas de TVDi fossem
recompilados para cada família de terminal de acesso. Considerando-se a
grande diversidade de processadores (e microcontroladores) utilizados no
cenário de sistemas computacionais embutidos, esta alternativa não se
mostra viável. Por outro lado, se a tradução fosse para uma
\textbf{linguagem de máquina virtual}, este problema seria eliminado,
mas não sem custos adicionais. Uma máquina virtual trás para tempo de
execução muitas coisas que poderiam ser feitas em tempo de compilação ou
ligação.

Mencionar os termos ``linguagem de programação'' e ``máquina virtual''
sem pensar em JAVA é um tanto quanto difícil nos dias de hoje. Seria
JAVA, então, a API do SO para TVDi? Independentemente da minha opinião
pessoal sobre esta linguagem, não acredito que muitos colegas me dariam
crédito se eu levantasse uma discussão sobre uma ``nova'' linguagem de
programação capaz de expressar computações elementares em uma máquina
virtual. Assim sendo, creio que a decisão fica mesmo entre JAVA ou uma
nova linguagem de descrição (e não de programação). Afinal, ao adotarmos
JAVA como API para o SO de TVDi estaríamos trazendo ao contexto uma das
linguagens de programação mais difundidas da atualidade e,
conseqüentemente, toda sua história de desenvolvimento de sistemas para
a Web. Infelizmente, juntamente com tudo aquilo que JAVA tem de bom,
estaríamos trazendo para o contexto de TVDi um dos sistemas de suporte
de tempo de execução mais complexos e onerosos já concebidos. 

Suponha, por exemplo, uma aplicação de vídeo sob demanda (VoD) escrita
em JAVA e sendo executada em um terminal de TVDi. Se tomarmos como base
a situação atual dos computadores pessoais, iremos nos deparar com um
gigantesco núcleo de SO, com uma máquina virtual (JVM) que faz uso de
uma série de bibliotecas nativas do SO, com uma biblioteca básica de
tempo de execução JAVA (classpath), possivelmente com o \emph{framework}
multimídia JAVA (JMF), além, é claro, da aplicação propriamente dita. O
overhead do sistema de suporte de tempo de execução completo é tão
grande que mesmo um computador pessoal de porte teria dificuldade em
executá-lo. Requisitos não funcionais como tempo de resposta e qualidade
de serviço dificilmente poderiam ser garantidos neste contexto.

Mas retornando ao contexto das \textbf{linguagens descritivas}, a mesma
aplicação de vídeo sob demanda seria simplesmente ``descrita'' por um
\textbf{elemento complexo} que conteria informações tais como pares
envolvidos, tipo de conteúdo e protocolos suportados. Esta descrição
seria então interpretada no terminal de acesso por uma espécie de
máquina virtual de alto nível que invocaria serviços do SO,
implementados especificamente para a plataforma em questão, a fim de
reagir à descrição recebida. Um SO deste tipo certamente acarretaria em
muito menos overhead do que uma pilha JAVA ordinária, talvez até
permitindo que o projeto fosse conduzido no contexto de sistemas
embutidos (de baixo custo).  Entretanto, como não poderia deixar de ser,
esta alternativa também tem suas desvantagens. Se optarmos por uma
linguagem descritiva com entidades complexas como a do exemplo anterior
(VoD) estaremos restringindo os programas de TVD aquilo que é
disponibilizado na API e nada mais. Qualquer extensão implicaria na
atualização do SO do terminal por parte de seus desenvolvedores. Atar
desenvolvedores de conteúdo e fabricantes de equipamentos em um esquema
de evolução de SO, pelo menos neste momento, não seria muito razoável.

\begin{figure}[htbp]
  \centering\includegraphics{arvore}
  \caption{Árvore de decisão da reflexão sobre um possível SO para
    TVDi.\label{fig:arvore}}
\end{figure}

Se, por outro lado, optarmos por uma \textbf{linguagem descritiva} com
\textbf{elementos básicos}, tais como \texttt{Conexão\_TCP},
\texttt{Área\_em\_Disco} e \texttt{Janela\_Gráfica}, estaremos
aumentando a complexidade do interpretador da LTVDi. Não obstante, se
comparada à alternativa baseada em JAVA, na qual o interpretador é uma
das peças de menor custo computacional, um interpretador um pouco mais
elaborado não seja suficiente para descartar a alternativa. Mais
significativo é o impacto que uma abordagem deste tipo teria na
segurança do terminal de acesso. Uma API de baixo nível daria acesso a
serviços básicos do SO, como eliminação de dados e envio de mensagens
pelo canal de retorno. Por um momento posso até imaginar nossas
televisões sendo infectadas por vírus, programas de televisão sendo
interrompidos ou removidos, dados pessoais sigilosos (e.g., Internet
banking) sendo divulgados indiscriminadamente, em resumo, o caos atual
da computação pessoal instaurado também na televisão. Alguém poderia
argumentar que JAVA estaria sujeito as mesmas considerações. Em teoria,
isso é verdade, mas na prática as questões de segurança de aplicações
JAVA para Web vêm sendo estudadas com afinco pela comunidade científica
e pelas empresas, de forma que não seria justo colocar as duas
abordagens no mesmo patamar.

Neste ponto da reflexão já me parece ser possível deduzir que os dois
candidatos mais fortes para definir a API do SO de TVDi são JAVA e uma
nova linguagem descritiva com elementos complexos. JAVA nos é familiar,
mas como seria esta linguagem descritiva? Sem me afastar muito de coisas
conhecidas, arriscaria sugerir SGML, ou melhor ainda, XML e uma coleção
de DTDs, como ponto de partida. Um programa de TVDi seria então descrito
por elementos que fariam menção, por exemplo, a idiomas de áudio e
legendas disponíveis. O SO reagiria, implicitamente, a tais elementos
invocando serviços para, por exemplo, indicar ao usuário que existem
diversas línguas disponíveis para a programação. Posteriormente, dentro
do fluxo de áudio e vídeo, o SO poderia identificar outros elementos da
LTVDi como canais de bate-papo sobre o programa, URLs para informações
auxiliares sobre o programa, elementos de interatividade como enquetes,
etc. Sempre que o SO identifica um elemento da TVDi dentro do fluxo ele
invoca os serviços associados. 

Tomando como base a Internet de hoje, certamente HTML seria uma das DTDs
constituintes do LTVDi. Além disso, o tratamento local de eventos
ordinários como o clique de um mouse seria feito através da adição de
seqüências de escape na LTVDi para linguagens de programação
simplificadas (linguagens de script) de forma similar a relação
estabelecida entre HTML e JAVA-Script. Cabe salientar que esta Internet
está disponível em sistemas embutidos complexos como telefones celulares
e PDAs e que uma re-engenharia poderia viabilizá-la em sistemas de menor
porte.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finalmentes}

Uma balanço da reflexão feita até o momento é mostrado na figura abaixo,
na qual JAVA representa a alternativa de \textbf{linguagen de
  programação} como definidora da API do sistema operacional para o
terminal de acesso de televisão digital interativa e XML representa a
alternativa de \textbf{linguagem de descrição}. Cada uma das
alternativas tem grandes vantagens e desvantagens, sendo que fazer uma
definição em favor de uma delas sem antes executar um profundo estudo
seria, no mínimo, um ato inconsistente.

\begin{figure}[htbp]
%  JAVA $\rightarrow$ programável $\rightarrow$
%  \parbox{4cm}{independência entre produtores de conteúdo e fabricantes
%    de equipamentos} $\rightarrow$ alto overhead $\rightarrow$
%  \parbox{3cm}{baixo custo de desenvolvimento (NRE)} $\rightarrow$
%  \parbox{3cm}{alto custo unitário}
  
%  XML $\rightarrow$ atualizável $\rightarrow$ \parbox{4cm}{dependência
%    entre produtores de conteúdo e fabricantes de equipamentos}
%  $\rightarrow$ baixo overhead $\rightarrow$ \parbox{3cm}{alto custo de
%    desenvolvimento (NRE)} $\rightarrow$ \parbox{3cm}{baixo custo unitário}
  
  \textbf{JAVA $\rightarrow$ programável $\rightarrow$ overhead grande
    $\rightarrow$ baixo custo de NRE $\rightarrow$ alto custo unitário}
  
  \bigskip
  
  \textbf{XML $\rightarrow$ atualizável $\rightarrow$ overhead pequeno
    $\rightarrow$ alto custo de NRE $\rightarrow$ baixo custo unitário}
\caption{Resumo da reflexão sobre um possível SO para TVDi.\label{fig:balanco}}
\end{figure}

Todavia, ao invés de um estudo profundo para analisar que vantagens são
mais vantajosa e quais desvantagens são mais desvantajosas correndo o
risco de não chegar-se a uma conclusão satisfatória, talvez fosse mais
prudente conduzir um profundo estudo para avaliar a possibilidade de
convergência das duas estratégias. Aparentemente, as duas abordagens são
muito distintas, quase antagônicas, e não apresentam uma intersecção
grande o suficiente para que possamos apontar alguma convergência.
Entretanto, se observarmos mais atentamente os detalhes arquiteturais do
sistema operacional por traz de ambas as estratégias, identificaremos
uma série de elementos comuns.

Pelo lado de JAVA, os esforços para viabilizar seu uso em sistemas
embutidos têm se concentrado em três frentes: otimização e compactação
do código compilado (i.e., \emph{bytecode}); otimização da máquina
virtual (JVM) e otimização das bibliotecas de tempo de execução
(\emph{classpath}). A primeira frente se concentra em remover do
\emph{bytecode} todas as informações que não são estritamente
necessárias a execução do programa sem perdas semânticas. Recentes
avanços nesta área~\cite{} vêm se mostrando bastante efetivos no que diz
respeito a redução da banda de rede e do espaço de armazenamento
requerido. No contexto de televisão digital, entretanto, estas métricas
não são tão significativas se considerarmos a banda e a área de
armazenamento necessárias para o processamento de vídeo e áudio.

A segunda frente, otimização da máquina virtual, freqüentemente implica
na eliminação de funções avançadas, como carga dinâmica de classes,
criação de monitores (para o sincronismo de \emph{threads}), gerência de
memória entre outras. No contexto de TVDi, uma máquina virtual
incompleta também não me parece aceitável.

Já a terceira frente, que se concentra em otimizar o \emph{classpath},
pode ser um dos pontos de convergência que buscamos. Uma estratégia
comum para a otimização das funções do \emph{classpath} e a utilização
de métodos nativos --- métodos declarados em JAVA mas compilados para a
máquina real. Esta abordagem poderia também ser usada para implementar
uma biblioteca de tempo de execução específica para TVDi muito similar a
máquina virtual que implementaria a linguagem descritiva analisada
anteriormente (i.e. XML). Assim, JAVA seria usada basicamente para
invocar a API de TVDi implementada nativamente para o terminal acesso em
questão, mas sem impedir que algum produtor de conteúdo venha a
introduzir novos elementos, que estariam restritos, basicamente, apenas
pelo desempenho do terminal de acesso para executar aplicações complexas
escritas em JAVA.

\begin{figure}[htbp]
  \centering\includegraphics{convergencia}
  \caption{Possível convergência das duas abordagens.\label{fig:convergencia}}
\end{figure}

A grande questão por traz desta convergência é saber se nossas técnicas
de engenharia de software são suficientemente maduras e robustas para
suportar uma arquitetura deste tipo; saber se podemos atribuir ao
conjunto um valor equivalente a soma dos valores das partes.  Um estudo
desta natureza certamente traria respostas a muitas das questões
levantadas nesta reflexão.







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{JAVA em Sistemas Embutidos}

%Qual seria a linha de ação para verificar a viabilidade de JAVA no
%contexto de sistemas embutidos?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Um SO para Televisão Digital Interativa}

%Qual seria a arquitetura de um SO para TVDi baseado em uma API originada
%a partir de uma linguagem descritiva de TVDi?


\bibliographystyle{apalike} \bibliography{guto,se,os}

\end{document}
