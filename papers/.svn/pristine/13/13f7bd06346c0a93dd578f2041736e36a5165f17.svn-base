\documentclass{acm_proc_article-sp}

\usepackage[latin1]{inputenc}	% for Latin languages
\usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support
\usepackage{graphicx}
%\usepackage{multirow}
%\usepackage[caption=false,font=footnotesize]{subfig}

\include{utils} %new commands 

\begin{document}

%\title{Aspect-oriented Design of Hardware Components}
\title{An AOP-based approach for Hardware Design}

%\author{Tiago Rogério Mück\IEEEauthorrefmark{1}, 
%Michael Gernoth\IEEEauthorrefmark{2}, 
%Wolfgang Schröder-Preikschat\IEEEauthorrefmark{2}, 
%Antônio Augusto Fröhlich\IEEEauthorrefmark{1}\\
%
%\IEEEauthorblockA{\IEEEauthorrefmark{1}Software/Hardware Integration Lab\\
%Federal University of Santa Catarina\\
%Florianópolis, Brazil\\ 
%Email: \{tiago,guto\}@lisha.ufsc.br}
%
%\IEEEauthorblockN{\IEEEauthorrefmark{2}Friedrich-Alexander University Erlangen-Nuremberg\\
%Department of Computer Science 4\\
%Erlangen, Germany\\
%Email: \{gernoth,wosch\}@cs.fau.de
%}}

\author{Authors omitted for blind review}

\maketitle

\begin{abstract}
In this paper we propose a SystemC-based hardware design method using
object-oriented and aspect-oriented programming concepts. The method
can be applied at register transfer or higher levels of the design process,
and leverages on features within the SystemC synthesizable subset, thus yielding
synthesizable components. The results show that our design artifacts provide an 
increased level of flexibility and reusability at the cost of a 
negligible overhead.
\end{abstract}

%\begin{IEEEkeywords}
%Aspect-oriented programing, digital hardware design, reconfigurable hardware
%\end{IEEEkeywords}

\section{Introduction}
\label{INTRO}
%Hw design problem, complexity, etc.
%Solution is reuse: OOP solved problems in SW, now in HW too
The complexity of embedded system design is increasing  much faster than
the design and verification capability of developers. 
This has led to the introduction of solutions and methodologies
that has been successfully deployed in the scope of large-scale software systems.
For example, \textit{object-oriented programming}~(OOP), which
is supported in the hardware domain by languages like SystemC~\cite{Panda:2001}.

%In this paper we explore ... (describe solution)
%AOP, AOP increases OOP expressiveness ...
%Our proposal...
In this paper we propose the use of 
\textit{Aspect-oriented programming}~(AOP)~\cite{Kiczales:1997} techniques
for hardware design. AOP is an elaboration over OOP which improves its
expressiveness by providing means to deal with concerns that cannot
be clearly encapsulated by OOP classes. In this work, we leverage on
SystemC features in order to enable the implementation of 
hardware components using OOP and AOP concepts. Along with the use of
OOP techniques (e.g. inheritance), we propose the use of a domain
engineering strategy which yields components in
which its dependencies from the execution scenario are encapsulated as 
\emph{aspects} and \emph{configurable features}. This artifacts are implemented
using standard C++ metaprogramming features within the SystemC synthesizable
subset~\cite{systemc_subset}, thus yielding \emph{synthesizable components} 
that can be more easily modified and reused in a wider range of execution
scenarios. This method is illustrated by the design and implementation of
an operating system task scheduler in hardware. \newline


%Our contributions are ... (highlight contributions)

In summary, in this paper, we make the following contributions:
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
 \item We provide a comprehensive analysis of related work in the area
of AOP applied to the hardware domain.
 \item We describe the first AOP-based method for designing 
synthesizable hardware components.
 \item We present the design and implementation of a flexible task scheduler
in hardware.
\end{itemize}

%The remaining of this paper is organized as follows...

The remaining of this paper is organized as follows: section \ref{ASPECTS}
introduces AOP concepts and gives a first glance on its use for the development of HW
components; section \ref{RELATED_WORK} presents a discussion about
related work; section \ref{PROPOSAL} presents our contributions;
and sections \ref{RESULTS} and \ref{CONCLUSION} show our experimental
results and conclusions.

\section{Aspect-oriented programming}
\label{ASPECTS}
%-Introduction to AOP\cite{Kiczales:1997}
%from OOP to AOP
%separation of cross-cutting concerns
%Advice, pointcut and aspect

In the software domain, the use of machine code had evolved naturally to 
procedural languages and then to OOP. 
An enormous productivity improvement resulted from the increased level of abstraction.
However, OOP still have some limitations in the way it allows a complex problem to
be broken up into reusable abstractions. Even though most classes in an object-oriented model
will perform a single function, they often share common, secondary requirements with other classes.
The implementation of these \emph{crosscutting concerns} is scattered among the multiple
abstractions, thus breaking the encapsulation principle. AOP is an elaboration over OOP to 
deal with the crosscutting
concerns. AOP proposes the encapsulation of these concerns in special classes called \emph{aspects}.
An aspect can alter the behavior of the base code by applying \emph{advices} 
(small pieces of code defining additional behavior) in specific points of a program 
called \emph{pointcuts}. Some extensions to OOP languages have been proposed to 
support these new concepts. 
For example, AspectJ~\cite{Kiczales:2001} and AspectC++~\cite{Spinczyk:2002} extend
Java and C++ with full support for AOP features. They provide both new language constructs
and an \emph{aspect weaver}, a tool responsible for applying the advices to the base code
before it is processed by the traditional compiling chain.


%-First glance of AOP in hardware
%Talk about OOP in hardware
%OOP X AOP in hardware
%Possible application of AOP in hardware (show examples)\cite{Engel:2008, FengLiu:2009, Bainbridge-Smith:2005}\newline

Recently, there has been a growing interest in high-level methodologies for
hardware design as well. An example of a \textit{hardware 
description language}~(HDL) which supports OOP is SystemC, 
a C++ based modeling platform and language supporting design abstractions at the
register transfer, behavioral, and system levels~\cite{Panda:2001}. However, analogous to software,
in hardware some system-wide cross-cutting concerns cannot be elegantly encapsulated.
For example, in complex circuits, interconnection of several entities is realized 
by introducing buses. A bus physically interacts with other components (e.g. CPU, DMA, ...),
but it is difficult to use a module or a class to encapsulate the bus because 
its interface and arbitration method has to be implemented in every attached component.
Other examples of crosscutting concerns in hardware designs can be also found in parts of a system
related to its overall functionality or the implementation of non-functional properties 
(e.g. clock handling and hardware debugging through JTAG scan chains). Even with the introduction of OOP in hardware,
this scattered code is hard to maintain and bugs may be easily introduced. The introduction of AOP 
to hardware design is expected to provide the easy encapsulation of cross-cutting 
concerns and an increase in the overall design quality. 

%maybe join this section with the next one or with the introduction.

\section{Related work}
\label{RELATED_WORK}
%the related works count in each paragraph will depend on the number of pages remaining.

%works discussing AOP in hardware
%\cite{Engel:2008} - AOP discussion and proposed VHDL extension / no implementation\newline
%\cite{Bainbridge-Smith:2005} - AOP discussion and proposed new language / few details\newline
%\cite{Burapathana:2005} - very low-level HW design / discussion and proposal / no implementation\newline

Several works have already proposed the use of AOP concepts for hardware design.
\emph{Engel and Spinczyk}~\cite{Engel:2008} discussed the nature of crosscutting
concerns in VHDL-based hardware designs. They have proposed a hypothetical AOP
extension for VHDL in which the execution of a process and the setting of a signal
are used as pointcuts. However, the work lacks a concrete implementation and
an evaluation of the impact of AOP in the design. In \emph{Bainbridge-Smith and Park}
~\cite{Bainbridge-Smith:2005} the authors discussed how the separation of concerns 
may relate to different levels of algorithmic abstraction. They have mentioned
the development of ADH, a new HDL based on AOP, but further details about ADH are
not mentioned. \emph{Burapathana et al.}~\cite{Burapathana:2005} proposed the use of AOP concepts to 
sequential logic design. Nevertheless, they focused on very simple and low level examples
like flip-flops and logic gates on which only the clock can be feasibly handled as
a crosscutting concern.

%works that focus on verification
%\cite{Endoh:2008} - high-level components verification / simulation only / SystemC+AspectC++ and SpecC\newline
%\cite{Kallel:2010} - TLM\cite{Cai:2003} verification / simulation only / SystemC+AspectC++\newline
%\cite{Liu:2010} - high-level power estimation / simulation only / SystemC+AspectC++\newline
%\cite{Vachharajani:2004} - high-level specification (but AOP features only for verification)/ simulation only / new language\newline


There are also several works which proposed the use of AOP concepts mostly for 
hardware verification. \emph{Endoh et al.}~\cite{Endoh:2008} used 
AOP to enable assertion-based verification in high-level hardware design,
in which assertions are based on pointcuts instead of specifiers to signal
changes. They have designed and implemented two assertion languages with 
pointcut-based assertions, ASystemC and ASpecC, which work alongside SystemC 
and SpecC, respectively. ASystemC uses pointcut of AspectC++, and its implementation
translates assertions into aspects of AspectC++. \emph{Kallel et al.}~\cite{Kallel:2010}
also proposed the use of SystemC and AspectC++ to implement assertion checkers.
The authors focused on the verification of transaction-level
models (TLM)~\cite{Cai:2003} in which transaction state updates are used as pointcuts.
They provide a framework in which the user verification classes extend the base aspect
classes that implement the pointcuts and verification. 

Other proposal that focus only on
hardware verification can be seen in \emph{Vachharajani et al.}~\cite{Vachharajani:2004},
in which the authors developed the \textit{Liberty Structural Specification Language}~(LSS).
In LSS each module can declare that its instances emit certain
events at runtime. These events behave like pointcuts of AOP. Each time a certain 
state is reached or a value is computed, the instance will emit the corresponding
event and user-defined aspects will perform statistics calculation and reporting. 
\emph{Liu et al.}~\cite{Liu:2010} also proposed AOP-based instrumentation,
but focusing high-level power estimation.  They have developed a methodology based on 
SystemC in which AspectC++ is used to define special power-aware aspects. 
These aspects are used as configuration files to link power aware libraries with
SystemC models.

%works that focus on design
%\cite{Deharbe:2006} - component design and verification / simulation only / SystemC+AspectC++\newline
%\cite{Vax:2007} - modeling and verification (mainly) / simulation only / new language\newline
%\cite{FengLiu:2009} - component design / simulation only / SystemC+AspectC++\newline
%\cite{Jun:2009} - FOP+AOP for hardware design / simulation-only / SystemC\newline

Other works provide AOP features not only for verification, but also for the actual
design of hardware. \emph{D\'{e}harbe and Medeiros}~\cite{Deharbe:2006}
present and assess possible applications of AOP in the context of integrated
system design by using SystemC with AspectC++. Differently from the works discussed
previously, they showed how AOP can be used to encapsulate some functional characteristics
of hardware components. They modeled as aspects the replacement policy of a cache, 
the data type of an FFT, and the communication protocol between modules. However,
only simulation results are shown and they do not compare the implementation of
aspect-based components against components with all
the functionalities hard-coded. In a similar work, \emph{Liu et al.}~\cite{FengLiu:2009}
implemented a SystemC model for a 128-bit floating-point adder and described
the implementation of the same model using AOP techniques. But, 
synthesis results are not provided and the two models are
compared only in terms of functionality to show that the AOP design works 
like the original SystemC-only design. 

Other works in this area follow different approaches.
The \emph{e} programming language~\cite{Vax:2007} was designed for modeling and
verification of electronic systems and some of its mechanisms can be used to support
AOP features. Apart from its OOP features, \emph{e} has some constructs to define
the execution order of overloaded methods in inherited classes, which can be used to 
define pointcuts and implement aspects. Indeed, this can be used to implement the
behavior of hardware components, but \emph{e} is more focused in high-level specification
and there is not any tool support for synthesis.

\emph{Jun et al.}~\cite{Jun:2009} analyzed the application of \textit{Aspectual Feature Module}
~(AFM)~\cite{Apel:2008} to HDLs. They have implemented a RISC processor using SystemC and
FeatureC++~\cite{Apel:2008}, and showed how AFM enables the incremental development of
hardware through the modularization of code fragments for the implementation of a function.
However, AOP is used only for encapsulation of verification code and the authors
do not provide synthesis results of the resulting code.

%-Discussion
%Most works focus on high-level specification and verification
%There are no related work aiming at using aspects for the actual
%design of synthesizable hardware

In summary, several of the previous works have focused
on high-level specification and AOP features are used
mostly for code instrumentation and verification. Also, there are not any related work 
aiming at using AOP for the actual design of synthesizable hardware, since, as discussed
above, all works present experiments only at the simulation level and lack a more
comprehensive discussion about the overheads related to the use of AOP.

\section{Designing hardware components using scenario adapters and configurable features}
\label{PROPOSAL}

%-Introduction
%Introduction to ADESD (previously known as AOSD\cite{Froehlich:2001})
%Use the techniques proposed by ADESD and implemented in C++ to
%implement HW components in SystemC
%Maybe include the classic ADESD figure

%OBS.: começar falando que vamos aplicar AOP em HW usando conceitos da ADESD ao
%invés de sair falando de cara sobre cenário adapters.

\figTC{.6}{fig_scenario_adapters_uml_detail}
{UML class diagram showing the general structure and behavior of a scenario adapter.}

Similarly to previous works, we also based our approach on methodologies
which have been used in the software domain. The 
\textit{Application-driven Embedded System Design} (ADESD) \cite{Froehlich:2001}
methodology elaborates on commonality and variability analysis---the well-known domain
decomposition strategy behind OOP---to add the concept of aspect identification and separation
at early stages of design. It defines a domain engineering strategy focused on the
production of families of scenario-independent components. Dependencies 
observed during domain engineering are captured as separate \emph{aspect},
thus enabling components to be reused on a variety of execution scenarios with the application of
proper \emph{aspects}. This aspect weaving is performed by constructs 
called \emph{Scenario adapters}\cite{Froehlich:2000}.

The design artifacts proposed in ADESD were implemented and validated on the
\textit{Embedded Parallel Operating System} (EPOS) \cite{Froehlich:2001}. 
EPOS aims to automate the development of dedicated computing systems,  
and features a set of tools to select, adapt, and plug components into an application-specific
framework, thus enabling the automatic generation of an application-oriented system instance.
EPOS is implemented in C++ and leverages on \emph{generic programming}~\cite{Czarnecki:2000}
techniques such as \emph{static metaprogramming} in order to achieve high reusability with low
overhead. Whether such guidelines can also be defined for designing hardware 
has not yet been investigated, but nonetheless, SystemC enables the introduction
of convenient C++ construct to increase the quality of hardware designs. 
This will be demonstrated in the next sections.


%-Describe the design artifacts
%Describe the artifacts belows in terms of hardware (with signals, etc)

\subsection{Scenario adapters}
%Scenario adapters\cite{Froehlich:2000}.

Scenario adapters were developed around the idea of components getting in and out 
of an execution scenario, allowing actions to be executed at these points, therefore,
a scenario must define at least two different operations: \emph{enter} and \emph{leave}.
These actions must take place respectively before and after each of the component's 
operation in order to setup the conditions required by the scenario. For example,
in a compressed scenario, enter would be responsible to decompress the
component's input data, while leave would compress its outputs. 

In the software domain, components are objects which communicate using method
invocation (considering an OOP-based approach) and the execution of all operations
are naturally sequential, so the scenario adapters were originally developed to 
provide means to just efficiently wrap the method calls to an object with 
enter and leave operations. However, in the hardware domain, components have
input and output signals instead of a method or function interface, and all
operations are intrinsically parallel. These different characteristics 
required a redefinition of the original design artifacts,
which is shown in figure \ref{fig_scenario_adapters_uml_detail}.

SystemC defines hardware components by the specialization of the \emph{sc\_module}
class. Components communicate using special objects called \emph{channels}. 
SystemC channels can be used to encapsulate complex communication protocols at
register transfer or higher levels of abstraction. However, these complex
channels lie outside the SystemC synthesizable subset, so we use only
\emph{sc\_in} and \emph{sc\_out}, which define simple input and output ports
for components. Methods which implement the component's
behavior must be defined as SystemC processes. In our examples we use SystemC
clocked threads (\emph{SC\_CTHREAD}), in which all operations are synchronous
to a clock signal. The implementation of the \emph{Component::controller} method
in figure \ref{fig_scenario_adapters_uml_detail} shows the common behavior of a 
\emph{SC\_CTHREAD}. SystemC \emph{wait()} statements must be used to synchronize the
operations with the clock, in other words, all operations defined between two 
\emph{wait()} statements occur in the same clock cycle.

Using these constructs, we define each aspect as a single and
independent hardware component (\emph{Aspect} class). \emph{Enter} and \emph{leave} operations 
are defined using a simple handshaking protocol (\emph{op\_rdy\_out} and \emph{op\_req\_in}
signals) to trigger its execution. The remaining input/output ports define which operation
are being triggered (this is specific of each aspect). With this kind of handshaking communication
protocol we can produce more reusable components, since the number of clock cycles it requires
for each operation is hidden by the protocol, thus making it easier to synchronize component
execution with the rest of the design.

The \emph{Scenario} class incorporates, via aggregation, all of the aspects which define
its characteristics. It defines \emph{enter} and \emph{leave} methods to encapsulate
the implementation of the handshaking protocol which trigger the aspects.
Figure \ref{fig_scenario_adapters_uml_detail} shows how the scenario's \emph{enter}
operation is implemented. All aspects are triggered at the same time and executes
in parallel, however, if required by the scenario, this can be modified in order to
execute each aspect sequentially at the cost of additional clock cycles. 

The adaptation of the component to the scenario is performed by the \emph{Scenario Adapter} 
class via inheritance. This adaptation is possible through the separation
of the component's input/output protocol from the implementation of
its behavior. A SystemC process (\emph{controller} method) handles the
input/output protocol (\emph{behavior} method) and calls the requested 
operations, which are each implemented in its own methods. These methods
are overridden in the \emph{Scenario Adapter} class. Notice that, although
scattered through a class hierarchy and different methods, all operations
(from the handling of the component's input/output protocol, to the triggering
of the aspects) executes inside the \emph{controller} \emph{SC\_CTHREAD} process.
For the proposed scheme to work, \emph{wait()} statements are also used
to schedule the operations among the clock cycles, instead of
defining explicit state machines. If the latter is used, it would not be possible
to elegantly implement the structure described in figure 
\ref{fig_scenario_adapters_uml_detail}, since a state machine would require 
manual intervention to add the operation defined by the scenario.

%Figure \ref{fig_scenario_adapters_block}
%also show how the design entities interacts by using a representation which is closer
%to the physical implementation.
%\fig{.6}{fig_scenario_adapters_block}
%{Block diagram showing the general structure of a scenario adapter.}  


\subsection{Configurable features}
%Configurable features using static metaprogramming.

Additionally to the analysis and domain engineering process, several characteristics 
can be identified as configurable features of the components. In fact, such 
characteristics represent fine variations within a component, which 
can be set in order to change slightly its behavior or structure.
Figure \ref{fig_config_features_uml} shows how this features can be implemented 
using static metaprogramming~\cite{Czarnecki:2000} techniques. Special template
classes called \emph{Traits} are used to define which characteristics of each component
is activated. Metaprograms are then used to conditionally modify the component
behavior or modify its structure through inheritance.

\fig{.5}{fig_config_features_uml}
{Components behavior and structure modified by configurable features}


\subsection{ADESD and classic AOP}
%-Discussion: ADESD X classic AOP (for hardware design)
%Basically, needs to justify the use of the above artifacts for HW design
%instead of other stuff proposed by other authors
%Using AspectC++ for example allows for full AOP in SystemC 
%(more powerful then scenario adapters), so why don't we use it ?
%The resulting code is not synthesizable, AspectC++ introduces dynamic pointers
%and objects outside the SystemC synthesizable subset (strong claim, actually needs further
%investigation)
%Most of the examples in the related works used have design problems that could be 
%more elegantly solved using other techniques rather than AOP (e.g. inheritance, 
%template parameters -- when using C++/SystemC)\cite{Afonso:2007, Deharbe:2006}
%The remaining problems can be easily solved by scenario adapters
%Only standard languages features are used. No extensions or extra tools are required.
%Can use OOP + scenario adapters + static metaprogramming and still remains within the
%SystemC synthesizable subset.
%Maybe talk something about homogeneous and heterogeneous crosscutting~\cite{Jun:2009}

Several previous works have already discussed aspect-oriented hardware design using 
SystemC and proposed solutions based on classic AOP concepts using the
well known AspectC++ language. Indeed, AspectC++ provides more powerful mechanisms
for aspect implementation then ADESD, especially when it comes to the definition
of the pointcut, however, this additional mechanisms are usually either
unnecessary or can be efficiently replaced. For example, the aspects implemented in
\emph{D\'{e}harbe and Medeiros}~\cite{Deharbe:2006}~(section \ref{RELATED_WORK})
could be more elegantly implemented using other standard C++ features like
inheritance and templates parameters. In the scope of ADESD, we can say that
scenario adapters can be used to implement \emph{homogeneous crosscutting}~\cite{Jun:2009}
(the process of adding the same behavior for all classes).
\emph{Heterogeneous crosscutting}~\cite{Jun:2009}(when concern is specific to a certain
component or family of components) can be easily 
implemented with standard OOP (e.g. inheritance) and configurable features.
 
Another advantage of ADESD over the methodologies proposed previously,
is the implementation of its mechanisms which can be realized using 
only standard SystemC features. No extensions to the language or
extra tools are required. Previous works focus on tools and 
languages which were deployed only for software development (e.g. AspectC++),
which limits its use for the generation of synthesizable hardware. 
For example, AspectC++ introduces dynamic pointers and objects, 
that are outside the SystemC synthesizable subset~\cite{systemc_subset},
thus allowing for the development of simulation-only models. This also
limits the evaluation of the physical 
overheads (e.g. silicon area and performance) associated to AOP.

As can be seen in the following sections, the use of OOP, scenario adapters,
and configurable features yield code within the SystemC synthesizable
subset, thus enabling the use of ADESD's mechanisms in all levels of the 
design process.

\section{Experimental results}
\label{RESULTS}

%-Describe the case study: the OS Scheduler\cite{Marcondes:2009:2}
%*Talk about the separation between the scheduling mechanism and the scheduling criteria. Figure \ref{fig_scheduler_model}.
%\figEMPTY{3in}{4in}{fig_scheduler_model}{Simplified version of the task scheduler model}

In order to evaluate the proposed approach, we provide an aspect-oriented
implementation of a hardware scheduler for operating system tasks~\cite{Marcondes:2009:2}.
Figure \ref{fig_schduler_model_uml} shows a simplified view of the task
scheduling model. In this design, the task is represented by the class
\emph{Thread} and defines the execution flow of the task, implementing 
the traditional functionality (e.g. suspend and resume operations). 
The classes \emph{Scheduler} and \emph{SchedulingCriteria} define the 
structure that realizes the task scheduling. Traditional design and 
implementations of scheduling algorithms are usually done by a hierarchy
of specialized classes of an abstract scheduler class, which can
be further specialized to bring new scheduling policies to the system. 
In order to reduce the complexity of maintenance of the code (generally present in
such hierarchy of specialized classes), as well as to promote its reuse,
the design detaches the scheduling policy (criteria) from its mechanisms 
(lists implementations) and also detaches the scheduling criteria from the 
thread it represents.  This is achieved by the isolation of the element's comparison
algorithm of the scheduler in the criteria.

\fig{.54}{fig_schduler_model_uml}
{Simplified UML view of the task scheduling model}

Additionally to the analysis and domain engineering process, several characteristics
were identified as configurable features of the scheduler. Among such features, 
preemption, admission control of tasks, energy consumption and changes in tasks
information were identified as slightly variations of the scheduler. 

\subsection{Hardware implementation}
%-Describe the hardware scheduling mechanism. Figure \ref{fig_scheduler_hw_blocks}.
%\figEMPTY{3in}{3in}{fig_scheduler_hw_blocks}{Block diagram of HW scheduling mechanism}

The separation of the mechanism from the scheduling policy was fundamental
for the construction of the scheduler in hardware. The hardware scheduler
component implements only the mechanisms that realize the ordering of the
tasks, based on the selected policy. In this sense, the same hardware 
component can realize distinct policies.

The implementation of the scheduler in hardware~(figure \ref{fig_schduler_hw}) follows a well-defined structure. 
It has an internal memory that implements an ordered list. One process (\emph{Controller})
is responsible for interpreting all the data received by the interface of
the component in hardware and then to activate the process responsible for implementing
the functionality requested by the user (through the command interface register). This
implementation, as the software counterpart, realizes the insertion of its elements
already in order, that is, the queue is always maintained ordered, following the
information that the \emph{SchedulingCriteria} provides.

\fig{.5}{fig_schduler_hw}
{Block diagram of hardware scheduling mechanism}

%\subsection{Configurable features implementation}
%-Describe the configurable features implemented
% TODO

\subsection{Aspects implementation}

%-Describe the aspects implemented
%*Implemented aspects from de Debugged family (talk  little about it,
%reference Guto's thesis)\cite{Froehlich:2001} for hardware debugging through JTAG
%*Traced aspect. Figure \ref{fig_debug_aspects}
%*Profiled aspect. Figure \ref{fig_debug_aspects}
%*Watched aspect. Figure \ref{fig_debug_aspects}
%\figEMPTY{3in}{4in}{fig_debug_aspects}{The debugged family of hardware aspects}

We have implemented aspects for debugging. Unlike previous works,
which focused on simulation-time tracing and logging, we have implemented
aspects for on-chip debugging. Figure \ref{fig_debug_aspects_uml} shows
the debugged family of hardware aspects. The class~\emph{DebuggedCommon}
defines common ports for all aspects. Besides the ports used for clock 
and reset, it defines outputs for the JTAG debug protocol~(\emph{trigger\_out}
and \emph{data\_out}) and for the enter/leave protocol~(\emph{op\_rdy\_out} and
\emph{op\_req\_in}). The input values for the ports defined
by the subclasses determine which operation will be triggered.

\fig{.55}{fig_debug_aspects_uml}
{The debugged family of hardware aspects}

The aspects implemented define the following debugging functionalities: 
\emph{Watched} causes the state of a component to be dumped every time 
it is modified; \emph{Traced} causes every operation execution to be 
signalized; and \emph{Profiled} counts the number of clock cycles used
by the component for each operation.


\subsection{Scenario adapter implementation}
%-The weaving process
%*Describe the Debugged scenario
%*Describe the scenario adapter for the scheduler
%*wait() statements are used to schedule operations instead of state machines
%\figEMPTY{3in}{4in}{fig_adapted_sched_diagram}{Scheduler modified by the scenario adapter}

Figure \ref{fig_adapted_sched_diagram_uml} shows how we applied the aspects
to the scheduler using a scenario adapter (for simplicity, some details,
such as methods, ports, and hierarchies, are omitted). The class \emph{Scheduler}
defines the scheduler component. The \emph{controller} SystemC process is 
responsible for reading the component inputs and calling the method which
implements the corresponding operation. The class \emph{AdaptedScheduler}
implements the scenario adapter. It inherits from the \emph{Scheduler}
and \emph{Debugged} classes, and redefines the operation methods by 
adding calls to the \emph{enter} and \emph{leave} methods of \emph{Debugged}.
The \emph{Debugged} class defines the scenario and its methods implement
the handshaking protocol that triggers the aspects components.

\fig{.6}{fig_adapted_sched_diagram_uml}{Scheduler modified by the scenario adapter}


\subsection{Results}

%Compare: raw scheduler X scenario adapted scheduler X scheduler with
%hand-coded debugging X original VHDL scheduler (from Hugo's work)
%Synthesis results (describe tools and target device. Celoxica's Agility
%synthesizes SystemC to VHDL, and all VHDL is synthesized using Xilinx's
%tools. Also compare the results of Xilinx tools with Agility's-generated
%netlist) through

We synthesized the SystemC designs described previously using Celoxica's Agility
1.3. They were synthesized to VHDL and EDIF formats targeting a Xilinx Spartan3
XC3S2000 FPGA. The final place-and-route was performed using Xilinx ISE 12.3.
All the synthesis processes were executed with all the optimization enabled.
Tables \ref{tab_results_agility_est} and \ref{tab_results_xilinx_edif}
show the results. \emph{Normal scheduler} is
the scheduler component without any modification, 
\emph{Debugged scheduler---scenario adapter} is the scheduler modified with the
scenario adapter while \emph{Debugged scheduler---hand coded} is the scheduler
with the aspects functionalities hand coded.

\tabTC[ht]{tab_results_agility_est}
{Hardware resources estimated by Agility.}

\tabTC[ht]{tab_results_xilinx_edif}
{Hardware resources used after placing and routing Agility's netlists.}

The results show that the use of scenario adapters yields a very low overhead in
terms of both resource consumption and performance.  For the scenario-adapted scheduler, the number of
occupied slices is about $1\%$ higher than the hand-coded scheduler. The difference
in performance (given by the longest path delay) is negligible. This overhead
comes basically from the additional signal and registers required by the 
handshaking protocol that is used to trigger the aspects, which is not
required when everything is coded within a single SystemC process. Also,
the modularized structure of the scheduler does not yield any overhead
since it is based on static mechanisms which are resolved at synthesis-time.

%Tables \ref{tab_results_xilinx_edif} and \ref{tab_results_xilinx_vhdl} also compares
%the synthesis results of the designs synthesized from SystemC using
%Agility with a design implemented by hand in VHDL and fully synthesized
%using Xilinx's tools. Both the \emph{Normal scheduler} and the \emph{VHDL scheduler}
%are semantically equivalent and differ only in the syntax defined by SystemC
%and VHDL, respectively, however, the SystemC scheduler occupies $46\%$ more area
%and is $97\%$ slower than the VHDL scheduler, showing that SystemC synthesis
%is still an open issue even for RTL designs.

%-Discussion
%*scenario adapted scheduler - scheduler with hand-coded debugging = 
%this technique overhead (we hope it is not too high)
%*Original VHDL scheduler much more efficient. This just shows that Agility's
%SystemC synthesis is not very efficient
%*Comment something about Agility's direct synthesis results


%\tabTC{tab_results_xilinx_vhdl}
%{Hardware resources used when synthesizing the VHDL generated by Agility.}



\section{Conclusion}
\label{CONCLUSION}
In this paper we have introduced an AOP-based method for designing
hardware components using SystemC. We have shown how our domain engineering strategy 
can be applied design by modeling a 
flexible task scheduler. The scheduler's dependencies from a specific
execution scenario were encapsulated and further applied to the core
component through the use of a scenario adapter and configurable
features.

In comparison with other approaches, we have focused in the design
of synthesizable hardware components, rather than verification and
simulation-only models. The results showed that
our design artifacts can be synthesized and introduce a negligible
overhead in the generated components.

\section*{Acknowledgments}
This work was partially supported by the 
\emph{Coordination for Improvement of Higher Level Personnel}~(CAPES) grant,
projects RH-TVD 006/2008 and 240/2008, and by the \emph{German Research Council}~(DFG)
under grant no. SCHR 603/7-1.

\bibliographystyle{IEEEtran}
\bibliography{paper}

\end{document}
