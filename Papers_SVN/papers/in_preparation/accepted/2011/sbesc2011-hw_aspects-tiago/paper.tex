\documentclass[10pt, conference, compsocconf]{IEEEtran}

\usepackage[latin1]{inputenc}	% for Latin languages
\usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support
\usepackage{graphicx}
%\usepackage{multirow}
%\usepackage{subfig}

\include{utils} %new commands 


\begin{document}

\title{A Case Study of AOP and OOP applied to digital hardware design}

\author{Tiago R. Mück\IEEEauthorrefmark{1}
Michael Gernoth\IEEEauthorrefmark{2}
Wolfgang Schröder-Preikschat\IEEEauthorrefmark{2}
Antônio A. Fröhlich\IEEEauthorrefmark{1}
\\
\\
\begin{tabular}{cc}
\IEEEauthorrefmark{1}Software/Hardware Integration Lab & \IEEEauthorrefmark{2}Department of Computer Science 4\\
Federal University of Santa Catarina & Friedrich-Alexander University Erlangen-Nuremberg\\
Florian\'{o}polis, Brazil & Erlangen, Germany\\
\{tiago,guto\}@lisha.ufsc.br & \{gernoth,wosch\}@cs.fau.de
\end{tabular}
}

\maketitle

%TODO Claim that one of the reasons to use the debug aspects is because
% they require the addition of new input/output ports to the modules
% (i.e. they modify the interface). This will not happen with the 
% other aspects

\begin{abstract}
In this paper we explore a SystemC-based hardware design method which uses
aspect-oriented programming concepts. We have designed a synthesizable resource
scheduler at register transfer level by using only features available in the
SystemC synthesizable subset. The results show that aspect-oriented programming
applied to digital hardware design provides a better separation of concerns at the cost of a
negligible overhead.
\end{abstract}

\begin{IEEEkeywords}
Aspect-oriented programing, digital hardware design, reconfigurable hardware
\end{IEEEkeywords}

\section{Introduction}
\label{INTRO}
%Hw design problem, complexity, etc.
%Solution is reuse: OOP solved problems in SW, now in HW too
The complexity of embedded system design is increasing  much faster than the
design and verification capability of developers. This has led to the
introduction of solutions and methodologies that had been successfully deployed
in the scope of large-scale software systems. For example,
\textit{object-oriented programming}~(OOP), which is supported in the hardware
domain by languages like SystemC.

%In this paper we explore ... (describe solution)
%AOP, AOP increases OOP expressiveness ...
%Our proposal...
In this paper we explore the use of \textit{Aspect-oriented programming}~(AOP)
techniques for hardware design. We redesigned the hardware implementation of an
operating system task scheduler~\cite{Marcondes:2009:2} by leveraging on SystemC
features in order to enable the use of OOP and AOP concepts. AOP was applied by
using a domain engineering strategy that yields components in which the
dependencies from the execution scenario are encapsulated as \emph{aspects}. In
order to obtain an efficient and synthesizable component, our scheduler was
designed at the \textit{register transfer level}~(RTL) by using standard C++
metaprogramming features within the SystemC synthesizable
subset~\cite{systemc_subset}. 

%The remaining of this paper is organized as follows...
The remaining of this paper is organized as follows: section \ref{ASPECTS}
introduces AOP concepts and gives a contextualization of its use on the hardware
domain; section \ref{RELATED_WORK} presents a discussion about related work;
section \ref{PROPOSAL} presents our design artifacts; sections \ref{SCHED} and
\ref{RESULTS} describe the implementation of our scheduler and show our
experimental results; section \ref{CONCLUSION} closes the paper with our
conclusions.

\section{Aspect-oriented programming}
\label{ASPECTS}
%-Introduction to AOP\cite{Kiczales:1997}
%from OOP to AOP
%separation of cross-cutting concerns
%Advice, pointcut and aspect
In the software domain, the use of machine code had evolved naturally to
procedural languages and then to OOP. An enormous productivity improvement
resulted from the increased level of abstraction. However, OOP still have some
limitations in the way it allows a complex problem to be broken up into reusable
abstractions. Even though most classes in an object-oriented model will perform
a single function, they often share common, secondary requirements with other
classes. The implementation of these \emph{crosscutting concerns} is scattered
among the multiple abstractions, thus breaking the encapsulation principle. AOP
is an elaboration over OOP to deal with the crosscutting concerns. AOP proposes
the encapsulation of these concerns in special classes called \emph{aspects}.
An aspect can alter the behavior of the base code by applying \emph{advices} 
(small pieces of code defining additional behavior) in specific points of a program 
called \emph{pointcuts}. Some extensions to OOP languages have been proposed to 
support these new concepts. For example, AspectJ~\cite{Kiczales:2001} and
AspectC++~\cite{Spinczyk:2002} extend Java and C++ with full support for AOP
features. They provide both new language constructs and an \emph{aspect weaver},
a tool responsible for applying the advices to the base code before it is
processed by the traditional compiling chain.

%-First glance of AOP in hardware
%Talk about OOP in hardware
%OOP X AOP in hardware
%Possible application of AOP in hardware (show examples)\cite{Engel:2008,
%FengLiu:2009, Bainbridge-Smith:2005}\newline
Recently, there has been a growing interest in high-level methodologies for
hardware design as well. An example of a \textit{hardware description
language}~(HDL) which supports OOP is SystemC; a C++ based modeling platform
and language supporting design abstractions at the register transfer,
behavioral, and system levels~\cite{Panda:2001}. However, analogous to software,
in hardware some system-wide cross-cutting concerns cannot be elegantly
encapsulated. For example, in complex circuits, interconnection of several
entities is realized by introducing buses. A bus physically interacts with other
components (e.g. CPU, DMA, ...), but it is difficult to use a module or a class
to encapsulate the bus because its interface and arbitration method has to be
implemented in every attached component. Other examples of crosscutting concerns
in hardware designs can be also found in parts of a system related to its
overall functionality or the implementation of non-functional properties (e.g.
clock handling and hardware debugging through JTAG scan chains). Even with the
introduction of OOP in hardware, this scattered code is hard to maintain and
bugs may be easily introduced. The introduction of AOP  to hardware design is
expected to provide the easy encapsulation of cross-cutting concerns and an
increase in the overall design quality. 

%maybe join this section with the next one or with the introduction.

\section{Related work}
\label{RELATED_WORK}
%the related works count in each paragraph will depend on the number of pages remaining.

%works discussing AOP in hardware
%\cite{Engel:2008} - AOP discussion and proposed VHDL extension / no implementation\newline
%\cite{Bainbridge-Smith:2005} - AOP discussion and proposed new language / few details\newline
%\cite{Burapathana:2005} - very low-level HW design / discussion and proposal /
%no implementation\newline
Several works have already proposed the use of AOP concepts for hardware design.
In \cite{Engel:2008} the authors discussed the nature of crosscutting concerns
in VHDL-based hardware designs. They have proposed a hypothetical AOP extension
for VHDL in which the execution of a process and the setting of a signal are
used as pointcuts. However, the work lacks a concrete implementation and an
evaluation of the impact of AOP in the design. In \cite{Bainbridge-Smith:2005} 
the authors discussed how the separation of concerns may relate to different
levels of algorithmic abstraction. They have mentioned the development of ADH, a
new HDL based on AOP, but further details about ADH are not mentioned. In
\cite{Burapathana:2005} the use of AOP concepts to sequential logic design was
proposed. Nevertheless, they focused on very simple and low level examples like
flip-flops and logic gates on which only the clock can be feasibly handled as
a crosscutting concern.

%works that focus on verification
%\cite{Endoh:2008} - high-level components verification / simulation only / SystemC+AspectC++ and SpecC\newline
%\cite{Kallel:2010} - TLM\cite{Cai:2003} verification / simulation only / SystemC+AspectC++\newline
%\cite{Liu:2010} - high-level power estimation / simulation only / SystemC+AspectC++\newline
%\cite{Vachharajani:2004} - high-level specification (but AOP features only for
%verification)/ simulation only / new language\newline
There are also several works which proposed the use of AOP concepts mostly for 
hardware verification. In \cite{Endoh:2008}, AOP was used to enable
assertion-based verification in high-level hardware design, in which assertions
are based on pointcuts instead of specifiers to signal changes. They have
designed and implemented two assertion languages with pointcut-based assertions,
ASystemC and ASpecC, which work alongside SystemC and SpecC, respectively.
ASystemC uses pointcut of AspectC++, and its implementation translates
assertions into aspects of AspectC++. \cite{Kallel:2010} also proposed the use
of SystemC and AspectC++ to implement assertion checkers. The authors focused on
the verification of transaction-level models (TLM) in which transaction state
updates are used as pointcuts. They provide a framework in which the user
verification classes extend the base aspect classes that implement the pointcuts
and verification. 

Other proposal that focus only on
hardware verification can be seen in \cite{Vachharajani:2004}, in which the
authors developed the \textit{Liberty Structural Specification Language}~(LSS).
In LSS each module can declare that its instances emit certain events at
runtime. These events behave like pointcuts of AOP. Each time a certain state is
reached or a value is computed, the instance will emit the corresponding event
and user-defined aspects will perform statistics calculation and reporting.
\cite{Liu:2010} also proposed AOP-based instrumentation, but focusing high-level
power estimation.  They have developed a methodology based on SystemC in which
AspectC++ is used to define special power-aware aspects. These aspects are used
as configuration files to link power aware libraries with SystemC models.

%works that focus on design
%\cite{Deharbe:2006} - component design and verification / simulation only / SystemC+AspectC++\newline
%\cite{Vax:2007} - modeling and verification (mainly) / simulation only / new language\newline
%\cite{FengLiu:2009} - component design / simulation only / SystemC+AspectC++\newline
%\cite{Jun:2009} - FOP+AOP for hardware design / simulation-only /
%SystemC\newline
Other works provide AOP features not only for verification, but also for the
actual
design of hardware. \cite{Deharbe:2006} present and assess possible applications
of AOP in the context of integrated system design by using SystemC with
AspectC++. Differently from the works discussed previously, they showed how AOP
can be used to encapsulate some functional characteristics of hardware
components. They modeled as aspects the replacement policy of a cache, the data
type of an FFT, and the communication protocol between modules. However, only
simulation results are shown and they do not compare the implementation of
aspect-based components against components with all the functionalities
hard-coded. In a similar work, \cite{FengLiu:2009} implemented a SystemC model
for a 128-bit floating-point adder and described the implementation of the same
model using AOP techniques. But, synthesis results are not provided and the two
models are compared only in terms of functionality to show that the AOP design
works like the original SystemC-only design. 

Other works in this area follow different approaches. The \emph{e} programming
language~\cite{Vax:2007} was designed for modeling and verification of
electronic systems and some of its mechanisms can be used to support AOP
features. Apart from its OOP features, \emph{e} has some constructs to define
the execution order of overloaded methods in inherited classes, which can be
used to define pointcuts and implement aspects. Indeed, this can be used to
implement the behavior of hardware components, but \emph{e} is more focused in
high-level specification and there is not any tool support for synthesis. 

%-Discussion
%Most works focus on high-level specification and verification
%There are no related work aiming at using aspects for the actual
%design of synthesizable hardware
%In summary, several of the previous works have focused on high-level
%specification and AOP features are used mostly for code instrumentation and
%verification. Also, there are not any related work aiming at using AOP for the
%actual design of synthesizable hardware, since, as discussed above, all works
%present experiments only at the simulation level and lack a more comprehensive
%discussion about the overheads related to the use of AOP.

\section{Designing a hardware using AOP}
\label{PROPOSAL}

%-Introduction
%Introduction to ADESD (previously known as AOSD\cite{Froehlich:2001})
%Use the techniques proposed by ADESD and implemented in C++ to
%implement HW components in SystemC
%Maybe include the classic ADESD figure

%OBS.: começar falando que vamos aplicar AOP em HW usando conceitos da ADESD ao
%invés de sair falando de cara sobre cenário adapters.
Similarly to previous works, we also based our approach on methodologies
which have been used in the software domain. The \textit{Application-driven
Embedded System Design} (ADESD) \cite{Froehlich:2001} methodology elaborates on
commonality and variability analysis---the well-known domain decomposition
strategy behind OOP---to add the concept of aspect identification and separation
at early stages of design. It defines a domain engineering strategy focused on
the production of families of scenario-independent components. Dependencies
observed during domain engineering are captured as separate \emph{aspect}, thus
enabling components to be reused on a variety of execution scenarios with the
application of proper \emph{aspects}. This aspect weaving is performed by
constructs called \emph{Scenario adapters}\cite{Froehlich:2000}.

The design artifacts proposed in ADESD were implemented and validated on the
\textit{Embedded Parallel Operating System} (EPOS) \cite{Froehlich:2001}. EPOS
aims to automate the development of dedicated computing systems, and features a
set of tools to select, adapt, and plug components into an application-specific
framework, thus enabling the automatic generation of an application-oriented
system instance. EPOS is implemented in C++ and leverages on \emph{generic
programming}~\cite{Czarnecki:2000} techniques such as \emph{static
metaprogramming} in order to achieve high reusability with low overhead. 

The next sections describe some of these design artifacts and how we have
applied them in the implementation of our hardware scheduler.

%-Describe the design artifacts
%Describe the artifacts belows in terms of hardware (with signals, etc)

\subsection{Scenario adapters}
%Scenario adapters\cite{Froehlich:2000}.

Scenario adapters were developed around the idea of components getting in and
out of an execution scenario, allowing actions to be executed at these points,
therefore, a scenario must define at least two different operations:
\emph{enter} and \emph{leave}. These actions must take place respectively before
and after each of the component's operation in order to setup the conditions
required by the scenario. For example, in a compressed scenario, enter would be
responsible to decompress the component's input data, while leave would compress
its outputs.

In the software domain, components are objects which communicate using method
invocation (considering an OOP-based approach) and the execution of all
operations are naturally sequential, so the scenario adapters were originally
developed to provide means to just efficiently wrap the method calls to an
object with enter and leave operations. However, in the hardware domain,
components have input and output signals instead of a method or function
interface, and all operations are intrinsically parallel. These different
characteristics required some modifications on the original scenario adapter.
The new scenario adapter is shown in figure
\ref{fig_scenario_adapters_uml_detail}.

\fig{.4}{fig_scenario_adapters_uml_detail}
{UML class diagram showing the general structure and behavior of a scenario
adapter.}

SystemC defines hardware components by the specialization of
the \emph{sc\_module} class. Components communicate using special objects called
\emph{channels}. SystemC channels can be used to encapsulate complex
communication protocols at register transfer or higher levels of abstraction.
However, these complex channels lie outside the SystemC synthesizable subset, so
we use only \emph{sc\_in} and \emph{sc\_out}, which define simple input and
output ports for components. Methods which implement the component's behavior
must be defined as SystemC processes. In our examples we use SystemC clocked
threads (\emph{SC\_CTHREAD}), in which all operations are synchronous to a clock
signal. The implementation of the \emph{Component::controller} method in figure
\ref{fig_scenario_adapters_uml_detail} shows the common behavior of a
\emph{SC\_CTHREAD}. SystemC \emph{wait()} statements must be used to synchronize
the operations with the clock, in other words, all operations defined between
two \emph{wait()} statements occur in the same clock cycle.

Using these constructs, we define each aspect as a single and independent
hardware component (\emph{Aspect} class). \emph{Enter} and \emph{leave}
operations are defined using a simple handshaking protocol (\emph{op\_rdy\_out}
and \emph{op\_req\_in} signals) to trigger its execution. The remaining
input/output ports define which operation are being triggered (this is specific
of each aspect). With this kind of handshaking communication protocol we can
produce more reusable components, since the number of clock cycles it requires
for each operation is hidden by the protocol, thus making it easier to
synchronize component execution with the rest of the design.

The \emph{Scenario} class incorporates, via aggregation, all of the aspects
which define its characteristics. It defines \emph{enter} and \emph{leave}
methods to encapsulate the implementation of the handshaking protocol which
trigger the aspects. Figure \ref{fig_scenario_adapters_uml_detail} shows how the
scenario's \emph{enter} operation is implemented. All aspects are triggered at
the same time and executes in parallel, however, if required by the scenario,
this can be modified in order to execute each aspect sequentially at the cost of
additional clock cycles. 

The adaptation of the component to the scenario is performed by
the \emph{Scenario Adapter} class via inheritance. This adaptation is possible
through the separation of the component's input/output protocol from the
implementation of its behavior. A SystemC process (\emph{controller} method)
handles the input/output protocol (\emph{behavior} method) and calls the
requested operations, which are each implemented in its own methods. These
methods are overridden in the \emph{Scenario Adapter} class. Notice that,
although scattered through a class hierarchy and different methods, all
operations (from the handling of the component's input/output protocol, to the
triggering of the aspects) executes inside the \emph{controller}
\emph{SC\_CTHREAD} process. For the proposed scheme to work, \emph{wait()}
statements are also used to schedule the operations among the clock cycles,
instead of defining explicit state machines. If the latter is used, it would not
be possible to elegantly implement the structure described in figure 
\ref{fig_scenario_adapters_uml_detail}, since a state machine would require 
manual intervention to add the operation defined by the scenario.


\subsection{ADESD and classic AOP}
%-Discussion: ADESD X classic AOP (for hardware design)
%Basically, needs to justify the use of the above artifacts for HW design
%instead of other stuff proposed by other authors
%Using AspectC++ for example allows for full AOP in SystemC 
%(more powerful then scenario adapters), so why don't we use it ?
%The resulting code is not synthesizable, AspectC++ introduces dynamic pointers
%and objects outside the SystemC synthesizable subset (strong claim, actually needs further
%investigation)
%Most of the examples in the related works used have design problems that could be 
%more elegantly solved using other techniques rather than AOP (e.g. inheritance, 
%template parameters -- when using C++/SystemC)\cite{Afonso:2007, Deharbe:2006}
%The remaining problems can be easily solved by scenario adapters
%Only standard languages features are used. No extensions or extra tools are required.
%Can use OOP + scenario adapters + static metaprogramming and still remains within the
%SystemC synthesizable subset.
%Maybe talk something about homogeneous and heterogeneous crosscutting~\cite{Jun:2009}

Several previous works have already discussed aspect-oriented hardware design 
using SystemC and proposed solutions based on classic AOP concepts using the
well known AspectC++ language. Indeed, AspectC++ provides more powerful
mechanisms for aspect implementation then ADESD, especially when it comes to the
definition of the pointcut, however, this additional mechanisms are usually
either unnecessary or can be efficiently replaced. For example, the aspects
implemented in \emph{D\'{e}harbe and Medeiros}~\cite{Deharbe:2006}~(section
\ref{RELATED_WORK}) could be more elegantly implemented using other standard
C++ features like inheritance and templates parameters. In the scope of ADESD,
we can say that scenario adapters can be used to implement \emph{homogeneous
crosscutting}~\cite{Jun:2009} (the process of adding the same behavior for all
classes). \emph{Heterogeneous crosscutting}~\cite{Jun:2009}(when concern is
specific to a certain component or family of components) can be easily
implemented with standard OOP (e.g. inheritance).
Additionally the implementation of ADESD's mechanisms can be realized using only
standard SystemC features. Previous works focus on tools and languages which
were deployed only for software development (e.g. AspectC++), which limits its
use for the generation of synthesizable hardware.

\section{Scheduler implementation}
\label{SCHED}

Our case study is based on a previous implementation of the EPOS scheduler
described by \cite{Marcondes:2009:2}, which described a task scheduling
suitable for hardware and software implementation. However, the original VHDL
implementation was not susceptible to the same mechanisms that render its
software counterpart flexible and reusable. The new System-based hardware
scheduler is described below.

Figure \ref{fig_schduler_model_uml} shows a simplified view of the task
scheduling model. In this design, the task is represented by the class
\emph{Thread} and defines the execution flow of the task, implementing 
the traditional functionality (e.g. suspend and resume operations). 
The classes \emph{Scheduler} and \emph{SchedulingCriteria} define the 
structure that realizes the task scheduling. Traditional design and 
implementations of scheduling algorithms are usually done by a hierarchy
of specialized classes of an abstract scheduler class, which can
be further specialized to bring new scheduling policies to the system. 
In order to reduce the complexity of maintenance of the code (generally present in
such hierarchy of specialized classes), as well as to promote its reuse,
the design detaches the scheduling policy (criteria) from its mechanisms 
(lists implementations) and also detaches the scheduling criteria from the 
thread it represents.  This is achieved by the isolation of the element's comparison
algorithm of the scheduler in the criteria.

\fig{.55}{fig_schduler_model_uml}
{Simplified UML view of the task scheduling model}

\subsection{Hardware implementation}

The separation of the mechanism from the scheduling policy was fundamental
for the construction of the scheduler in hardware. The hardware scheduler
component implements only the mechanisms that realize the ordering of the
tasks, based on the selected policy. In this sense, the same hardware 
component can realize distinct policies.

The implementation of the scheduler in hardware follows a well-defined structure. 
It has an internal memory that implements an ordered list. One process (\emph{Controller})
is responsible for interpreting all the data received by the interface of
the component in hardware and then to activate the process responsible for implementing
the functionality requested by the user (through the command interface register). This
implementation, as the software counterpart, realizes the insertion of its elements
already in order, that is, the queue is always maintained ordered, following the
information that the \emph{SchedulingCriteria} provides.

\subsection{Aspects implementation}

We have implemented aspects for debugging. Unlike previous works~\cite{Vachharajani:2004,Liu:2010},
which focused on simulation-time tracing and logging, we have implemented
aspects for on-chip debugging. Figure \ref{fig_debug_aspects_uml} shows
the debugged family of hardware aspects. The class~\emph{DebuggedCommon}
defines common ports for all aspects. Besides the ports used for clock 
and reset, it defines outputs for a JTAG debug protocol~(\emph{trigger\_out}
and \emph{data\_out}) and for the enter/leave protocol~(\emph{op\_rdy\_out} and
\emph{op\_req\_in}). The input values for the ports defined
by the subclasses determine which operation will be triggered.

\fig{.55}{fig_debug_aspects_uml} {The debugged family of hardware aspects}
\fig{.55}{fig_adapted_sched_diagram_uml}{Scheduler modified by the scenario
adapter}

\tabTC[ht]{tab_results_xilinx_edif}
{Hardware resources used after placing and routing Agility's netlists.}

The aspects implemented define the following debugging functionalities: 
\emph{Watched} causes the state of a component to be dumped every time 
it is modified; \emph{Traced} causes every operation execution to be 
signalized; and \emph{Profiled} counts the number of clock cycles used
by the component for each operation.


\subsection{Scenario adapter implementation}

Figure \ref{fig_adapted_sched_diagram_uml} shows how we applied the aspects
to the scheduler using a scenario adapter (for simplicity, some details,
such as methods, ports, and hierarchies, are omitted). The implementation follows
the guidelines depicted in figure \ref{fig_scenario_adapters_uml_detail}.
The class \emph{Scheduler} defines the scheduler component. The \emph{controller}
SystemC process is responsible for reading the component inputs and calling the method which
implements the corresponding operation. The class \emph{AdaptedScheduler}
implements the scenario adapter. It inherits from the \emph{Scheduler}
and \emph{Debugged} classes, and redefines the operation methods by 
adding calls to the \emph{enter} and \emph{leave} methods of \emph{Debugged}.
The \emph{Debugged} class defines the scenario and its methods implement
the handshaking protocol that triggers the aspects components. %The debug information
%generated by the aspects is forwarded to outputs defined by the scenario.


\section{Results}
\label{RESULTS}

%Compare: raw scheduler X scenario adapted scheduler X scheduler with
%hand-coded debugging X original VHDL scheduler (from Hugo's work)
%Synthesis results (describe tools and target device. Celoxica's Agility
%synthesizes SystemC to VHDL, and all VHDL is synthesized using Xilinx's
%tools. Also compare the results of Xilinx tools with Agility's-generated
%netlist) through

We synthesized the SystemC designs described previously using Celoxica's Agility
1.3. They were synthesized to VHDL and EDIF formats targeting a Xilinx Spartan3
XC3S2000 FPGA. The final place-and-route was performed using Xilinx ISE 12.3.
All the synthesis processes were executed with all the optimization enabled.
Table \ref{tab_results_xilinx_edif} shows the
results. \emph{Normal scheduler} is the scheduler component without any
modification, \emph{Debugged scheduler---scenario adapter} is the scheduler
modified with the scenario adapter while \emph{Debugged scheduler---hand coded}
is the scheduler with the aspects functionalities hand coded. Table \ref{tab_results_xilinx_edif}
also shows the debugged family synthesized in isolation.

%\tab[ht]{tab_results_agility_est}
%{Hardware resources estimated by Agility.}

The results show that the use of scenario adapters yields a very low overhead in terms of both
resource consumption and performance.  For the scenario-adapted scheduler, the number of occupied
slices is about $1\%$ higher than the hand-coded scheduler. This overhead comes basically from the
additional signal and registers required by the handshaking protocol that is used to trigger the
aspects, which is not required when everything is coded within a single SystemC process. The
difference in performance (given by the longest path delay) is about $3\%$. Curiously, in the final
place-and-routed designs, the hand-coded scheduler has the smaller longest path delay.
This may be the result of some optimization algorithm applied in the place-and-route backend.

%Also, the modularized structure of the
%scheduler does not yield any overhead since it is based on static mechanisms
%which are resolved at synthesis-time.

%Tables \ref{tab_results_xilinx_edif} and \ref{tab_results_xilinx_vhdl} also compares
%the synthesis results of the designs synthesized from SystemC using
%Agility with a design implemented by hand in VHDL and fully synthesized
%using Xilinx's tools. Both the \emph{Normal scheduler} and the \emph{VHDL scheduler}
%are semantically equivalent and differ only in the syntax defined by SystemC
%and VHDL, respectively, however, the SystemC scheduler occupies $46\%$ more area
%and is $97\%$ slower than the VHDL scheduler, showing that SystemC synthesis
%is still an open issue even for RTL designs.

%-Discussion
%*scenario adapted scheduler - scheduler with hand-coded debugging = 
%this technique overhead (we hope it is not too high)
%*Original VHDL scheduler much more efficient. This just shows that Agility's
%SystemC synthesis is not very efficient
%*Comment something about Agility's direct synthesis results

%\tabTC{tab_results_xilinx_vhdl}
%{Hardware resources used when synthesizing the VHDL generated by Agility.}

\section{Conclusion}
\label{CONCLUSION}
In this paper we have shown how a domain engineering strategy and AOP techniques can be applied to
design and implement a flexible task scheduler in hardware. The scheduler's dependencies from a
debugging execution scenario were encapsulated in aspects and further applied to the core component
through the use of a scenario adapter, thus providing a better separation of concerns. The results
showed that our design artifacts can be synthesized and introduce a negligible overhead in the
generated components.

\section*{Acknowledgments}
This work was partially supported by the \emph{Coordination for Improvement of
Higher Level Personnel}~(CAPES) grant, projects RH-TVD 006/2008 and 240/2008,
and by the \emph{German Research Council}~(DFG) under grant no. SCHR 603/7-1.

\bibliographystyle{IEEEtran}
\bibliography{paper}

\end{document}
