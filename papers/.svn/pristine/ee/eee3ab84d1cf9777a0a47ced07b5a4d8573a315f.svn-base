\documentclass[a4paper,english,10pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{babel}
\usepackage{times}
\usepackage{graphics}
\usepackage[margin=3cm]{geometry}

\input{terms}

\newcommand{\tm}[1]{\textsc{#1}}
\newcommand{\sym}[1]{\texttt{#1}}
\newcommand{\refsec}[1]{[section~\ref{sec:#1}]}

\newcommand{\fig}[3][htbp]{
  \begin{figure}[#1]
    \centering\includegraphics{fig/#2}\par
    \caption{#3\label{fig:#2}}
  \end{figure}}

\title{An Strategy to Develop Component Frameworks\\
  for Distributed Computing\\
  \large{--- extended abstract ---}}
%  \thanks{The research work described in this article has been partially
%  supported by Fraunhofer FIRST.}}

%\author{
%  Antônio Augusto Fröhlich\\
%  UFSC/CTC/LISHA\\
%  PO Box 476\\
%  88049-900 Florianópolis - SC, Brazil\\
%  guto@inf.ufsc.br}

\author{
  Antônio Augusto Fröhlich\\
  Fraunhofer FIRST\\
  kekuléstraße 7\\
  12489 Berlin, Germany\\
  \texttt{guto@first.fhg.de}\\
  \texttt{http://www.first.fhg.de/$\sim$guto}}

\date{}

\bibliographystyle{alpha}

\begin{document}

\maketitle

%\section{Introduction}

%The advent of software engineering techniques that support the
%construction of systems as arrangements of software components might
%incorrectly lead one to believe that, by adopting such techniques, it
%would be possible to construct run-time support systems with a high
%degree of customizability. In particular, parallel applications could
%benefit from statically configurable run-time support systems, thus
%avoiding the high price of dynamic reconfiguration.

%Nevertheless, a repository of components and a mechanism to arrange them
%together may not suffice to comply with the requirements of distributed
%applications.  Ordinary run-time support systems frequently fail to
%deliver the expected services, or the expected service
%quality~\cite{Anderson:1992a, Maheshwari:1994}.  Slicing one such a
%system in a set of components will certainly not improve the case for
%applications.

% The method explores commonality and
%variability analysis during domain decomposition to model families of
%highly reusable, adaptable, application-ready abstractions, isolating
%scenario aspects and capturing fragments of reusable system
%architectures.  The refinement of design entities identified during
%domain analysis is subsequently approached, considering peculiarities in
%regard to the organization of abstractions in families, the conciliation
%of family members under a common interface, the modeling of scenario
%aspects that can be transparently applied, and representation of
%architectural aspects in component frameworks.  Afterwards,
%considerations about the implementation of \aosds\ are stated,
%emphasizing implementations in the \cpp\ programming language.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{The Case for Application-Orientation\label{sec:case}}
\section{Introduction}

% + What's wrong with contemporary operating systems in general?
%   - Suffocated by standards {Pike:2000}
%   - Conceived for hardware + standards, not for applications
%   - Out of date with modern software engineering
%   - How can CBSE fail?
%   - Customizability = user-driven configuration (Linux case)
% + What's wrong with operating systems for dedicated systems?
%   - Offer much more than was required
%   - Do not deliver what is needed
% + How application-orientation can help?
%   - SO only implements what is needed and delivers as requested
%     - Scales with architecture AND APPLICATIONS
%     - Automatic configuration and generation 

% Suffocated by standards {Pike:2000}
Historically, operating systems have been constructed aiming at
abstracting physical resources in a way that is convenient to the
hardware, not to applications.  Undoubtedly, the monolithic structure of
early operating systems contributed to this scenario, for it must have
been very difficult, if not impracticable, to customize such systems in
order to accomplish the demands of particular applications. The notion
that applications have to be adapted to the operating system was so
established. Since then, a succession of standardizations has been
freezing application program interfaces~(API), thus helping to
consolidate the situation.  Consequently, contemporary operating systems
are suffocated by thick layers of standards that prevent internal
improvements from reaching applications~\cite{Pike:2000}.

% Out of date with modern software engineering
Besides failing to accompany the natural evolution of applications, many
operating systems also fail to keep updated as regards software
engineering. Perhaps this is also a consequence of extreme
standardization, whereas there is little room for novel software
engineering concepts in the constrained realm of operating systems.
Astonishingly, this is a very complex software domain, spanning from
hardware to applications, and would greatly profit from modern software
engineering techniques. In reality, however, the obsolescence of the
techniques deployed in some systems comes out to
impact applications. %, as it is the case with \windows\ infamous
%crashes~\cite{Kabay:2000}.

% Conceived for hardware + standards, not for applications
Even modern systems that support customization have difficulties to
match up with application requirements. Mainly because they usually
target the design of configurable features, the heart of any
customization strategy, on standard compliance and on hardware aspects,
and do not adequately address application requirements.  Hence, an
application programmer may be invited to select features such as \posix\ 
or \textsc{TCP/IP} compliance, or to select drivers for a certain
hardware device, but seldom will have the chance to select a distributed
object infrastructure. Deploying a general-purpose operating system to
support distributed applications is likely to result in a situation
where applications get uncountable services that are not needed, but
still have to implement much of what is needed. This also leads to the
phenomenon that transforms standard APIs, such as \corba, in middleware
layers.  A properly constructed run-time support system could deliver
its services under a variety of APIs, eliminating such middleware
layers.

% How can CBSE fail?
Building a system as an aggregate of reusable components has the
potentiality to considerably improve the case for applications.
Nevertheless, component-based software engineering is just a means to
construct systems that can be customized to fulfill the demands of
particular applications.  Inadequately modeled components, or inadequate
mechanisms to select and combine components, may render the extra effort
of building reusable software components unproductive. The goal of
application-driven customization can only be achieved if the system as a
whole is designed considering the fulfillment of application
requirements.

% Customizability = user-driven configuration
Furthermore, the way customization is typically carried out in
component-based systems makes it difficult to pair with application
requirements.  As a rule, customization in these systems is delegated to
end users, which are assisted by some sort of tool in selecting and
combining components to produce an executable system.  In this case,
successfully customizing the system becomes conditioned to the knowledge
the user has about it. Hence, user-driven customization is entangled in
the balance of component granularity:

\begin{itemize}
\item If components are \emph{coarse-grained}, the chance of an ordinary
  user, i.e., a user without deep knowledge about the system, to
  successfully conduct customizations grows, but the probability that
  components will meet application requirements decreases
  proportionally.
\item If components are \emph{fine-grained}, the chance that the system
  will match application requirement grows, but it is likely that users
  will not be able to understand the peculiarities of such a large
  collection of components, probably missing the most adequate
  configurations.
\end{itemize}

% The Linux case
Improvements in user-driven configuration have been pursued by enabling
components to be selected indirectly. The \linux\ system, for instance,
utilizes a mechanism to select kernel components through the features
they implement.  Instead of pointing out which components will be
included in the system, users can select the desired system features.
Features, in turn, are interrelated by dependencies and mapped into
components.  Nevertheless, even if \linux\ kernel components are
coarse-grained (they are mainly device drivers and subsystems) and will
seldom satisfy the specific requirements of individual applications,
selecting features from a list with approximately 700
options\footnote{The number of \linux\ configurable kernel features has
  been estimated by executing the following command in a system based on
  kernel version 2.2.14: \sym{grep CONFIG
    /usr/src/linux/configs/kernel-2.2.14-i386.config | wc -l}.} is a
sordid activity. A mechanism that allows applications themselves to
guide the configuration process would be more appropriate.

% Feature based ??? Wosch said: a few features can select many components,
% easing with user-friendship, but I have no example for that so far.
%A more elaborate approach, also based on feature selection, has been
%used by Beuche at al.~\cite{Beuche:2000} to handle configuration in
%systems with a large amount of fine-grained components. Although this
%strategy was able to efficiently handle complex configurations, it did
%not target end users, but operating system developers with enough
%expertise about the system. 

% SO only implements what is needed and delivers as requested
%   Scales with architecture AND APPLICATIONS
%   Automatic configuration and generation 
Notwithstanding, software engineering seems to be mature enough to
produce run-time support systems that, besides scaling with the
hardware, also scale with applications; that deliver all the
functionality required by applications in a form that is convenient for
them; and that deduce application requirements to automatically
configure itself. Many of the related issues have already been addressed
in the context of all-purpose computing by \emph{reflective systems}. In
order to comply with the requirements of high-performance distributed
applications, the subject is approached in this paper from the
perspective of statically configurable component-based systems. The
paper elaborates on the \emph{\AOSD} method~\cite{Froehlich:2001} to
delineate \emph{an strategy to develop component frameworks for
  distributed computing}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Domain Engineering}
%   + Domain Analysis
%     - The operating system realm as seen by applications
%     - Canonical partitioning X Families
%     - Families of abstractions
%     - Scenario independence
%     - Scenario adapters
%     - Reusable architectures
%     - Case study

% - OS -> conventions -> old -> standards -> solidified
% - {Pike:2000}
Although no design can go further than its perception of the
corresponding problem domain, domain analysis and run-time support
systems are subjects that seldom come together. The fact that the
operating system domain is basically made of conventions, many of which
established long ago in projects such as \thesys~\cite{Dijkstra:1968}
and \multics~\cite{Organick:1972}, seems to have fastened it to a
``canonical'' partitioning. This partitioning includes abstractions such
as process, file, and semaphore, and is taken ``as-is'' by most
designers. Indeed, it is now consolidated by standards on one side and
by the hardware on the other, leaving very little room for new
interpretations.

% - New perspectives (active objects)
% - Not as middleware!
Notwithstanding this, revisiting the problem domain during the design of
a new operating system would probably reveal abstractions that are
better tuned with contemporary applications. For example, the triple
(process, file, message passing) could be replaced by persistent
communicating active objects. Actually, most run-time platforms feature
this perspective of the operating system domain through a middleware
layer such as \corba~\cite{corba} and \java~\cite{java}. However, the
middleware approach goes the opposite direction of
application-orientation, whereas it further generalizes an already
generic system.

% - Traditional abstractions -> families
% - Analysis => vocabulary
% - Design => abstractions
% - Domain Analysis => all applications in a domain
Nevertheless, even if one endures domain analysis knowing that
decomposition will have to be carried out respecting the boundaries
dictated by standards, programming languages, and hardware, there is at
least one important reason to do it: to avoid the monolithic
representation of abstractions. If an \aoos\ is to be the output of
design, capturing application-specific perspectives of each abstraction
and modeling them as independently deployable units, as suggested by
\emph{\sop}~\cite{Harrison:1993}, is far more adequate than the
monolithic approach. After all, the product of domain engineering is not
a single system, but a collection of reusable software artifacts that
model domain entities and can be used to build several systems.


\subsection{Application-Oriented Domain Decomposition\label{sec:aodd}}

% AODD And OOD
An application-oriented decomposition of the problem domain can be
obtained, in principle, following the guidelines of
\emph{object-oriented decomposition}~\cite{Booch:1994}. However, some
subtle yet important differences must be considered.  First,
object-oriented decomposition gathers objects with similar behavior in
class hierarchies by applying variability analysis to identify how one
entity specializes the other.  Besides leading to the infamous ``fragile
base class'' problem~\cite{Mikhajlov:1998}, this policy assumes that
specializations of an abstraction (i.e. \emph{subclasses}) are only
deployed in presence of their more generic versions (i.e.
\emph{superclasses}).

Applying variability analysis in the sense of
\emph{\fbd}~\cite{parnas:1976} to produce independently deployable
abstractions, modeled as members of a family, can avoid this restriction
and improve on application-orientation.  Certainly, some family members
will still be modeled as specializations of others, as in
\emph{\isd}~\cite{habermann:1976}, but this is no longer an imperative
rule. For example, instead of modeling connection-oriented as a
specialization of connectionless communication (or vice-versa), what
would misuse a network that natively operates in the opposite mode, one
could model both as autonomous members of a family.

% Scenario-independence
A second important difference between application-oriented and
object-oriented decomposition concerns environmental dependencies.
Variability analysis, as carried out in object-oriented decomposition,
does not emphasizes the differentiation of variations that belong to the
essence of an abstraction from those that emanate from execution
scenarios being considered for it. Abstractions that incorporate
environmental dependencies have a smaller chance of being reused in new
scenarios, and, given that an \aos\ will be confronted with a new
scenario virtually every time a new application is defined, allowing
such dependencies could severely hamper the system.

Nevertheless, one can reduce such dependencies by applying the key
concept of \emph{\aop}~\cite{Kiczales:1997}, i.e.  aspect separation, to
the decomposition process.  By doing so, one can tell variations that
will shape new family members from those that will yield scenario
aspects.  
%\footnote{The representation of scenario aspects will be
%  discussed later in section~\ref{sec:sa}, for now it is only important
%  to avoid modeling unnecessary family members.}.
For example, instead of modeling a new member for a family of
communication mechanisms that is able to operate in the presence of
multiple threads, one could model multithreading as a scenario aspect
that, when activated, would lock the communication mechanism (or some of
its operations) in a critical section.

% - Why it gets scenario-dependent?
The phenomenon of mixing scenario aspects and abstractions seems to
happen spontaneously in most other design methods, thus learning to
avoid it might require some practice. Perhaps the most critical point is
the fact that systems are often conceived with an implementation
platform in mind, which is often better understood than the
corresponding problem domain.  In principle, there is nothing wrong in
studying the target platform in details before designing a system,
actually it might considerably save time, but designers tend to
misrepresent abstractions while considering how they will be implemented
in the chosen platform. In an \aosd, this knowledge about implementation
details should be driven to identify and isolate scenario aspects. In
general, aspects such as identification, sharing, synchronization,
remote invocation, authentication, access control, encryption,
profiling, and debugging can be represented as scenario aspects.

% Configurable features
Building families of scenario-independent abstractions and identifying
scenario aspects are the main activities in \aodd, but certainly not the
only ones. The primary strategy to add functionality to a family of
abstractions is the definition of new members, but sometimes it is
desirable to extend the behavior of all members at once.  Specializing
each member would double the cardinality of the family.  \Aosd\ deals
with cases like this by modeling the extended functionality as a
\emph{configurable feature}.  Just like scenario aspects, configurable
features modify the behavior of all members of a family when activated,
but, unlike those, are not transparent.  One could say that scenario
aspects have ``push'' semantics, while configurable features have
``pull''.

A configurable feature encapsulates common data structures and
algorithms that are useful to implement a family's feature, but leave
the actual implementation up to each family member.  Abstractions are
free to reuse, extend, or override what is provided in a configurable
feature, but are requested to behave accordingly when the feature is
enabled.

\fig[t]{aod}{An overview of \aodd.}

The case for configurable features can be illustrated with a family of
networks and features such as multicasting, in-order delivery, and error
detection.  If new family members were to be modeled for each such a
feature, a family of 10 networks subjected to 10 features could grow up
to $10^{10}$ members.  Modeling this kind of feature as a scenario
aspect is usually not possible either, since its implementation would
have to be specialized to consider particular network architectures.

%As an example, consider features such as multicasting, in-order
%delivery, and error detection in a family of networks. If new family
%members were to be modeled for each such a feature, a family of 10
%networks subjected to 10 features could grow up to $10^{10}$ members.
%Modeling this kind of feature as a scenario aspect is usually not
%possible either, since its implementation would have to be specialized
%to consider the peculiarities of each network architecture.  A
%configurable feature would be an adequate solution.

% Inter-family relationships
Another relevant issue to be considered during domain decomposition is
how abstractions of different families interact. Capturing ad-hoc
relationships between families during design can be useful to model
reusable software architectures, helping to solve one of the biggest
problems in component-based software engineering: how to tell correct,
meaningful component compositions from unusable ones. A reusable
architecture avoids this question by only allowing predefined
compositions to be carried out. For example, one could determine that
the members of a family of process abstractions must use the family of
memory to load code and data, avoiding an erroneous composition with
members of the file family.  In \aosd, reusable architectures are
captured in component frameworks that define how abstractions of
distinct families interact.  Although such frameworks are defined much
later in the design process, taking note of ad-hoc relationships during
domain decomposition can considerably ease that activity.
 
% Overview
An overview of \aodd\ is presented in figure~\ref{fig:aod}. In summary,
it is a multiparadigm domain engineering method that promotes the
construction of \aoss\ by decomposing the corresponding domain in
families of reusable, scenario-independent abstractions and the
respective scenario aspects. Reusable system architectures are
envisioned by the identification of inter-family relationships that will
later build component frameworks.

The full version of this paper will elaborate on these concepts to
delineate a systematic strategy to develop component frameworks for
distributed computing, including an analysis of distributed computing
domain and an overview of \epos, an \aoos\ that promptly serves
applications in this domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Families of Scenario-Independent Abstractions\label{sec:fa}}
%%   + Families of Abstractions
%%     + Abstractions
%%       - Application-ready and scenario-independent
%%       - Granularity
%%       - Components in AOSD (functional units) 
%%       - Interfaces
%%     + Families
%%       - Base class? (subtyping X subclassing)
%%       - Configurable features
%%       - Inter-family dependencies
%%       - NO relations due to code sharing

%During \aodd, scenario-independent abstractions are identified and
%grouped in families according to what they have in common. The
%subsequent phase in \aosd\ is the refinement of these abstractions in
%order to define the software components that will implement them.

%% Granularity
%The first refinement to be performed is the adjustment of the magnitude
%of components in relation to abstractions. The basic idea is to keep a
%1-to-1 relation, preserving conformity with the domain. However, it may
%happen that some entities in the domain are too coarse-grained to be
%modeled as a single component (e.g. a file system), or to primitive to
%be directly exposed to application programmers (e.g. an FPU). As
%explained earlier, excessively large components will likely miss the
%target on application-orientation, while excessively small components
%will likely flop on user-friendship.

%The balance ``as simple as possible, but still application-ready'' is
%the goal to be pursued in this phase of design.  Larger, more complex
%abstractions can be implemented as an assemblage of components, while
%elementary entities, that do not characterize abstractions, can be
%embedded in other components according to the criterion of functional
%cohesion. Data structures and algorithms that are common to several
%families of abstractions can be collected in \emph{utility classes} to
%be reused during the construction of actual components. Although a
%precise ``algorithm'' to reach such a balance does not exist,
%chapter~\ref{chp:epos} brings an extensive case study on \aosd\ that
%shall elucidate many of the issues related to abstraction granularity.

%For all practical effects, components in an \aosd\ will always be seen
%as direct emanations of abstractions, hence some granularity adjustments
%may have to be propagated back to the documents of domain analysis.
%This correspondence between abstractions and components helps to assure
%that an application programmer will never be called to interact with
%abstractions that are not directly being used, nor confronted with the
%fact that unnecessary abstractions have been included in the system. If
%a component encapsulates several abstractions and the application makes
%use of a single one, it is likely that the programmer will still have to
%configure the remaining abstractions, and that these extra abstractions
%will consume resources that otherwise could be used by the application.

%% ADT, interfaces
%After components and abstractions have been matched, each family of
%abstractions can be refined considering details about the structure and
%behavior of its members in order to ratify their interfaces. Ideally,
%application-orientated abstractions should be delivered as
%\emph{Abstract Data Types}~(ADT)~\cite{Liskov:1974}. In this case, each
%abstraction would be exported through an interface that clearly
%identifies its responsibilities.  The definition of these interfaces is
%fundamental for a successful design, whereas they constitute the main
%interaction point between system and application programmers.

%% - Constructor in interfaces
%Some designers defend that interfaces should not specify constructors,
%since in principle a class can realize several interfaces, possibly
%leading to conflicts. However, the class that represents an abstraction
%in the realm of \aosd\ is a rather special one: it is conceived to
%collect the classes that implement the abstraction in a construct that
%realizes the interface of that abstraction. These classes always realize
%a single interface.  Furthermore, some abstractions become considerably
%easier to understand and to use when associated with distinct
%initialization semantics, which could be expressed by constructors in
%their interfaces.

%The interface of a member of a family of threads outlined in
%figure~\ref{fig:interface} illustrates the case for constructors in
%interfaces.  When creating an object of type \sym{A\_Thread}, the
%programmer can choose from a variety of initial states that differ on
%aspects such as whether the thread is immediately eligible for execution
%or not, where the execution will begin, and what priority it will have.
%In situations like this, application-oriented designers are encouraged
%to specify constructors in abstraction's interfaces.

%\fig{interface}{The interface of a member of a family of thread
%  abstractions.}

%% - Base class 
%Regarding the organization of abstractions in families, one of the first
%aspects to be observed is whether the commonalities that substantiated
%the creation of the family can be modeled as a basic abstraction from
%which all other abstractions derive. If so, the family becomes a
%traditional object-oriented class hierarchy, with the basic abstraction
%as a \emph{base class} and the remaining members as specializations of
%that.  In this case, each family member defines a \emph{subtype} of the
%basic abstract data type, thus enabling the entire family to be handled
%as a single \emph{polymorphic} abstraction.

%Contrarily to what a ``pure'' object-oriented designer might suppose,
%this is not the only (and sometimes not even an adequate) alternative to
%represent a family of abstractions. Consider for instance a family of
%synchronization mechanisms comprising two well-known abstractions:
%\emph{condition variables} and \emph{semaphores}. Does what they have in
%common characterize a basic abstraction?  Alternatively, should one of
%them be taken as the basic abstraction?  In any case, how would the
%drastic differences between them be accommodated in the base class?  As
%the term suggests, \emph{polymorphism} concerns the reconciliation of
%the multiple ``forms'' of an abstraction, providing a single interface
%for entities of different types. However, what happens if these multiple
%forms, though sharing semantic and functional aspects, do not fit under
%a common type?

%% nothing to do with polymorphism
%%\footnote{Note that design patterns such as the \tm{Abstract
%%    Factory}~\cite{Gamma:1995}, which could ultimately be used to deal
%%  with cases like this, are orthogonal to the concept of families at
%%  this level of design. A higher quality design is produced if the
%%  organization of abstractions in families is guided mainly by their
%%  commonalities and differences.  Further refinements can introduce
%%  design patterns, or any other technique considered adequate
%%  by the designer, as the design approaches implementation.}

%% - AOSD alternative to polymorphism: inflated interfaces
%As a multiparadigm design method, \aosd\ does not presuppose
%abstractions in a family to be polymorphic. If the commonality of a
%family does not spontaneously characterizes a basic abstraction, then it
%can be represented by classes collected in a ``common package'' and made
%available to be reused by independently defined family members via
%\emph{aggregation} or \emph{subclassing} instead of \emph{subtyping}.

%%As a multiparadigm design method, \aosd\ is not as strict as
%%object-oriented design in this regard, handling cases like this by means
%%of \emph{inflated interfaces} that play a role similar to base classes
%%to the eyes of users, but set the family free from the polymorphic
%%organization. These interfaces will be described in
%%section~\ref{sec:ii}. If the commonality of a family does not
%%spontaneously characterizes a basic abstraction, then it can be
%%represented by classes collected in a ``common package'' and made
%%available to be reused by the independently defined members of the
%%family via \emph{aggregation} or \emph{subclassing} instead of
%%\emph{subtyping}.

%% - Mutual exclusion
%Some families of abstractions may feature members that are mutually
%exclusive, i.e., that cannot be deployed at the same time.  For example,
%a family of process abstractions could feature a member to support a
%single thread per process and another to support both single and
%multiple threads.  These two abstractions would likely be mutually
%exclusive, since the cost of dynamically switching between them would be
%much higher than the cost of selecting the abstraction that supports
%multithreading and leaving the feature inactive for most of the time.
%This kind of family excludes polymorphism even if the family derives
%from a common basic abstraction, since only one of its multiple
%``forms'' can be used at a time.

%% - Configurable features
%The construct used to encapsulate the common elements of a family is
%also the ideal place to store the classes used to implement configurable
%features, since it is always incorporated by all members.  Configurable
%features dictate particular conditions to abstractions, but unlike
%scenario aspects, are not transparent. When an abstraction is notified
%that a configurable feature has been enabled, it has to modify its
%behavior accordingly. Nevertheless, the implementation of such
%configurable features across the members of a same family can usually be
%accomplished deploying common data structures and algorithms, which can
%be modeled as classes in the family's common package.  These classes can
%be reused, specialized, or overridden by each family member.

%% - Notation 
%A typical family of abstractions can be represented using the notation
%illustrated in figure~\ref{fig:family}. The correspondence of
%abstractions and components in an \aosd\ allows \emph{family diagrams}
%to fuse elements from both logical and component view. A family is
%represented as a tree, with members connected through dependency
%relationships, and themselves depending or specializing each other. The
%family's common package is implicitly represented, unless configurable
%features have been modeled for the family. In this case, they appear
%connected to the root of the tree by means of use relationships.

%\fig{family}{Notation to represent a family of abstractions.}

%% - Inter-family relationships
%While refining the specification of families and their members, it is
%also important to consider inter-family relationships. Families often
%rely on abstractions from other families to deliver the contracted
%services.  For example, a family of process abstractions may rely on a
%family of synchronization abstractions to coordinate concurrent
%execution.  Whenever possible, inter-family relationships should be
%expressed without making the case for a particular member of the
%supplier family, so that configurability is not constrained. If a family
%makes a superfluous choice for a mutually exclusive member of another
%family, it implicitly configures that family, preventing the application
%programmer from doing so, and reducing the number of valid system
%configurations.

%Suppose for instance that family \sym{B} of
%figure~\ref{fig:family_dependencies} is mutually exclusive (i.e. only
%one of \sym{B1}, \sym{B2}, and \sym{B3} can be used at a time).
%Defining relationship \sym{R2} would implicitly exclude members
%\sym{B2} and \sym{B3} from been used when family \sym{A} is
%deployed.  Evidently, this is not an issue if family \sym{A} really
%depends on member \sym{B1}.  Indeed, failing to represent this
%relationship would make room for erroneous configurations in this case.
%However, it is important to carefully consider if a restrictive
%relationship like this really holds for the whole family.  For example,
%if the dependency on member \sym{B1} concerns exclusively to member
%\sym{A3}, while other members of family \sym{A} would behave
%correctly with any member of family \sym{B}, a relationship
%\sym{R1} could express the inter-family dependency and be overridden
%by \sym{R3} for member \sym{A3}.

%%A flexible mechanism to allow inter-family dependencies to be expressed
%%outside abstractions will be described in
%%section~\ref{sec:dependencies}.

%\fig{family_dependencies}{Inter-family dependencies.}

%% - Shared classes across families
%Another situation that could bring families to interact is the
%identification of common software artifacts that are of interest to
%several families.  Containers such as lists and queues, for instance,
%appear in a large number of system-level abstractions. Modeling such
%artifacts in the context of one abstraction and establishing
%inter-family relationships just for the sake of code sharing is
%certainly not an option: the loss of quality due to improper coupling is
%eminent.  Defining additional ``utility abstractions'', where common
%artifacts are collected for posterior reuse, is not an alternative
%either, since such abstractions would break fidelity with the domain. A
%satisfactory answer to the question would be to model these common
%artifacts as utility classes that are stocked up in a library. In this
%way, they can be shared among clients without setting up any
%relationship between them.

%% - OOD
%At this point, \aosd\ converges into object-oriented design to produce
%detailed specifications of each family's common package, its members,
%its configurable features, and class utilities. Among others, the
%methods proposed by Rumbaugh~\cite{Rumbaugh:1991},
%Jacobson~\cite{Jacobson:1993}, and Booch~\cite{Booch:1994} could be used
%for this purpose.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Scenario Aspects\label{sec:sa}}
%%   + Scenarios
%%     - Exec context for abstractions (sync, protect, local, etc) (global)
%%     - Why it gets scenario-dependent?
%%     + Scenario adapters
%%       - Adapt an abstraction to a scenario
%%       - Transparent to abstractions
%%       - Structural X Behavioral
%%     - Incompatible scenario aspects

%% - Exec context for abstractions (sync, protect, location, etc) 
%In the process of \aodd, abstractions are specified avoiding
%dependencies from envisioned execution scenarios, while scenario aspects
%are captured in separated constructs. By doing so, an explosion of
%scenario-dependent abstractions is avoided at the same time the degree
%of reusability of abstractions is increased. However, for this scheme to
%be effective, the constructs used to capture scenario aspects must be
%modeled in such a way that it becomes possible to enforce abstractions
%the conditions dictated by a given scenario without having to explicitly
%modify them.

%% - Scenario adapters
%One can think of a \emph{scenario} as a construct that incorporates
%several scenario aspects in the same way abstractions do with
%configurable features. Once the desired scenario aspects have been
%selected, the scenario can be applied to abstractions with a
%\emph{scenario adapter}. A scenario adapter is a kind of agent that
%engulfs a scenario-independent abstraction in order to mediate its
%interaction with a scenario-dependent client
%(figure~\ref{fig:scenario}). In this way, abstractions acquire the
%properties needed to perform in a given scenario without having to be
%modified. %In principle, scenario adapters are defined in a per-family
%%basis, but it may happen that some exotic family members require them to
%%be specialized.

%\fig{scenario}{The general structure of a scenario adapter.}

%In \aosd, scenarios and the respective aspects are represented in
%\emph{scenario diagrams}. In principle, scenario adapters are defined on
%a per-scenario/per-family basis, so it is unnecessary to represent them
%either in scenario diagrams or in family diagrams. However, if some
%exotic families (or family members) require scenario adapters to be
%specialized, then it is convenient to represent them in the
%corresponding family diagram. A scenario that only regards to a single
%family is represented in the corresponding family diagram too.

%% - Structural
%Scenario aspects can be either structural or behavioral. The first kind
%modifies the structure of abstractions, appending some scenario-specific
%data structure to them. The unique global identifier that is assigned to
%abstractions in order to support remote invocation in a distributed
%scenario is an example of structural aspect. Such a kind of scenario
%aspect can be modeled as shown in
%figure~\ref{fig:structural_scenario_aspect}, with the structural aspect
%being first incorporated by the corresponding scenario via aggregation
%and later by the scenario adapter via inheritance.

%\fig[b]{structural_scenario_aspect}{The representation of a structural
%  scenario aspect.}

%% - Behavioral 
%The second kind of scenario aspect modifies the behavior of
%abstractions, enforcing scenario-specific semantics on them. Attaching a
%lock to abstractions so that concurrent invocations of their operations
%get coordinated is an example of behavioral aspect. Abstractions would
%be locked just before an operation is invoked and released just after it
%is concluded. A generic representation of behavioral aspects is shown in
%figure~\ref{fig:behavioral_scenario_aspect}. Just like structural
%aspects, behavioral aspects are first incorporated by the corresponding
%scenario via aggregation and later by the scenario adapter via
%inheritance. However, unlike the former, behavioral aspects implement
%operations that are automatically invoked by the scenario adapter to
%establish the conditions required by the scenario before the operation
%is invoked on the abstraction. The corresponding operations of all
%behavioral aspects are usually called in-order when entering and leaving
%the scenario, but more sophisticated schemes can be devised.

%\fig{behavioral_scenario_aspect}{The representation of a behavioral
%  scenario aspect.}

%%A counterpart example of behavioral aspect for the distributed scenario
%%would be the interception of operation invocations in order to perform a
%%remote procedure call when the target abstraction does not reside in the
%%same address space as the client.  This behavioral aspect can be modeled
%%as a class that supplies the operations needed to implement remote
%%invocations and to check the locality of abstractions.  These operations
%%would be invoked by the scenario adapter to automatically perform a
%%remote procedure call when necessary.

%% - Incompatible scenario aspects
%A new scenario, and consequently a new scenario adapter, has to be
%defined for a family of abstractions only if incompatibilities among
%scenario aspects arise. Otherwise, a set of scenario aspects can be
%simultaneously activated to shape an execution scenario for the
%abstractions in the system.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Inflated Interfaces\label{sec:ii}}
%%   + Inflated interfaces
%%     + Why
%%       - Family handled as a single entity
%%       - Configuration problem (user X app)
%%     + What
%%       - Single interface for a whole family
%%     + How
%%       - Incremental family: biggest interface
%%       - Merging family: merge individual interfaces  
%%       - Null intersection: merge individual interfaces as long as no
%%         conflict occurs; may require an abstraction that do not exist

%% - Why are inflated interfaces necessary
%In \aosd, families of abstractions are sometimes handled as single
%entities. Configurable features and scenario adapters, for instance, are
%defined in terms of families and not of their members.  Viewing a family
%as a single entity may be convenient to application programmers as well,
%since it would enable them to postpone the decision of which family
%member will be used until enough arguments have been collected.
%Assigning each family a single interface, that represents all its
%members at once, would produce the desired single-view and would enable
%programmers to write their applications with a higher degree of
%abstraction. Adequate realizations of these interfaces could be selected
%just before generating the \aoos.

%% - Example
%Consider, for example, the case in which an application programmer first
%identifies a given member \sym{A} of a family of abstractions as
%being the most adequate for an application, but during implementation
%realizes that writing the application in terms of a member \sym{B}
%would have been more appropriate.  Replacing each appearance of
%\sym{A} for \sym{B} in the source code could be avoided if the
%programmer had written the application in terms of an interface that
%congregates the services of both member \sym{A} and member
%\sym{B}, and if both members had been implemented respecting the
%semantics of this interface. In this case, binding the interface to
%member \sym{B} would be enough to produce the desired effect.

%% - OS and APP use different languages ???

%%This sequence, fist implementing the application and than configuring
%%the system may sound familiar to most configurable operating system
%%users, however, a deeper look on such systems will most likely reveal
%%that they either use monolithic abstractions, i.e., there are no
%%alternative implementations for an abstraction, or force all
%%abstractions of a family to realize the same, usually standardized,
%%interface. Systems that promote the organization of families according
%%to software quality metrics instead of standards must be configured in
%%advance, since family members with incompatible interfaces would inply
%%in unacceptable application modifications\footnote{Wosch: help!}.
%%Applying the single-view principle to such families could solve this
%%problem as well.

%% - Inflated Interfaces
%Therefore, besides exposing the individual interface of each member of a
%family of abstractions, an \aos\ also delivers an \emph{inflated
%  interface} that exports the family as though a ``super'' component,
%that implements all responsibilities assigned to the family, was
%available. Theoretically, such an interface can be obtained by merging
%the interfaces of individual family members. However, if programmers are
%invited to write their applications based on these inflated interfaces,
%a strategy to transparently bind them to one of their realizations (i.e.
%a family member) has to be devised.

%% - Automatic binding
%Ideally, application programmers should be able to write applications
%entirely in terms of inflated interfaces, delegating the burden of
%system configuration to an automatic tool. Such a tool would
%syntactically analyze the source code of the application in order to
%determine the inflated interface subsets that have been effectively
%used. It could then bind each inflated interface to the lightest family
%member that realizes the required subset\footnote{The complex task of
%  ordering family members according to a cost model would have been
%  previously accomplished by the operating system designer.}, thus
%producing an \aoos. In order to achieve this scenario, inflated
%interfaces must be carefully specified, taking in consideration the
%internal organization of families. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Reusable System Architectures\label{sec:aof}}
%%   + Reusable system architectures
%%     + What
%%       - Know-how about building system of a class
%%     + why
%%       - Arrange abstractions in a functioning system
%%       - Only predicted interactions are possible, reducing error proneness
%%     + How
%%       - Identify relationships between families and the environment
%%       - Component Framework
%%         - plug-and-play
%%         - System-wide properties
%%         - efficiency (static metaprogramming)
%%         - Collection of interrelated scenario adapters in a framework
%%         - Adapter = component place holders

%% - What is a reusable system architecture?
%Along with the specification of abstraction families and scenario
%aspects, an \aosd\ delivers specifications of reusable system
%architectures, which define how abstractions can be arranged together in
%a functioning system. Reusable system architectures are usually defined
%considering the past experience with the building systems of a certain
%class.  After having developed some systems, or some versions of a
%system, for a certain problem domain, developers begin to agree on how
%to implement the abstractions that build up the domain, how they
%interact with each other, with the environment, and with applications,
%and how the implied non-functional requirements can be accomplished.
%Such an expertise can be captured in an architectural specification to
%be reused in upcoming systems.

%% - Why to reuse an architecure?
%Capturing reusable system architectures in a component-based system is
%fundamental, since a pile of components, by itself, is nothing but a
%pile of components. A component-based system is only achieved when
%components can be arranged together in an assemblage of predictable
%behavior. In \aosd, reusable architectures begin to be modeled yet
%during domain decomposition with the identification of relationships
%between families of abstractions. These relationships are enriched by
%scenario constraints during the specification of scenario aspects and
%serve as input for this phase, which aims at producing a detailed
%specification of reusable system architectures in the form of component
%frameworks.

%% - Component frameworks
%An \aocf\ captures a reusable architecture by specifying the families of
%abstractions that take part in a certain kind of system, as well as
%rules that guide their interaction. Systems produced by component
%frameworks, when compared to arbitrary arrangements of components, are
%less prone to misbehavior, since only compositions that have been
%predefined by system architects are allowed.  Although component
%frameworks are not the unique alternative to capture reusable
%architectures---among others, \emph{aspect programs}, \emph{subjects},
%and \emph{collaborations} could also be used for this purpose---they fit
%perfectly with application-orientation's notion of isolating scenario
%aspects from abstractions by means of scenario adapters.

%% - AOSD framework
%An \aocf\ could be defined as a collection of interrelated scenario
%adapters as shown in figure~\ref{fig:aof}. Each scenario adapter would
%set up a ``socket'' for components of the corresponding family. Plugging
%components into the framework would be accomplished by binding the
%inflated interface of every used family to the desired family member.
%The way scenario adapters are arranged in the framework would define the
%basic architecture of resultant systems, while architectural elements
%that do not concern components could be hard-coded in the framework.

%\fig{aof}{An \aocf.}

%A component framework defined in terms of scenario adapters would also
%present advantages concerning \emph{system-wide properties}, which could
%be modeled as scenario aspects to be enforced on components by the
%respective scenario adapters~\cite{Szyperski:1998}. Moreover, a
%component framework of this kind does not require complex tools to
%manipulate the source code of components in order to generate a system.
%After all, the representation of a component framework as a socket board
%to which components can be plugged is well understood and accepted by
%users.

%% - example 
%Figure~\ref{fig:comm_fmk} shows a schematic representation of a
%component framework that embodies a plausible system architecture for
%the domain of high-performance communication in clusters of workstations
%used as example in section~\ref{sec:aodd}.  It illustrates the
%relationships between the three families of abstractions modeled:
%\sym{Communication End-Point}, \sym{Communication Strategy}, and
%\sym{Network}. Firstly, it shows a mutual dependency between the
%families of strategies and end-points, i.e., by selecting a certain
%strategy, one automatically selects the corresponding end-point, and
%vice-versa. It also shows that a network is \emph{used} by the members
%of the communication strategy family. The respective sets of components
%are also shown to illustrate the ``select-and-plug'' organization of the
%framework.

%\fig{comm_fmk}{A component framework for the domain of high-performance
%  communication.}

%% + Overview
%An overview of the \aosd\ method is presented in figure~\ref{fig:aosd}.
%In summary, it is a multiparadigm design method that promotes the
%construction of \aooss\ by applying the process of
%\emph{application-oriented decomposition} to engineer a domain as
%collection of \emph{families of reusable, scenario-independent
%  abstractions}.  Scenario dependencies are modeled as \emph{scenario
%  aspects} that can be enforced on abstractions by means of
%\emph{scenario adapters}.  Families are made visible to applications
%through \emph{inflated interfaces}, which export all members as though a
%comprehensive component was available. Reusable system architectures are
%captured in \emph{component frameworks} defined in terms of scenario
%adapters.

%\fig{aosd}{An overview of \aosd.}
%\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Conclusions}

%Historically, applications have been adapted to the operating system,
%adhering to standardized application program interfaces that covey
%uncountable useless services (for each individual application), and yet
%fail to deliver much of what is necessary.  An application-oriented
%operating system ruptures with this notion, implementing services that
%emanate from application requirements and delivering them as a set of
%configurable components that can be assembled to produce
%application-tailored system instances.

%Such \aooss\ can be constructed deploying the \aosd\ method %, which is
%%outlined in figure~\ref{fig:aosd}, 
%to engineer the envisioned domain. In this way, the domain is decomposed
%in abstractions that model application-specific perspectives of each
%entity.  These abstractions are gathered in families according to what
%they have in common, with variability analysis being deployed to
%identify subsequent members of each family. During this process,
%variations that belong to the essence of abstractions are separated from
%those that emanate from execution scenarios, the former shaping family
%members, and the latter yielding scenario aspects.  This separation
%improves on reusability, for scenario-independent abstractions can be
%reused in a larger variety of
%scenarios. % Moreover, the complexity of individual abstractions is
%%decreased, thus enhancing software quality in general.

%%\fig{aosd}{An overview of \aosd.}

%Maintainability in a component-based system is mainly a function of the
%number of components and of the complexity of each component.  The
%separation of abstractions and scenario aspects improves both factors.
%Scenario-independent abstractions are less complex than their
%scenario-dependent counterparts, for they do not need to deal with
%environmental particularities.  At the same time, the number of modeled
%software artifacts is reduced, since most scenario aspects apply to
%several abstractions (some even apply to all abstractions).
%Furthermore, not all of the variability observed in a family of
%abstractions yields family members.  Some designate optional features
%that concern to several members at once.  Instead of specializing each
%abstraction to produce versions that include such features, \aodd\ 
%suggests generic implementations of these configurable features to be
%modeled as constructs that can be reused by existing family members when
%the corresponding feature is required.  An explosion of abstraction
%specializations is so avoided.

%Still during domain decomposition, ad-hoc relationships between families
%of abstractions are exploited to model reusable software architectures.
%Such architectural specifications designate valid combinations of
%abstractions and scenario aspects that are subsequently materialized as
%component frameworks.  In this way, \aosd\ advances in one of the most
%contentious aspects of component-based software engineering: how to tell
%valid composites form invalid ones.

%Abstractions modeled during domain decomposition originate the software
%components of an \aoos\ on 1-to-1 relation. They are delivered to users
%as abstract data types, with interfaces that clearly identify their
%responsibilities. Scenario aspects are maintained separately, being
%combined at user's wish to shape the execution scenario for a certain
%composite. They are applied to abstractions by means of scenario
%adapters, which act as agents to mediate the interaction of
%scenario-dependent clients with scenario-independent abstractions.

%In order to enable applications to deal with families of abstractions as
%they were single entities, an inflated interface is delivered for each
%family in an \aosd.  Such an interface exports a family as though a
%``super'' component was available that implements all responsibilities
%assigned to the family.  The choice of specific family members can thus
%be postponed or even delegate to a configuration tool.  Such a tool
%would analyze the applications to determine which subsets of each
%inflated interface have been used, binding them to the most appropriate
%realization available.

%The configurable system architectures modeled during domain analysis are
%delivered to users as component frameworks defined in terms of scenario
%adapters.  Each scenario adapter constitutes a placeholder for an
%abstraction, pre-establishing relevant relationships.  Abstractions are
%plugged to the framework via the inflated interface binging mechanism,
%which is also used to select scenario aspects.

%An \aoos\ designed according to the directives of \aosd\ can be
%implemented using a variety of techniques. As of today, it is probable
%that the \cpp\ will the choice for most implementations, because it is
%one of the few programming languages that completely expose the
%underlying hardware, an essential condition for an operating system
%implementation.  Furthermore, \cpp\ supports multiple programming
%paradigms, including static metaprogramming, that can be combined to
%achieve efficient implementations.


%% Incremental system design
%%Curiously, the longstanding \emph{Incremental System Design} method (see
%%section~\ref{sec:isd}) deals exactly with this problem. An incrementally
%%designed system extends into the application, theoretically eliminating
%%the gap. However, the software technology available for the time it was
%%proposed did not contributed to its success. Today, with techniques that
%%support the implementation of family members as software components,
%%Incremental System Design seems to have a better chance.

%% - Example of scenario aspect
%%A mailbox, for instance, should be modeled around its basic
%%functionality, i.e., collecting messages sent to the associated
%%recipient, while aspects such as whether mailboxes are be used in a
%%trusted environment, where a recipient is granted not to peep in someone
%%else's mailbox, or in an environment where mailboxes have to be locked
%%with a key; whether mailboxes have an exclusive recipient, or may be
%%shared among several recipients; what to do if two recipients want to
%%open the mailbox at the same time; 

%% - SOP
%%Subject-Oriented Programming~[section~\ref{sec:sop}] contributes with
%%the idea that family members may reflect subjective views of the same
%%abstraction. The outcome of this procedure is a collections of
%%abstraction families, with each family capturing an entity in the
%%problem domain, and with family members capturing application-oriented
%%perspectives of each abstraction. 

\bibliography{guto,se,os}

\end{document}
