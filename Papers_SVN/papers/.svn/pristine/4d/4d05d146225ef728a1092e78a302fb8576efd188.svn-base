\note{Exemplo simples para demostrar a usabilidade da API.}
In order to demonstrate the usability of the defined interface, a
thermometer was implemented using a simple prototype with a 10 kilo
ohm thermistor connected to an analog-to-digital converter channel of
an Atmel ATMega16~\cite{ATMega16:2004} microcontroller. The embedded
application is presented in Figure~\ref{prg:app.cc}. This application
uses four system components: \texttt{System}, \texttt{Alarm},
\texttt{Ther\-mo\-me\-ter} (member of the \texttt{Sentient}
family~\cite{Wanner:2005b}) and \texttt{UART}. The \textsc{Epos}
hierarchical organization binds, for example, the
\texttt{Ther\-mo\-me\-ter} abstraction with the microcontroller's
analog-to-digital converter hardware mediator.

\prg{C++}{app.cc}{A aplicação Thermometer}

\note{Comportamento da aplicação.}
When the application starts, all used components are initialized by
their constructors and a periodical event is registered with the
\texttt{Alarm} component. The power state of the whole system is then
switched to \texttt{STANDBY} through a power command issued to
\texttt{Sys\-tem}. When this happens, the \texttt{System} component
switches all system components, except for the \texttt{Alarm}, to
\emph{sleeping} modes. The \texttt{Alarm} component uses a timer to
generate interrupts at a given frequency. Each time an interrupt
occurs, the CPU wakes-up and the \texttt{Alarm} component handles all
registered events currently due for execution. In this example, every
two seconds the \texttt{Thermometer} and \texttt{UART} components are
automatically switched on when accessed and a temperature reading is
forwarded through the serial port. When all registered events are
handled, the application continues normal execution on a loop which
puts the \texttt{System} back in the \texttt{STANDBY} mode.

\fig{therm_graphics}{Consumo de energia para a aplicação Thermometer
  \emph{sem (a)} e \emph{com (b)} gerenciamento do consumo de
  energia.}{.3}

\note{Análise dos gráficos de consumo de energia.}
The graphics presented in Figure~\ref{fig:therm_graphics} show energy
measurements for this application with and without system power
management capabilities. Both graphics show the results of a mean
between ten measurements. Each measurement was ten seconds long. In
graphic (a) is noticed that system power consumption oscillates
between 2.5 and 4~Watts. In graphic (b), the oscillation stays between
2 and 2.7~Watts. By calculating the integral of these graphics is
possible to obtain energy consumption for these system instances
during the time it was running. The results were 3.96~Joules for (a)
and 2.45~Joules for (b), i.e., the system saved 38.1\% of energy
without compromising its functionality.

\input{tbl/therm_size.tex}

Table~\ref{tbl:therm_size} shows system footprint sizes without power
management, managing only one component (UART) and managing all
components. As can be seen, only 6 bytes of data and 742 B of code
were added to the system. This overhead includes the code and data
necessary to handle the operating mode nets.
