\documentclass{sig-alternate}

\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{color}
\usepackage[english]{babel} 
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[caption=false]{subfig}

\newcommand{\fig}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

\newcommand{\figtwocolumn}[4][ht]{
  \begin{figure*}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure*}
}

\newcommand{\multfigtwoh}[6][htb]{
\begin{figure*}[#1]
  \centering
  \subfloat[]{\label{fig:#3}\scalebox{#2}{\includegraphics{fig/#3}}}
  \subfloat[]{\label{fig:#4}\scalebox{#2}{\includegraphics{fig/#4}}}
  \caption{#6}
  \label{fig:#5}
\end{figure*}
}

\newcommand{\multfigtwov}[6][htb]{
\begin{figure}[#1]
  \centering
  \subfloat[]{\label{fig:#3}\scalebox{#2}{\includegraphics{fig/#3}}}\\
  \subfloat[]{\label{fig:#4}\scalebox{#2}{\includegraphics{fig/#4}}}
  \caption{#6}
  \label{fig:#5}
\end{figure}
}

\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinestyle{prg} {basicstyle=\small\sffamily, lineskip=-0.2ex, showspaces=false}

\newcommand{\progcpp}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=C++,style=prg]{fig/#2.cc}
   \caption{#3\label{progcpp:#2}}
 \end{figure}
}

\hyphenation{or-ga-ni-za-tion op-tical net-works semi-conduc-tor KRA-TOS}

\begin{document}

%
% --- Author Metadata here ---
\permission{Permission for classroom and personal use is granted, providing this notice appears on all copies.}
\conferenceinfo{SBESC 2012}{Natal, Brazil}
\crfee{}
\copyrtholder{by the Authors.}
\CopyrightYear{2012}
\crdata{This work is based on an earlier work: System-Level Verification of Embedded Operating Systems Components, in Proceedings of the ${2}^{nd}$ Brazilian Symposium on Computing System Engineering. \copyright IEEE, 2012. http://dx.doi.org/10.1109/SBESC.2012.39}
% --- End of Author Metadata ---


\title{On the Formal Verification of Component-based Embedded Operating Systems}
\numberofauthors{1}

\author{
\alignauthor
Mateus Krepsky Ludwich and Antônio Augusto Fröhlich\\
       \affaddr{Federal University of Santa Catarina (UFSC)}\\
       \affaddr{Software/Hardware Integration Lab (LISHA)}\\
       \affaddr{880400-900 - Florianópolis - SC - Brazil}\\
       \email{\{mateus,guto\}@lisha.ufsc.br}
}

\date{}

\maketitle

\begin{abstract}
  The increasing complexity of embedded systems is pushing their design
  to System-Level, thus leading to a convergence between software and
  hardware. Consequently, operating systems in this realm are also being
  required to deliver their services both as software and as hardware.
  In such a scenario, it is desirable to verify system properties
  regardless of whether its components are instantiated at software or
  hardware. In this paper, we describe an approach to formally verify
  functional correctness and safety properties of such system-level
  component. The approach is illustrated by a case study of EPOS'
  scheduler, whose implementation can be driven to yield both a software
  instance compiled by the GCC C++ compiler or a hardware instance
  synthesized by the CatapultC ESL tool. We demonstrate that the
  scheduler follows its specification regardless of the domain for which
  it is instantiated. We also demonstrate that the proposed approach
  causes no run-time overhead, since the adopted Software Model Checking
  techniques are deployed at compile-time.
\end{abstract}

\category{D.2.4}{Program Verification}{Correctness proofs}
\category{D.4.1}{Process Management}{Scheduling}
\category{D.4.7}{Organi\-za\-tion and Design}{Real-time systems and embedded systems}

\terms{Algorithms, Design, Verification}

\keywords{Formal Verification, Embedded Operating Systems, Scheduling} 

% ------------------------------------------------------------------------------
\section{Introduction} \label{intro}

In the last few years, advances in Electronic Design Automation (EDA)
techniques and tools are allowing hardware synthesis from high-level
behavioral models.  This process, known as High-level Synthesis (HLS),
allows designers to describe hardware components using programming
languages such as C++ and Java, and System-Level Description Languages
(SLDLs) such as SystemC and SpecC \cite{Gerstlauer:2009}.  In such
scenario, it is highly desirable to verify system properties formally,
regardless of whether their components are going to be implemented in
software or hardware.

Two main classes of properties for formal verification are functional
correctness and safety.  Functional correctness aims to check if a given
implementation follows its functional specification (also referred as
\emph{contract}).  Safety aims to check if there is an execution path
which leads the component to an error state.  An error state can be
caused, for example, by buffer overflows (e.g. while array bounds are
surpassed), and by violating pointer safety (e.g. while dereferencing a
null pointer).

As HLS allows for hardware components to be described using programming
languages, descriptions can now be verified using Software Model
Checking tools.  In Software Model Checking, a program is translated
into a logical formula.  Properties about the target program can be
described in such logics, directly in the programming language (e.g. by
using \emph{assert} expressions), or even automatically generated by
analyzing constructions of the programming language, such as arrays and
pointers.  Then, the logical formula representing the program is
combined with given properties, generating \emph{Verification
  Conditions} (VCCs) that are passed to a satisfiability solver or to a
theorem prover.  Finally, it is determined if all properties specified
for the program are true or not.  In the latter case, a counter-example
is generated, demonstrating the execution path that lead the property to
be false.

Model checking and other verification approaches also have been applied
to SLDLs such as SystemC and SpecC. Usually, SLDL descriptions are
transformed in C++ code that is subsequently submitted to a software
model checking tool.  That is the case of the KRATOS model checker
\cite{Cimatti:2011} and the Scoot tool \cite{Blanc:2008}, both targeting
SystemC descriptions. A similar strategy is used by Clarke to verify
SpecC descriptions \cite{Clarke:2007}. However, recent Electronic
System-Level (ESL) enable hardware components to be directly described
in C++. Certainly some issues are intrinsic to the design of software
and others to hardware, but in respect to formal verification, this new
generation of tools allow us to skip model transformations and language
translations as long as components are properly designed for
verifiability.

In this paper, we propose an approach to formally verify functional
correctness and safety properties of embedded system components
described at system-level.  In our proposal, a contract is written for
each component in order to formally specify its behavior. Contracts are
composed by class invariants and method pre and postconditions as
proposed by Meyer in \emph{Design by Contract} \cite{Meyer:1992}.  Such
contracts are also specified in C++, the same language used for the
implementation of components.  Both specification and implementation are
translated to the internal representation of the C Bounded Model Checker
(CBMC) \cite{Kroehning:CBMC} and then formally checked.  Besides
verifying functional correctness properties specified by a component's
contract, CBMC also checks for safety properties such as the absence of
buffer overflows, and pointer safety. In order to demonstrate our
approach, we have verified the scheduler of the Embedded Parallel
Operating System (EPOS) \cite{Frohlich:2001} showing that it follows
its specification regardless of being instantiated as software or
hardware.

The remaining of this paper is organized as follows: Section~\ref{sota}
makes an overview of formal verification at System Level Design (SLD),
and formal verification of embedded systems; Section~\ref{proposal}
presents our approach for System-Level verification; Section~\ref{eval}
evaluates our approach for the scheduler of an embedded operating
system; Section~\ref{concl} closes the paper with our final
considerations.

% ------------------------------------------------------------------------------
\section{Related Works} \label{sota}

At the System-Level, Fujita and others have described the verification
of synchronization properties for the Point-to-Point Protocol (PPP)
\cite{Fujita:2008}.  In their work, the SpecC description of PPP is
translated into Boolean SpecC and then translated into mathematical
representations of equalities and inequalities that are solved by an
Integer Linear Programming (ILP) solver. Computation Tree Logic (CTL)
formulas are used to represent the expected protocol behavior. The
protocol implementation is checked for state reachability and deadlock
conditions. The adoption of ILP techniques has the advantage of yielding
a model that could be used for system optimization in addition to
verification, but at the same time, imposes practical limits to what can
be verified in this manner.

On the operating system realm, Klein and others have presented the
results of the L4.Verified project, which accomplished the verification
of the seL4 $\mu$-kernel used in embedded systems \cite{Klein:2009}.
The strategy used by the L4.Verified project was to translate the C
implementation of the $\mu$-kernel into the Simpl language
\cite{Schirmer:2006:PHD}, which in turn was implemented using High-Order
Logic (HOL) on the Isabelle theorem prover \cite{Nipkow:2002}.  Then,
invariants about the representation of the operating system components
were proved with Isabelle. Finally, the Simpl description was
demonstrated to refine the kernel's specification described in HOL. The
approach has the advantage of keeping the specification separated from
the implementation and described at a higher level of abstraction, but
requires several refinements that must be carried out manually and that
are out of reach for most operating system developers.

Cohen has verified the functional correctness of Microsoft’s Hyper-V
virtualization platform and also of SYSGO’s embedded real-time operating
system PikeOS \cite{Cohen:2010}.  His strategy was based on a logic to
express Locally Checked Invariants (LCI) that can be used to assign
predicates to components. Predicates define a sort of contract that can
be subsequently verified by the VCC verification environment
\cite{Cohen:2009}. The approach shares some aspects with the one
proposed here, but each function must be verified in isolation, using
only the contracts of called functions and invariants of types used in
its code.

Gotstman and others propose the modular verification of preemptive
kernels running in multiprocessor machines \cite{Gotsman:2011}.
Gotsman's approach propose two proof systems: a high-level one, in which
all processes have their own virtual CPU, and a low-level, in which the
number of processors is fixed.  The high-level proof system is used to
reason about processes while the lower-level proof targets the scheduler
itself. This separation and the isolation of the scheduler from the rest
of the kernel allows for modular verification.  Although the proposal is
to verify mainstreams operating systems such as Linux and FreeBSD, all
theory presented in the paper is developed around an assembly language
for a fictional machine.

Differently from these related works, our proposal aims at verifying
functional correctness and safety of individual operating system
components described at system-level. Additionally, we address
verification without requiring OS developers to specify the behavior of
components using specific languages and tools. In our approach, which is
detailed in the next section, contracts are written in the same language
as components and no refinements have to be proven.

% ------------------------------------------------------------------------------
\section{Verification Approach} \label{proposal} 

The convergence between software and hardware in the design of embedded
systems calls for embedded operating systems whose parts can also be
freely shifted from one domain into the other. Accordingly, the formal
verification of such systems must now be carried out independently of
the instantiation domain. In this scenario, the implementation itself
must be domain-independent. Therefore, we propose a strategy to handle
these cases that consists of three main steps: (i) writing contracts for
the components that will be verified, (ii) instrumenting components with
such contracts, (iii) performing software bounded model checking to
verify if components respect their contracts.

The fact that modern ESL design tools such as CatapultC
\cite{Calypto:Catapult} are able to synthesize hardware directly from
C++ descriptions enables us to propose a single-language strategy.
Components and contracts are both written in C++ on a seamless way
inspired by the Eiffel programming language \cite{Meyer:1992}. We
propose contracts to be written in C++ using assertions (\emph{assert}
expressions).  A contract is composed by the invariants of the class
that defines the component and by a set of pre and postconditions.
Class invariants are defined as a set of assertions that are always true
for all instances of that class.  The preconditions of a method define a
set of assertions that must be satisfied before it is executed.
Conversely, the postconditions of a method define a set of assertions
that must be true in case the method invocation terminates normally
(i.e. without triggering exceptions, which have not yet been addressed
in our approach).  Pre and postcondition assertions can reason about the
method's parameters, return value, and object state.  Figure
\ref{progcpp:contract_example} shows an example of contract for the
method \texttt{insert} of a \texttt{Queue} class.  The
\texttt{invariants} method defines the class' invariants, which, in the
example, state that a queue of this class can never be empty.

\progcpp{contract_example}{Example of contract for the \texttt{insert()}
  method of a \texttt{Queue} class.}

Writing contracts directly on the component implementation has the
advantage of keeping specification and implementation close to each
other, always at hand to be informally verified by programmers during
development. However, writing assertions directly on the component code
can impose additional run-time overhead to its instances. The code added
to components to specify their contracts can be partially eliminated by
the macro mechanism traditionally implemented in the standard C library.
Since contracts are only used during the verification phase, the
\texttt{libc}'s \texttt{assert} macro (declared in \texttt{assert.h})
can be defined to be void for the compilation of the final system.
Nevertheless, contracts that require the declaration of new variables
cannot be handled in this way. For example, the expression
\begin{verbatim}
assert(size() == size_at_pre + 1);
\end{verbatim}
in the postcondition of method \texttt{insert} in Figure
\ref{progcpp:contract_example} depends on the declaration of the
(\emph{size\_at\_pre}) variable. This variable was not present in the
original method and was only included to support the method's contract.
In such cases, Aspect-oriented Programming (AOP) techniques can be of
great help. Both assertions and associated variables can be injected into
the component's code specifically for the verification stage and left
out for the final system instantiation.

\fig{.4}{verified_scenario}{The Verified Scenario to make components
  verifiable using AOP techniques.}

In our approach, we resort to the \emph{Scenario Adapter} pattern
\cite{Frohlich:SCI:2000}, proposed by Fröhlich, to realize a
\emph{Verified Scenario} for specific components. As it can be seen from
Figure \ref{fig:verified_scenario}, the client (\emph{Client}) of a
component accesses its methods though the scenario adapter
(\texttt{Scenario\_Adapter}), which encapsulates the component in a
scenario defined by a collection of aspect programs meant to properly
wrap each component method invocation, thus imputing them the semantics
established by that scenario. The \texttt{Scenario\_Adapter} applies the
pattern shown at the implementation of the method \texttt{operation()}
for each method of the component. It calls the preconditions of such
method before calling the actual method and then calls postconditions
after the method is called.  The actual method is called through
delegation (\texttt{IMP\-::\-Com\-ponent::operation()}).  It also calls
the \texttt{invariants()} just before and just after calling the actual
method to ensure that the method does not violate the class invariants.
The \texttt{Verified\_Scenario}, which can be customized for each
individual component, combines all invariants, pre and postconditions
through inheritance to define a deployment scenario in which that
component can be verified. Assertions touching cross-cutting properties
or referring recurring properties can be freely reused in several
\texttt{Verified\_Scenario} wrappers\footnote{Actually, a single
  implementation of \texttt{Verified\_Scenario} can be defined for all
  components. It is subsequently specialized by using a metaprogrammed
  list of conditions and invariants that must be applied to each method
  of each component.}.

The main advantage of using the scenario adapter pattern to instrument a
component with its contract is the possibility of easily enabling and
disabling the instrumentation as needed.  In order to enable the
instrumentation, one can use a type alias as the following:
\begin{verbatim}
namespace IMP {
    #include <component>
}
typedef Scenario_Adapter<IMP::Component> Component;
\end{verbatim}
As the scenario adapter implements the public interface of the
\emph{Component} interface, the client class accesses the verified
version of the component just as it accesses the original (and final)
component. Once the component has been instrumented with its contract,
that is, once it is put in its \texttt{Verified\_Scenario}, verification
can be carried out by traditional software model checkers.

Besides instrumenting the component implementation with its contract,
AOP techniques can also be deployed to isolate the component target of
verification from other components.  Isolation is essential to enable a
modular verification of components, in which not-yet-verified components
can be disconnected from the component currently being verified.
Furthermore, verifying a whole embedded operating system at once is a
defying process. Even the L4.Verified project, which verified a whole
$\mu$-kernel, used isolation to some extent as they pushed I/O and
interrupt handling to well-defined and well-behaved places inside the
kernel \cite{Klein:2009}.  To make the case for modular verification,
consider resource scheduler depicted in Figure
\ref{fig:component_isolation_for_verification-all}. The
\texttt{Scheduler} class is a parametric class designed and implemented
to schedule all sort of resources. However, its traditional deployment
as a \texttt{Thread} scheduler brings about several complex issues,
including context exchange, interrupt handling and many other
asynchronous events that so often challenge formal method researchers.

In order to isolate the \texttt{Scheduler} from the \texttt{Thread}
implementation (and from any other complex resource being scheduled),
the \texttt{Verified\_Scenario} forces it to be instantiated with a
\texttt{Dummy\_Thread} class. The \texttt{Dummy\_Thread} class
implements the same interface of class \texttt{Thread}, represented in
Figure \ref{fig:component_isolation_for_verification-all} by the
association class \texttt{Scheduling\_Cri\-te\-ria}.  In this design,
all schedulable resources must define the \texttt{int()} operator, thus
enabling them to be properly ordered by the scheduler in accordance with
the scheduling police in force. Scheduling policies are specified by
controlling the mapping of objects representing resources into the
totally ordered set of integer numbers $\mathbb{Z}$. Since any
interaction between the scheduler and the objects being scheduled is
performed through this narrow interface (i.e. \texttt{operator int()}),
replacing \texttt{Thread} by \texttt{Dummy\_Thread} does not impair the
verification of \texttt{Scheduler} as long as the total ordering
property holds, something ensured by the compiler from the definition of
type \texttt{integer}.

\multfigtwov{.4}{component_isolation_for_verification-a}{component_isolation_for_verification-b}
{component_isolation_for_verification-all} {Component isolation for
  verification. (a) Before isolation (b) After isolation.}

It is important to notice that the isolation of components described
here to illustrate the proposed approach for verification can only be
done efficiently for components designed to be reused in a variety of
scenarios. The scheduler discussed here was designed following the ADESD
methodology~\cite{Muck:OSR:2012} with that purpose in mind. It is
unlikely that the thread scheduler of a monolithic (i.e.  a
non-component-based) $\mu$-kernel could be isolated in this manner.
Monolithic designs are more likely to be verified in an all-or-nothing
approach or perhaps to be refactored as a set of semi-independent
modules.  In any case, isolation for verification can never be taken
independently from component design since the effect of isolation over
each individual property being verified must be taken into account.

We have so far demonstrated our approach with the C Bound\-ed Model
Checker (CBMC) \cite{Kroehning:CBMC}.  The component implementation
instrumented with its contract is translated by CBMC into a logical
formula through a process called \emph{symbolic
  simulation}\cite{Clarke:2004}.  While performing this translation,
CBMC also performs static analysis of the source code generating
properties to be checked.  Among these properties, one can find array
bound and pointer safety plus user defined assertions, which in our case
correspond to the contracts of components.  Subsequently, the logical
formula representing the component is combined with the properties
generated by CBMC to yield verification conditions.  Finally, CBMC
invokes a SAT solver to determine if all the properties defined for the
component being verified hold.  In case a property does not hold, a
counter-example is generated showing the execution path where the
property became false.  If all properties are true, the verification
ends successfully proving that the component fulfills both its contract
and the automatically generated safety properties.

The next section describes the verification of the scheduler introduced
in this section in details aiming at illustrating and corroborating the
approach introduced here.

% ------------------------------------------------------------------------------
\section{Case study} \label{eval}

We have chosen the scheduler of the Embedded Parallel Operating
System~(EPOS)~\cite{Frohlich:2001} as a case study to evaluate the
verification strategy proposed here because it has been extensively
investigated as a system-level design artifact in the realm of embedded
systems~\cite{Marcondes:EPS:2009}. It was first implemented as a
software/hardware hybrid component following a design that allowed it to
be described either in C++ or in VHDL. Subsequently, its C++ description
has been demonstrated to be directly synthesizable using ESL
tools~\cite{Pizani:ICECS:2011}. Moreover, the scheduler is a key
component of an operating system, handling queues and dealing with
polices under severe performance constraints.

An overview of EPOS scheduler is shown in Figure
\ref{fig:epos_scheduler}.  The scheduler itself is designed to be
independent from the resources (i.e. objects) it schedules---threads in
this case. As it was discussed in the previous section, queue management
and scheduling policies are also kept independent of each other as much
as possible. They are connected only by the \texttt{int()} operator
defined in \texttt{Scheduling\_Criteria}, which maps schedulable objects
into the totally ordered set of integer numbers $\mathbb{Z}$, thus
defining a scheduling policy algorithm. Total ordering dictates that
higher ranked objects have precedence over lower ranked ones in
accordance with the ordering in $\mathbb{Z}$. It does not require
schedulable objects to be uniquely ranked. Ties are either handled on a
round-robin manner (i.e. queue reinsertion at tail) or
first-in-first-out (i.e. queue reinsertion at head) according with a
user visible configurable feature of the scheduler.

\fig{.4}{epos_scheduler}{Overview of EPOS scheduler design.}

To verify the functional correctness and safety of EPOS scheduler, we
must first specify its contract. A single class invariant was defined.
It dictates that one cannot remove more schedulable objects from the
scheduler than have been inserted into it.
\begin{verbatim}
assert(size() >= 0);
\end{verbatim}
Afterwards, we defined C++ assertions representing pre and
postconditions for each public method of class \texttt{Scheduler}. They
are shown at the Table \ref{tab:scheduler1s_contract}. Variables
prefixed \texttt{at\_pre} hold the value of the corresponding property
obtained at the precondition, that is, before the method execution.  The
private method \texttt{contains()} checks whether the object given as
argument is contained in the scheduler.  The safety properties of the
scheduler contract related to array bounds and pointer safety are
automatically generated by CBMC and are not shown in the table. The
specified contract was incorporated into EPOS scheduler implementation
using the \emph{verified scenario} described in Section~\ref{proposal}.
No modifications of any kind were made in the scheduler itself, thus
ensuring that the verified version is equivalent to the final version
(of which assertions are striped).

\begin{table*}[htb]
\begin{center}
\caption{Pre and postconditions to be verified for EPOS scheduler's methods.}
\textsf{
\begin{tabular}{|p{.3\textwidth}|p{.3\textwidth}|p{.3\textwidth}|}
\hline
\textbf{Method}				& \textbf{Preconditions} 			& \textbf{Postconditions}				\\
\hline
unsigned int size() const		& \textit{none}				& \textit{none}					\\
\hline
T * volatile chosen() const		& \textit{none}				& if(!empty())					\\
					&					& ~~~~\textbf{assert}(contains(result);		\\
					&					& else						\\
					&					& ~~~~\textbf{assert}(result == null);		\\
\hline
void insert(T * obj)			& \textbf{assert}(obj != null);		& \textbf{assert}(size() == size\_at\_pre + 1);	\\ 
					& \textbf{assert}(!contains(obj));	& \textbf{assert}(contains(obj));			\\
\hline
T * remove(T * obj)			& \textbf{assert}(obj != null);		& \textbf{assert}(!contains(obj));		\\
					&					& if(at\_pre.contains(obj))			\\
					&					& ~~~~\textbf{assert}(size() == size\_at\_pre - 1)\\
					&					& else						\\
					&					& ~~~~\textbf{assert}(result == null); \\
\hline
void suspend(T * obj)			& \textbf{assert}(obj != null);		& \textbf{assert}(!contains(obj));		\\
					&					& if(at\_pre.contains(obj)) \\
					&					& ~~~~\textbf{assert}(size() == size\_at\_pre - 1)\\
\hline
void resume(T * obj)			& \textit{same as insert}			& \textit{same as insert}				\\
\hline
T * choose()				& \textit{none}				& \textbf{assert}(size() == size\_at\_pre)	\\
					&					& if(empty()) \\
					&					& ~~~~\textbf{assert}(result == null)		\\
					&					& else						\\
					&					& ~~~~\textbf{assert}(contains(result))		\\
\hline
T * choose\_another()			& \textit{same as choose}			& \textit{same as choose} \\
\hline
T * choose(T* obj)			& \textbf{assert}(obj != null);		& \textbf{assert}(size() == size\_at\_pre);	\\
					&					& if(at\_pre.contains(obj)) \{			\\
					&					& ~~~~\textbf{assert}(contains(result));		\\
					&					& ~~~~\textbf{assert}(result==obj);		\\
					&					& \} else					\\
					&					& ~~~~\textbf{assert}(result == null);		\\
\hline
\end{tabular}
}\label{tab:scheduler1s_contract}
\end{center}
\end{table*}

After being instrumented with its contract, EPOS scheduler was submitted
to CBMC for formal verification.  CBMC generates VCCs pertaining the
functional correctness properties specified by the contract and also
VCCs related to array bound and pointer safety.  In our case, 2344 VCCs
were generated.  After generating VCCs, CBMC performs a simplification
phase based on constant propagation and expression rewriting.  After
that phase, 2121 VCCs remained.  The whole verification process took
around 10 minutes running on an Intel Core 2 at 2.83GHz.  At the end of
the process, CBMC indicated that all VCCs held, confirming that the
scheduler respected its contract and also the no safety properties are
violated. The verified code was subsequently compiled using GCC yielding
a software instance and using the CatapultC HLS tool
\cite{Calypto:Catapult} yielding a hardware instance of the scheduler.

% ------------------------------------------------------------------------------

\section{Conclusion} \label{concl}

In this paper, we have introduced an approach to formally verify
functional correctness and safety properties of embedded operating
system components described at System-Level.  The functional correctness
properties of a component are expressed by a contract containing
assertions that represent class invariants, pre, and postconditions for
each method declared in the component's interface.  The strategy of
enriching components with contracts was inspired by the Eiffel
programming language designed by Meyer.  The safety properties are meant
to be automatically generated by a model checker. Components target of
verification are instrumented with their contracts using the
\emph{Verified Scenario} pattern, which allows for assertion reuse and
component isolation for modular verification. Components instrumented
with contracts as described here can be submitted to the CBMC model
checker for formal verification. Subsequently, the \emph{Verified
  Scenario} can be disabled to eliminate any overhead caused by the
instrumentation, thus yielding a production version of the component
with absolutely the same properties.

We have chosen the C++ programing language for implementing components
and contracts because it is a strong contender in the System-Level
realm. Components described in C++ following specific design
methodologies can now be automatically synthesized both as software,
hardware or arbitrary combinations of both. Nevertheless, we believe
that the principles behind our proposal can easily be adapted to other
languages and model checkers.  The verified scenario construct can be
directly applied to SystemC, since it is implemented as a C++ library.
For SpecC, the verified scenario can be applied by using aggregation
instead of inheritance in order to collect the verification aspect
programs used by the component's verified scenario, and subsequently to
combine it with the \emph{Scenario Adapter}. Then, any model checker
supporting such languages and supporting user-defined assertions can be
used to proceed a formal verification.

The isolation of components for modular verification, however, is
something that is made possible by design and not simply by deploying
tools or language patterns. The scheduler verified in this article was
designed following the \emph{Applica\-tion-Driven Embedded Systems
  Design}~(ADESD) methodology~\cite{Muck:OSR:2012} to be independent
from the envisioned deployment scenarios. Scenario independence is
attained by minimizing the connections between components and by the
encapsulation of scenario dependencies in aspect programs. Such design
principles produced a scheduler with a lean interface and with whose
external dependencies were restricted to a single method
(\texttt{operator int()}. It is unlikely that the thread scheduler of a
monolithic (i.e.  a non-component-based) $\mu$-kernel could be isolated
in this manner.  Monolithic designs are more likely to be verified in an
all-or-nothing approach and probably would not benefit much from the
approach proposed here.

% ------------------------------------------------------------------------------

\bibliographystyle{abbrv}

\bibliography{lisha,hw,fm,os,pl}

\end{document}
