\section{The Automatic Exchange of Configuration Parameters}
\label{sec:automatic}
The automatic exchange of configuration parameters is part of an effort to a punctual implementation of each party involved in an atomic tool for complete automation of testing. By using a real-world application its possible to emphasize that even though a small contribution, if compared with the ultimate goal, this solution its already a useful tool to help the debugging process. 

%explicar epos
%mostra que tivemos um rpobelma com a troca de configuraçoes - pegar um exemplo
%mostrar que se a gente tivesse uma troca automatizada este erro seria encontrado mais rápido
The real-world application is based on the development of software in embedded systems using EPOS (\textit{Embedded Parallel Operating System})~\cite{Froehlich:2001}, a component-based framework that provides all traditional abstractions of operating systems and services like memory management, communication and time management.

\subsection{Exchange of Configuration Parameters in EPOS}
EPOS uses generic programming techniques so each abstraction can be configured as desired. Traits are parameterized classes that describe the properties of a given object/algorithm. Figure~\ref{fig:traits} shows a piece of traits classes used by EPOS, where a set of static members describe some definitions used by abstractions. 

\fig{traits}{Set of definitions from a traits class in EPOS}{scale=.5}

By definition, EPOS is instantiated only with the support needed for their dedicated application, it is important to remember that an individual member of a trait is a characteristic of the system and all features of a component must be set appropriately for a better performance of the system. In this context, the automated exchange of these parameters can be used both to discovery a failure in the program by an wrong characterization of components, or to improve the performance for the application by selecting a better configuration.

\fig{script_gray}{Overview of automatic exchange of configuration parameters}{scale=.26}

Figure~\ref{fig:script_gray} shows the overview of how the automatic exchange of configurations parameters is performed. Basically a member of traits is selected, its definition is changed according to the specification and then application is recompiled. Traces generated by each version of application are compared and reported to developer. Before a new cycle is complete, the integrated test environment is used to verify the application execution. The performance is analyzed and compared with other versions of the application, which also generates an execution report.

In the current version of the script, a configuration is selected and its parameter is modified randomly, but can also be supplemented with an artificial intelligence tool or some Application-Oriented System Design tool to provide all information for the script.

\subsection{Real-World Application}
The automation script exchange parameters was used to test the Distributed Motion Estimation Component (DMEC). This component performs a motion estimation that exploits the similarity between adjacent images in a video sequence, which allows images to be coded differentially, increasing the compression ratio of the generated bitstream \cite{Wiegand}. Motion Estimation is an significant stage for H.264 encoding, since it consumes around 90\% of the total time of the encoding process \cite{Li}.

DMEC's test check the performance of motion estimation using a data partitioning strategy. This estimate is made by \texttt{Workers} threads and the result is processed by the \texttt{Coordinator} thread  \cite{dmec}.

\fig{dmec}{Interaction between \texttt{Coordinator} and \texttt{Workers} threads \cite{dmec}}{scale=.3}

Figure~\ref{fig:dmec} presents the interaction between the threads. The \texttt{Coordinator} is responsible for defining the partitioning of picture, provide the image to be processed and return results generated to encoder, while \texttt{Workers} must calculate motion cost and motion vectors.

The Distributed Motion Estimation Component was tested using the integrated environment demonstrated in the section \ref{sec:simulationEnv}. Despite the first part of the script generates multiple configurations, only compile the code does not guarantee that the application is bug free. Figures \ref{fig:qemu_dmec_6_workers} and \ref{fig:qemu_dmec_60_workers} show the DMEC execution using values 6 and 60 for \texttt{NUM\_WORKERS} configuration. 

\fig{qemu_dmec_6_workers}{DMEC emulated execution - \texttt{NUM\_WORKERS} = 6}{scale=.42}
\fig{qemu_dmec_60_workers}{DMEC emulated execution - \texttt{NUM\_WORKERS} = 60}{scale=.43}

The biggest difference between the two figures is that after retrieving the information from the application, QEMU has a response only for the six \texttt{worker}s configuration. 

The automation script uses GDB for debugging all configurations that could be compiled. This process was crucial to determine the error in DMEC case. In this sense, some breakpoints were added to all functions, specially main, according to Figure \ref{fig:gdb_dmec_60_workers}. Its possible to check that "continuing" is the last line that appears in the execution, that fails because a high value is defined for the number of threads. 

\fig{gdb_dmec_60_workers}{DMEC debug with GDB execution - \texttt{NUM\_WORKERS} = 60}{scale=.43}

Through the second part of the script, the debug, was possible to verify that the program even reach the main function, which means that now the script must change configurations before the main call.
