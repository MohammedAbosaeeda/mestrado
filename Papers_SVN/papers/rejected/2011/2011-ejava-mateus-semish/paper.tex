\documentclass[12pt]{article} % SEMISH 2011
\usepackage{sbc-template} % SEMISH 2011

% \usepackage[latin1]{inputenc}	% for Latin languages
% \usepackage[T1]{fontenc}	% for ISO and UTF characters
\usepackage[english]{babel}	% for multilingual support

\usepackage[utf8]{inputenc} % for use utf8
%\usepackage{graphicx}
\usepackage{graphicx,url} % SEMISH 2011

% -----------------------------------------------------------------------------

% Command to use code as figure -----------------------------------------------
\usepackage{listings}
\lstset{keywordstyle=\bfseries, flexiblecolumns=true}
\lstloadlanguages{[ANSI]C++,HTML}
\lstdefinestyle{prg} {basicstyle=\small\sffamily, lineskip=-0.2ex, showspaces=false}

\newcommand{\prgcpp}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=C++,style=prg]{fig/#2.cc}
   \caption{#3\label{prg:#2}}
 \end{figure}
}

\newcommand{\prgjava}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=Java,style=prg]{fig/#2.java}
   \caption{#3\label{prgjava:#2}}
 \end{figure}
}

\newcommand{\prgkcl}[3][tbp]{
 \begin{figure}[#1]
     \lstinputlisting[language=C++,style=prg]{fig/#2.kcl}
   \caption{#3\label{prgkcl:#2}}
 \end{figure}
}

%------------------------------------------------------------------------------

% Commands to insert figures --------------------------------------------------
\newcommand{\figu}[4][ht]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

\newcommand{\fig}[4][htb]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}
% fig usage:
% \fig{<scale>}{<file>}{<caption>}
% e.g.: \fig{.4}{uml/uml_comportamental_dia}{Diagramas comportamentais da UML}
% The figure label will be "fig:" plus <file>.
% The figure file must lie in the "fig" directory.

\newcommand{\figtwocolumn}[4][ht]{
  \begin{figure*}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure*}
}

\newcommand{\figb}[4][hb]{
  \begin{figure}[#1] {\centering\scalebox{#2}{\includegraphics{fig/#3}}\par}
    \caption{#4\label{fig:#3}}
  \end{figure}
}

%------------------------------------------------------------------------------
\sloppy

\title{Abstracting Hardware Devices to Embedded Java Applications}
%\title{Providing embedded Java with hardware devices}


\author{Mateus Krepsky Ludwich\inst{1}, Antônio Augusto Fröhlich\inst{1}}

\address{Laboratory for Software and Hardware Integration -- LISHA\\ 
Federal University of Santa Catarina -- UFSC\\ 
P.O.Box 476, 880400900 - Florianópolis - SC - Brazil\\
\email{\{mateus,guto\}@lisha.ufsc.br}
}


\begin{document}



\maketitle

\begin{abstract}
% Very high-level languages facilitate the development of embedded systems since they provide features such as automatic memory management, memory protection, and reflection. At the same time implementation of these languages targeting embedded systems must attend requirements of these systems such as frequent access to hardware devices and restrictions of memory consumption, time, and energy. 
% 
%In this paper we show a way to interface hardware components with embedded Java applications. This interfacing is achieved using the foreign function interface of KESO Java Virtual Machine that does the binding between Java methods and C functions at compile-time. Using EPOS to support KESO execution, we provide a portable and economical way to run Java applications. We have obtained a total footprint of less then 33KB, including the application and runtime support. Besides that, we have demonstrated that KESO FFI is an adequate mechanism for implementing interaction with hardware devices, achieving a low time overhead when compared to other solutions.
% 
In this paper we introduce a way to interface hardware components with embedded Java applications. This interfacing is achieved using the foreign function interface of the KESO Java Virtual Machine that does the binding between Java methods and C functions at compile-time. Using EPOS to support KESO execution, we provide a portable and economical way to run embedded Java applications. We have obtained a total footprint of less then 33KB, including the application and the runtime support system. Besides that, we have demonstrated that KESO FFI is an adequate mechanism for abstracting the interaction with hardware devices, achieving a low time overhead when compared to other solutions.

\end{abstract}

% \category{D.3.3}{Programming Languages}{Language Constructs and Features}[Classes and objects]
% \category{D.3.4}{Programming Languages}{Processors}[Run-time environments]
% \category{D.4.4}{Operating Systems}{Communications Management}[Input/output]
% \category{D.4.7}{Operating Systems}{Organization and Design}[Real-time systems and embedded systems]
%
% \terms
% Design, Languages, Reliability
% 
% \keywords
% Java, Embedded Systems, Foreign Function Interface

%------------------------------------------------------------------------------
\section{Introduction}
Java implementations that have embedded systems as targets must provide developers with a way to control hardware devices. This is highly desirable since embedded system applications run close to the hardware in the sense that they use hardware devices such as sensors and actuators to interact with the environment, transmitters and receivers for communication, and timers for real time operations. At the same time, embedded Java applications must have a footprint according to the memory constraints imposed by many embedded systems.

Foreign Function Interface (FFI) like the \emph{Java Native Interface} is the mechanism used by Java platforms to access hardware devices and memory. In fact, several Java packages such as java.io, java.net and java.awt are implemented using FFI facilities \cite{Liang:1999}. However, as we will explain in section \ref{sec:related_work}, the main FFIs provided by Java have limitations to deal with embedded systems, because they are too onerous or because of design limitations.

This work demonstrates how we interface hardware components to Java applications. The Embedded Parallel Operating System (EPOS) abstracts hardware devices as components which a well-defined interface. Using the Foreign Function Interface of KESO Java Virtual Machine (JVM) we create the binding between these components and their Java counterparts abstractions. 

Our work focuses on application-driven, statically-configured, and deeply embedded systems. Which means, embedded systems designed to execute a single application, where all the resources the application will need are known at design time. With this in mind, we can optimize the system generation, for example generating only the hardware components needed by the application. In this scenario features such as reflection and dynamic class loading can be also removed from the JVM.

EPOS \emph{hardware mediators} sustain an interface contract between system abstractions (e.g. threads) and the machine allowing for these abstractions machine-independence. \cite{Polpeta:2004}. Since there is a mediator for each hardware device being abstracted, providing Java with these mediators allows a fine-grained control of hardware devices.

KESO JVM focuses on embedded systems and uses an ahead-of-time compilation strategy to translate programs from Java bytecode to C. The KESO FFI also uses a static approach generating the specified C code to native methods.

The next sections of this paper are organized in this way: section \ref{sec:related_work} presents an overview of the main requirements that Java must fulfill in the embedded systems scenario, showing approaches to deal with these requirements. We exemplify each approach using Java solutions from related work and using the KESO JVM. Section \ref{sec:keso} presents KESO Java Virtual Machine and its main concepts, including KESO FFI. We present our approach to interface hardware components with Java applications in section \ref{sec:proposal}, and we evaluate our approach in section \ref{sec:case_study}. Our final considerations are presented in section \ref{sec:discussion}.

% -----------------------------------------------------------------------------
\section{Java requirements for embedded systems}
\label{sec:related_work}
	The requirements that Java must fulfill in the embedded systems scenario
can be grouped in three categories: direct hardware access, elimination of 
java bytecode interpreter overhead, and runtime support and class libraries 
handling. This section explains these requirements categories as the
approaches to deal with them. 
\subsection{Direct hardware access}
	The Java programming language does not provides the concept of 
\emph{pointer} like C and C++ does. The address of \emph{reference variables},
used to access Java objects, is just known by the Java Virtual Machine that 
handles all memory accesses. As major hardware devices are mapped in memory 
addresses, direct access to them is a problem to Java language. Foreign 
Function Interface (FFI) is the approach used by Java to overcome this
limitation.

	Foreign Function Interface (FFI) is a mechanism that allows programs 
written in a certain programming language to use constructions of programs 
written in another.
FFIs are used by Java platforms to provide direct access to memory and I/O 
devices. FFIs can also be employed to reuse code written in other programming
languages such as C and C++ and to embed JVMs into native applications allowing
them to access Java functionality (\cite{Liang:1999}, \cite{1288968}).

\emph{Java Native Interface} (JNI) is the main Java FFI, which is used in \emph{Java Standard Edition} platform (JSE) \cite{Liang:1999}. In JNI, the binding of native code is performed during runtime. Which means, the JVM searches and load into itself the implementation of methods marked as \emph{native}. Usually the implementation of native methods is stored in a dynamic library. This search and loading mechanism increase the need for runtime memory and increase the JVM size. Because of that, they are avoided in embedded systems.

The \emph{Java Micro Edition} (JME) platform uses a lightweight FFI, called \emph{K Native Interface} KNI \cite{_k_2002}. KNI does not dynamically load native methods into JVM, avoiding the memory overhead of JNI. In KNI the binding between Java and native code is performed statically, during compile time. However the design of KNI imposes some limitations. KNI forbids creating new Java objects (other than strings) from the native code. It is also forbidden calling Java methods from the native code. Besides that, in KNI the only native methods that can be invoked are the ones pre-built into the JVM. There is no Java-level API to invoke others native methods. By consequence, it is difficult to create new hardware drivers through KNI.

KESO FFI, presented in section \ref{sec:keso}, focuses on embedded systems. Like KNI, KESO FFI does not perform dynamically loading of native methods. But unlike KNI, KESO FFI provides for the programmer a Java-level API to create new native code bindings. Also there is no problem of native code calling Java code since KESO and KESO FFI generate C code.

\subsection{Bytecode interpreter overhead}
	An overhead that embedded systems would like to avoid is the one of
the Java bytecode interpreter. The Java bytecode interpreter causes a memory
overhead because it is always together with the applications. It also causes
an execution time overhead since bytecode need to be interpreted by software
and them executed. Approaches to deal with this problem are \emph{Just-in-time}
compilation, \emph{Java processors}, and \emph{Ahead-of-time} compilation.

The translation of Java bytecode into native code during execution time, known as 
\emph{Just-in-time} compilation, is a widespread technique used by Java 
Standard Edition JVM.
Gal et al. demonstrate the possibility of using JIT compilation for 
resource-constrained devices also \cite{1134780}.
However \emph{Just-in-time} is just a partial solution to bytecode interpreter
overhead problem. It solves part of the execution time overhead, since methods
are interpreted once and then translated into native code. But the memory 
overhead remains.

Another method to eliminate the runtime overhead of Java bytecode 
interpreters is building the interpreter directly onto the hardware. In this 
case Java bytecode is the ``native code'' of such machines. This approach is
implemented by the so-called \emph{Java Processors}, of which Picojava I and 
II, Jazelle and JOP are examples \cite{picojava1:621089}, 
\cite{picojava2:1288972}, \cite{jazelle}, \cite{jop:1365141}.
Java processors are not a practical solution since major embedded systems are
implemented using more generic propose processors.

A more widespread used solution to eliminate the runtime overhead of Java 
bytecode interpreters is to translate source code or Java bytecode into a
lower level language before program execution. This approach is called
\emph{Ahead-of-time compilation} (\cite{gcj-site}, \cite{sjc}, \cite{1268029}). 
The \emph{KESO compiler}, presented in section \ref{sec:keso}, is also
an ahead-of-time compiler that translates a program written in Java bytecode to
C.

\subsection{Runtime support and class libraries}
	Even interpreting bytecode or compiling it into native code, 
the necessity of some runtime support still remains, for example the garbage 
collector.
This runtime can lie in a preexistent library or can be generated according to
the needs of the application. The same is valid for the classes that a Java
application will need.

In \cite{1620409} a framework is presented for the development and deployment
of Java applications for embedded system devices which uses a runtime 
environment generated from specifications of the hardware and software platform
which will be used by the application.
 
Secchi \cite{Secchi:2004} proposes a tool for bytecode analysis and generation 
of application-specific class libraries. Pereira \cite{Pereira:2007} proposes 
the use of these kinds of tools to build an application-oriented JVM.

	KESO builder, presented in section \ref{sec:keso}, analyzes the application bytecode, creating a call graph, which is used to determine with parts of JVM is need by the application. Then, only the necessary code for providing runtime support to the application is generated. The same bytecode analysis is used to eliminate classes, methods, and fields not accessed by the application.

% -----------------------------------------------------------------------------
\section{KESO java virtual machine}
\label{sec:keso}
KESO is a multi-Java Virtual Machine (JVM) that focuses on embedded devices and 
networks of micro controllers \cite{Wawersich:2007}. KESO relies on the 
OSEK/VDX operating system \cite{osek-vdx_portal}. OSEK/VDX organization 
specifies standards for automotive systems, including the operating system 
standard used by KESO. Because KESO is based on OSEK, it exports the concepts 
of this operating system to Java applications, including statically allocated 
tasks, scheduling policies, interrupt and event mechanism, and communication
\cite{osek_spec223}. Figure \ref{fig:keso_architecture}, taken from 
\cite{Stilkerich:2006}, shows KESO architecture and its main concepts.

\fig{.5}{keso_architecture}{KESO architecture \cite{Stilkerich:2006}}

% Tasks
Tasks are the schedulable unit on OSEK systems. They have fixed priority and 
are allocated statically during the system generation. KESO uses the concept of
OSEK Tasks as a substitute for Java Threads. It is well suited since KESO
focuses on static embedded systems, which allocate resources that will be used
by the system application during design time.

% Domains
Although not explored in this work, KESO can be used as a distributed system
composed by \emph{domains}. A domain appears to the application developer as
a self-contained JVM which has its own heap and static class fields. KESO is
called \emph{multi-JVM} just because of that. A task in KESO just belongs to
one domain and, like all other types of objects, cannot cross domain 
boundaries.
The concept of domain was first introduced by JX \cite{713870} and is a way in
which to perform memory protection in software that can be used when the target
platform is absent of the memory protection unit (MPU) and memory management 
unit (MMU).

% Portals
Inter-domain communication is performed using \emph{portals}. A domain can
provide a \emph{portal service} that consists of a Java interface that offers
\emph{services} to other domains. A task from another domain can import the 
offered service using a global name service.

% Code Generation
KESO JVM overcomes the byte code interpretation overhead compiling byte code into C code in an ahead-of-time fashion 
(i.e. before the program execution).Figure \ref{fig:keso_sys_gen}, taken from \cite{Wawersich:2007}, shows this process. Java application source files and KESO class library are compiled to byte code using a standard Java compiler. Then, the \emph{KESO Builder} translates the class files into C source files and also generates the C source files corresponding to JVM features that will be used by the application (e.g. garbage collector). During the process, KESO Builder analyzes the bytecode and eliminates classes, methods, and fields not accessed by the application and eliminates, when possible, virtual method calls.

\fig{.5}{keso_sys_gen}{System Generation Process \cite{Wawersich:2007}}

% KESO FFI
KESO provides a Foreign Function Interface (FFI) for interfacing with C and C++ code. KESO FFI uses a static approach like Sun's KNI (see section \ref{sec:related_work}), binding Java and native code at compile time. The Foreign Function Interface of KESO is called \emph{KESO Native Interface (KNI)}, but in this paper we refer to it as KESO FFI, to avoid confusions with Sun's KNI.

% AOP concepts
The design of KESO FFI has adopted some concepts of Aspect-Oriented Programming (AOP) \cite{Kiczales97aspect-orientedprogramming}. Using the KESO FFI API it is possible to ``write'' \emph{point cuts} specifying the \emph{join points} of a Java program (such as Java methods and classes) that will be affected by the given \emph{advices}. The advices in this case, are the codes that represent the native method implementation. The \emph{aspects} that group together \emph{point cuts} and \emph{advices} are represented in KESO FFI API by a \emph{Weavelet} abstract class. Extending the \emph{Weavelet} class and implementing some of its methods it is possible to specify which Java classes and methods should be affected and which native code should be generated. The class figure \ref{fig:weavelet_extension_generic} illustrates this process.

\fig{.4}{weavelet_extension_generic}{Using KESO FFI}

% Optimization questions
The KESO FFI is integrated with the KESO compiler so, during the compilation of Java bytecode to C, instances of weavelets classes are created and used for generating the native code. Although the code specified by a weavelet is not subject of the static analysis performed by the KESO compiler, KESO FFI still presents some interesting advantages. For example, if the KESO compiler identifies that the application code does not use some native method it does not generate the native code for that method, reducing the memory needs.

% Memory-Mapped Objects
Another concept of KESO FFI is the \emph{Memory-Mapped Objects} \cite{Thomm:2010:KOM:1850771.1850788}. A memory-mapped object is a Java object that when created can point to a specific region of the system memory. These kinds of objects are useful to implement direct access to hardware registers.

% System OSEK generation
The OSEK specification states that the operating system's components used by 
the application, such as tasks, alarms, and counters, are automatically generated
from a configuration file. This configuration file is written using \emph{OSEK 
Implementation Language} (OIL). KESO uses a similar configuration file written
using \emph{KESO Configuration Language} (KCL). As shown in figure 
\ref{fig:keso_sys_gen}, KESO Builder takes a KCL file and generates an OIL file
from it. Then the OIL file can be used to generate the OSEK components needed 
by the application.
% inserir figura do KCL file aqui, para "completar" o exemplo da UART?

% -----------------------------------------------------------------------------
%\section{Interfacing hardware devices with very high level languages}
%\input{tex/proposal_v4}
% -----------------------------------------------------------------------------
%\section{Interfacing EPOS components to Java}
% \section{Interfacing hardware devices with very }
\section{Interfacing hardware devices with very high level languages}
\label{sec:proposal}
%Our proposal to interface very high level languages with hardware devices is based in export these devices to the API of the language. The hardware devices to be exported have a well defined interface, using the \emph{hardware mediator} concept of EPOS. We have used the Foreign Function Interface of KESO JVM in order to export EPOS mediators to Java. Using the concepts of application-driven of EPOS and static embedded systems of KESO we can achieve the requirements of embedded systems. This sections aims to explain each one of these steps.
Our proposal to interface very high level languages with hardware devices is based in export these devices to the API of the language. The hardware devices to be exported have a well defined interface, using the \emph{hardware mediator} concept of EPOS. We have used the Foreign Function Interface of KESO JVM in order to export EPOS mediators to Java. Using KESO FFI it is also possible to go beyond the OSEK API provided by KESO. As a example, we show the an implementation of the Java Thread class using KESO FFI and the \emph{Thread} abstraction of EPOS.

\subsection{Accessing hardware devices}
One of the main issues of languages that aim to be used for embedded systems development is to access hardware devices. This is necessary, since embedded systems often use hardware devices to interact with the environment where they are inserted on. EPOS uses the concept of \emph{hardware mediators} in order to abstract specificities from different hardware devices. \emph{Hardware mediators} sustain an interface contract between system abstractions (e.g. threads) and the machine allowing for these abstractions machine-independence. \cite{Polpeta:2004}. For example, a mediator for an Universal Asynchronous Receiver Transmitter (UART) device provides methods to put characters on the UART, to get received characters and to configure some operation parameters of the UART such as bound rate, parity, and data and stop bits. But the generation of the mediator implementation for a specific machine is performed at compile time. Using static meta-programming techniques and function's inlining is possible to dissolve mediators among the abstractions that use it, which avoids time overhead in the use of mediators.
% possivel inserção da figura do mediador e suas várias implementações.

% <P> EPOS mediators e FFI KESO.
We have used KESO FFI to create a binding for each EPOS mediator that should be accessed by Java, providing Java with hardware components. The approach used is shown in figure \ref{fig:approach_v02}. The binding is performed by ``FFI C gen code''. ``KESO C gen code'' represents all code that is automatically generated by KESO compiler and does not belong to the binding. Still in the UART example, the Java class of UART has methods signatures but no implementation, since they are native methods. Then a weavelet class of KESO FFI is used to specify the implementation for each UART method. This implementation is basically a call for each method of the EPOS UART mediator. In the weavelet class is specified which methods of Java UART class that we would like to intercept (our pointcuts) and the respective code that shuld be generated (our advices). The aspects specified in a weavelet class are integrated with the KESO Builder which applies the aspects during the compilation of Java bytecode into C, which will lead into the ``FFI C gen code'' of figure \ref{fig:approach_v02}.

\fig{.3}{approach_v02}{Proposed approach}

% <P> complete application.
%
The main classes used in our UART example application are shown together in Figure \ref{fig:overall_uart_application}. Classes under the dark gray area are written in Java. They correspond to almost all the code written, including the application class \emph{UART\_Test}, the \emph{UART} class on the Java side, and even the \emph{UART\_Weavelet} which specifies the C code that should be generated to bind the Java UART to the EPOS UART mediator. Our application class \emph{UART\_Test} extends the KESO class \emph{Task}. This means that an instance of our class will be implemented by an OSEK task created by KESO, during the system generation. % The \emph{launch} method is the task's entry point.

\fig{.3}{overall_uart_application}{Overall UART application}

%\subsection{Meeting embedded systems requirements}
%ddd

\subsection{OSEK API and beyond}
%<P> OSEK/EPOS layer
The binding code (``FFI C gen code'') can run directly on EPOS, but the code generated by KESO (``KESO C gen code'') needs an operating system that follows the OSEK standard. An OSEK/EPOS layer was recently developed to solve this problem \cite{Bauer:Thesis:2008}. Using this layer, EPOS behaves like any other OSEK operating system and can run Java applications generated by KESO. The OSEK/EPOS layer basically maps OSEK constructions in EPOS abstractions, respecting the OSEK semantics. For instance, OSEK tasks are mapped into EPOS Threads, and OSEK alarms into EPOS alarms.

Using KESO FFI we can go beyond the OSEK API, providing developers with Java 
classes of other APIs and implementing others specifications, such as the Java
Standard Edition API and Java Real Time Specification. In order to demonstrate
this possibility we have implemented the Java SE \emph{Thread} class, using 
KESO FFI and EPOS system abstractions.
Table \ref{tab:thread_mapping} summarizes how we mapped Java Thread methods in
EPOS methods.

\begin{table}[t]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Java} & \textbf{EPOS} \\
\hline
start & Thread::resume \\
\hline
sleep & Alarm::delay \\
\hline
join & Thread::join \\
\hline
\end{tabular}
\caption{Implementing Java Thread class using KESO FFI}
\label{tab:thread_mapping}
\end{center}
\end{table}

	We create a private method \emph{\_entry} in Java Thread class and we mapped
it as the entry point of EPOS Threads. The \emph{\_entry} method calls the 
\emph{run} method of Java Thread class which is empty by default and should be
overwritten by classes that extend Java Thread. EPOS threads were created in
\emph{SUSPENDED} state to fulfill the semantic of Java Threads. So, \emph{start}
method of Java was implemented using the \emph{resume} method of EPOS Thread
class. To implement the static method \emph{sleep} of Java, we used another
system abstraction of EPOS, the \emph{Alarm}.


% -----------------------------------------------------------------------------
\section{Evaluation}
\label{sec:case_study}
In order to evaluate our proposal of interfacing hardware devices with Java, we have used the UART example application mentioned in section \ref{sec:proposal}. The application uses the UART mediator of EPOS to write characters on a serial device. % Figure \ref{prgjava:application} shows the application source code.
Although simple, the application is representative because it can be use to evaluate the main point of interfacing very high level languages and hardware devices, which is time overhead. If the time to access a hardware device using a FFI is bigger than the response time needed then, the use of such FFI becomes impractical. Also the code generated to wrap the abstractions in the lower level language should interferer the minimum possible in the total system size.

The time overhead generated by a FFI can be defined by equation \ref{eq:time_overhead}.
\begin{equation}
\label{eq:time_overhead}
FFI\_Overhead = 1 - \frac{Device\_Execution\_Time} {Total\_Execution\_Time}
\end{equation}
Where Total\_Execution\_Time represents the response time of a native method, including the call to the method, the ``actual'' processing (represented by Device\_Execution\_Time), and the method's return. In our case the \emph{Device\_Execution\_Time} is the time taken by the UART EPOS mediator and the physical UART. 

We have measured the total and the device time of the UART's put method. The method was called 10 thousand times in an application's execution, and the application was executed 30 times. We have used EPOS's \emph{time stamp clock} to compute the time. In order to evaluate the overhead values, we have compared our approach with an UART application developed using Java Standard Edition which uses the Java Native Interface as FFI. We have used the \emph{RXTX} \cite{site:RXTX} library which implements the \emph{Java Communications API} \cite{site:JavaCommAPI}, used for communicating with serial devices. The function \emph{gettimeoftheday} was used to compute the device time, and the Java \emph{System.nanoTime} method was used to compute the total time. Table \ref{tab:time_overhead} shows the obtained values. % Table \ref{tab:time_overhead} shows the results of this comparison.
The JNI based application presents an overhead about 39 times bigger than the overhead obtained using your approach. As we said, high time overhead in a FFI can turn its use impractical.

\begin{table}[t]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{} & \textbf{Total($\mu$$s$)} & \textbf{UART($\mu$$s$)} & \textbf{FFI Overhead}\\
\hline
Proposal & 517.74 & 517.54 & 0.00038 \\
\hline
JSE & 8364683.74 & 8238695.07 & 0.01506 \\
\hline
\end{tabular}
\caption{FFI time overhead}
\label{tab:time_overhead}
\end{center}
\end{table}

In order to estimate the memory overhead generated by our approach, we have measured the footprint of the binary image which contains the whole system. Table \ref{tab:space_overhead} shows the obtained values for the IA32 and Power PC32 architectures. The whole system size including the application, KESO JVM, and EPOS runtime has less than 33KB in both architectures, a suitable value for many embedded hardware platforms.

\begin{table}[t]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{} & \textbf{IA32(byte)} & \textbf{PPC32(byte)} \\
\hline
text & 28645 & 30504 \\
\hline
data & 1180 & 1198 \\
\hline
bass & 1264 & 840 \\
\hline
total & 31089 & 32542 \\
\hline
\end{tabular}
\caption{Total footprint}
\label{tab:space_overhead}
\end{center}
\end{table}


% -----------------------------------------------------------------------------
\section{Discussion}
\label{sec:discussion}
	Applications for embedded systems usually have the necessity to interact
with several kinds of hardware devices such as sensors, actuators, transmitters,
receivers, and timers. 

	Foreign Function Interface is the way adopted by Java to overcome language
limitations and allows for direct memory and hardware devices access. However,
as we showed in section \ref{sec:related_work}, the main Java FFI solutions 
does not provide developers with a resource-efficient way to interfacing with
hardware devices or impose design limitations to this interface.

	In this paper, we have shown a way to interface hardware components with
Java applications for embedded systems. This was achieved using the foreign
function interface of KESO JVM and EPOS.

	EPOS provides for a portable way to interfacing hardware devices with user
applications. This is accomplished by using the concept of hardware mediators
which sustain an interface contract between system abstractions and the machine.

	KESO JVM compiles the bytecode of a Java application to C code and generates 
the parts of JVM needed by the application. The KESO FFI also uses this static
approach generating C code specified by \emph{Weavelet} classes. Then, the C codes
generated by the KESO compiler and by KESO FFI are compiled together to native code
using a standard C compiler. 

	The C code generated by KESO compiler needs an
OSEK operating system to execute. Using an OSEK/EPOS layer, EPOS behaves like an
OSEK OS allowing Java applications to run on it. However, using KESO FFI is 
possible go beyond OSEK API implementing other APIs and specifications. We 
have demonstrated this implementing the Java standard class Thread.

	We have evaluated our approach implementing an UART application. The generated time overhead is less than 0.04 \% of the total execution time. Our solution is 39 times faster than Sun's JNI. We also have evaluated the total footprint of the application. The obtained value of 33KB, including all runtime support, is suitable for many embedded systems.

%------------------------------------------------------------------------------
\bibliographystyle{sbc}
\bibliography{references}


\end{document}

%------------------------------------------------------------------------------



